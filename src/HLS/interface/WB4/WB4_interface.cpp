/*
 *
 *                   _/_/_/    _/_/   _/    _/ _/_/_/    _/_/
 *                  _/   _/ _/    _/ _/_/  _/ _/   _/ _/    _/
 *                 _/_/_/  _/_/_/_/ _/  _/_/ _/   _/ _/_/_/_/
 *                _/      _/    _/ _/    _/ _/   _/ _/    _/
 *               _/      _/    _/ _/    _/ _/_/_/  _/    _/
 *
 *             ***********************************************
 *                              PandA Project
 *                     URL: http://panda.dei.polimi.it
 *                       Politecnico di Milano - DEIB
 *                        System Architectures Group
 *             ***********************************************
 *              Copyright (C) 2004-2024 Politecnico di Milano
 *
 *   This file is part of the PandA framework.
 *
 *   The PandA framework is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
/**
 * @file WB4_interface.cpp
 * @brief Class to generate WB4 interfaces for high-level synthesis
 *
 * This class generates WB4 intefaces for connecting modules to
 * microprocessors or busses
 *
 * @author Marco Minutoli <mminutoli@gmail.com>
 * $Revision$
 * $Date$
 * Last modified by $Author$
 * $Locker:  $
 * $State: Exp $
 *
 */

#include "WB4_interface.hpp"
#include "HDL_manager.hpp"
#include "Parameter.hpp"
#include "application_manager.hpp"
#include "behavioral_helper.hpp"
#include "copyrights_strings.hpp"
#include "hls.hpp"
#include "hls_constraints.hpp"
#include "hls_device.hpp"
#include "hls_manager.hpp"
#include "language_writer.hpp"
#include "memory.hpp"
#include "memory_allocation.hpp"
#include "structural_manager.hpp"
#include "structural_objects.hpp"
#include "technology_manager.hpp"
#include "technology_node.hpp"
#include "technology_wishbone.hpp"
#include "tree_helper.hpp"
#include "tree_manager.hpp"

WB4_interface::WB4_interface(const ParameterConstRef _parameters, const HLS_managerRef _HLSMgr, unsigned int _funId,
                             const DesignFlowManagerConstRef _design_flow_manager,
                             const HLSFlowStep_Type _hls_flow_step_type)
    : minimal_interface(_parameters, _HLSMgr, _funId, _design_flow_manager, _hls_flow_step_type)
{
}

WB4_interface::~WB4_interface() = default;

DesignFlowStep_Status WB4_interface::InternalExec()
{
   // WB4 construction starts on top of the minimal interface.
   minimal_interface::InternalExec();

   const structural_managerRef SM = HLS->top;

   structural_objectRef wrappedObj = SM->get_circ();
   std::string module_name = wrappedObj->get_id() + "_wb4_interface";

   structural_managerRef SM_wb4_interface = structural_managerRef(new structural_manager(parameters));
   structural_type_descriptorRef module_type =
       structural_type_descriptorRef(new structural_type_descriptor(module_name));
   SM_wb4_interface->set_top_info(module_name, module_type);
   structural_objectRef interfaceObj = SM_wb4_interface->get_circ();

   // add the core to the wrapper
   wrappedObj->set_owner(interfaceObj);
   wrappedObj->set_id(wrappedObj->get_id() + "_i0");

   GetPointer<module>(interfaceObj)->add_internal_object(wrappedObj);
   /// Set some descriptions and legal stuff
   GetPointer<module>(interfaceObj)
       ->set_description("WB4 interface for top component: " + wrappedObj->get_typeRef()->id_type);
   GetPointer<module>(interfaceObj)->set_copyright(GENERATED_COPYRIGHT);
   GetPointer<module>(interfaceObj)->set_authors("Component automatically generated by bambu");
   GetPointer<module>(interfaceObj)->set_license(GENERATED_LICENSE);

   build_WB4_bus_interface(SM_wb4_interface);

   build_WB4_complete_logic(SM_wb4_interface, wrappedObj, interfaceObj);

   if(parameters->isOption(OPT_expose_globals) && parameters->getOption<bool>(OPT_expose_globals))
   {
      memory::propagate_memory_parameters(HLS->top->get_circ(), SM_wb4_interface);
   }

   // Generation completed
   HLS->top = SM_wb4_interface;
   return DesignFlowStep_Status::SUCCESS;
}

unsigned long long WB4_interface::get_data_bus_bitsize()
{
   const auto function_behavior = HLSMgr->CGetFunctionBehavior(HLS->functionId);
   const auto behavioral_helper = function_behavior->CGetBehavioralHelper();
   const auto function_parameters = HLSMgr->Rmem->get_function_parameters(HLS->functionId);

   auto data_bus_bitsize = HLSMgr->Rmem->get_bus_data_bitsize();
   for(const auto& function_parameter : function_parameters)
   {
      if(function_parameter.first != HLS->functionId)
      {
         data_bus_bitsize =
             std::max(data_bus_bitsize,
                      tree_helper::SizeAlloc(HLSMgr->get_tree_manager()->GetTreeNode(function_parameter.first)));
      }
   }
   return data_bus_bitsize;
}

unsigned int WB4_interface::get_addr_bus_bitsize()
{
   auto addr_bus_bitsize = HLSMgr->get_address_bitsize();
   auto allocated_space = HLSMgr->Rmem->get_max_address();
   unsigned int parameter_addr_bit = 1;
   while(allocated_space >>= 1)
   {
      ++parameter_addr_bit;
   }

   return std::max(parameter_addr_bit, addr_bus_bitsize);
}

void WB4_interface::build_WB4_bus_interface(structural_managerRef SM)
{
   structural_objectRef interfaceObj = SM->get_circ();

   structural_type_descriptorRef b_type = structural_type_descriptorRef(new structural_type_descriptor("bool", 1));

   auto data_bus_bitsize = get_data_bus_bitsize();
   auto addr_bus_bitsize = get_addr_bus_bitsize();

   structural_type_descriptorRef sel_type =
       structural_type_descriptorRef(new structural_type_descriptor("bool", data_bus_bitsize / 8));
   structural_type_descriptorRef addr_type =
       structural_type_descriptorRef(new structural_type_descriptor("bool", addr_bus_bitsize));
   structural_type_descriptorRef data_type =
       structural_type_descriptorRef(new structural_type_descriptor("bool", data_bus_bitsize));

   // Parameters
   std::string functionName = tree_helper::name_function(HLSMgr->get_tree_manager(), HLS->functionId);
   memory::add_memory_parameter(SM, STR(WB_BASE_ADDRESS) + "_" + functionName, STR(0));

   // Common Inputs
   SM->add_port(CLOCK_PORT_NAME, port_o::IN, interfaceObj, b_type);
   SM->add_port(RESET_PORT_NAME, port_o::IN, interfaceObj, b_type);
   SM->add_port(WB_IRQ_PORT_NAME, port_o::OUT, interfaceObj, b_type);

   // Master Inputs
   SM->add_port(WB_DATIM_PORT_NAME, port_o::IN, interfaceObj, data_type);
   SM->add_port(WB_ACKIM_PORT_NAME, port_o::IN, interfaceObj, b_type);

   // Master Outputs
   SM->add_port(WB_CYCOM_PORT_NAME, port_o::OUT, interfaceObj, b_type);
   SM->add_port(WB_STBOM_PORT_NAME, port_o::OUT, interfaceObj, b_type);
   SM->add_port(WB_WEOM_PORT_NAME, port_o::OUT, interfaceObj, b_type);
   SM->add_port(WB_ADDROM_PORT_NAME, port_o::OUT, interfaceObj, addr_type);
   SM->add_port(WB_DATOM_PORT_NAME, port_o::OUT, interfaceObj, data_type);
   SM->add_port(WB_SELOM_PORT_NAME, port_o::OUT, interfaceObj, sel_type);

   // Slave Inputs
   SM->add_port(WB_CYCIS_PORT_NAME, port_o::IN, interfaceObj, b_type);
   SM->add_port(WB_STBIS_PORT_NAME, port_o::IN, interfaceObj, b_type);
   SM->add_port(WB_WEIS_PORT_NAME, port_o::IN, interfaceObj, b_type);
   SM->add_port(WB_ADDRIS_PORT_NAME, port_o::IN, interfaceObj, addr_type);
   SM->add_port(WB_DATIS_PORT_NAME, port_o::IN, interfaceObj, data_type);
   SM->add_port(WB_SELIS_PORT_NAME, port_o::IN, interfaceObj, sel_type);

   // Slave Outputs
   SM->add_port(WB_DATOS_PORT_NAME, port_o::OUT, interfaceObj, data_type);
   SM->add_port(WB_ACKOS_PORT_NAME, port_o::OUT, interfaceObj, b_type);
}

void WB4_interface::connect_with_signal_name(structural_managerRef SM, structural_objectRef portA,
                                             structural_objectRef portB, std::string signalName)
{
   structural_objectRef signA = GetPointer<port_o>(portA)->get_connected_signal();
   structural_objectRef signB = GetPointer<port_o>(portB)->get_connected_signal();

   THROW_ASSERT(portA->get_kind() == port_o_K && portB->get_kind() == port_o_K,
                "WB4 Interface portA = " + portA->get_path() + " portB = " + portB->get_path());

   // std::cerr << "CONNECT SIGNAL NAME: " << signalName << "\n";
   // std::cerr << "CONNECT SIGNAL: size A = " << GET_TYPE_SIZE(portA)
   //   << " size B = " << GET_TYPE_SIZE(portB) << "\n";
   if(!signA && !signB)
   {
      structural_objectRef sign;
      if(GET_TYPE_SIZE(portA) < GET_TYPE_SIZE(portB))
      {
         // std::cerr << "using size A\n";
         sign = SM->add_sign(signalName, SM->get_circ(), portA->get_typeRef());
      }
      else
      {
         // std::cerr << "using size B\n";
         sign = SM->add_sign(signalName, SM->get_circ(), portB->get_typeRef());
      }
      SM->add_connection(portA, sign);
      SM->add_connection(sign, portB);
   }
   else if(!signA && signB)
   {
      SM->add_connection(portA, signB);
   }
   else if(!signB && signA)
   {
      SM->add_connection(portB, signA);
   }
   else if(signA && signB)
   {
      SM->add_connection(signA, signB);
   }
}

void WB4_interface::connect_with_signal_name(structural_managerRef SM, structural_objectRef A, std::string Asignal,
                                             structural_objectRef B, std::string Bsignal, const std::string& signalName)
{
   structural_objectRef port1 = A->find_member(Asignal, port_o_K, A);
   structural_objectRef port2 = B->find_member(Bsignal, port_o_K, B);
   connect_with_signal_name(SM, port1, port2, signalName);
}

void WB4_interface::connect_with_signal_name(structural_managerRef SM, structural_objectRef APort,
                                             structural_objectRef B, std::string Bsignal, const std::string& signalName)
{
   structural_objectRef port1 = B->find_member(Bsignal, port_o_K, B);
   connect_with_signal_name(SM, APort, port1, signalName);
}

void WB4_interface::connect_with_signal(structural_managerRef SM, structural_objectRef portA,
                                        structural_objectRef portB)
{
   connect_with_signal_name(SM, portA, portB, portA->get_id() + "_INT");
}

void WB4_interface::connect_with_signal(structural_managerRef SM, structural_objectRef A, std::string Asignal,
                                        structural_objectRef B, std::string Bsignal)
{
   structural_objectRef port1 = A->find_member(Asignal, port_o_K, A);
   structural_objectRef port2 = B->find_member(Bsignal, port_o_K, B);
   connect_with_signal(SM, port1, port2);
}

void WB4_interface::connect_with_signal(structural_managerRef SM, structural_objectRef APort, structural_objectRef B,
                                        std::string Bsignal)
{
   structural_objectRef port2 = B->find_member(Bsignal, port_o_K, B);
   connect_with_signal(SM, APort, port2);
}

void WB4_interface::connect_with_signal(structural_managerRef SM, structural_objectRef A, std::string Asignal,
                                        structural_objectRef portB)
{
   structural_objectRef port1 = A->find_member(Asignal, port_o_K, A);
   connect_with_signal(SM, port1, portB);
}

void WB4_interface::build_WB4_complete_logic(structural_managerRef SM, structural_objectRef wrappedObj,
                                             structural_objectRef interfaceObj)
{
   // Master OUT
   structural_objectRef Mout_data_ram_size_port = wrappedObj->find_member("Mout_data_ram_size", port_o_K, wrappedObj);
   structural_objectRef Mout_Wdata_ram_port = wrappedObj->find_member("Mout_Wdata_ram", port_o_K, wrappedObj);
   structural_objectRef Mout_addr_ram_port = wrappedObj->find_member("Mout_addr_ram", port_o_K, wrappedObj);
   structural_objectRef Mout_we_ram_port = wrappedObj->find_member("Mout_we_ram", port_o_K, wrappedObj);
   structural_objectRef Mout_oe_ram_port = wrappedObj->find_member("Mout_oe_ram", port_o_K, wrappedObj);
   // Master IN
   structural_objectRef M_DataRdy_port = wrappedObj->find_member("M_DataRdy", port_o_K, wrappedObj);
   structural_objectRef M_Rdata_ram_port = wrappedObj->find_member("M_Rdata_ram", port_o_K, wrappedObj);
   // Slave OUT
   structural_objectRef Sout_DataRdy_port = wrappedObj->find_member("Sout_DataRdy", port_o_K, wrappedObj);
   structural_objectRef Sout_Rdata_ram_port = wrappedObj->find_member("Sout_Rdata_ram", port_o_K, wrappedObj);
   // Slave IN
   structural_objectRef S_data_ram_size_port = wrappedObj->find_member("S_data_ram_size", port_o_K, wrappedObj);
   structural_objectRef S_Wdata_ram_port = wrappedObj->find_member("S_Wdata_ram", port_o_K, wrappedObj);
   structural_objectRef S_addr_ram_port = wrappedObj->find_member("S_addr_ram", port_o_K, wrappedObj);
   structural_objectRef S_we_ram_port = wrappedObj->find_member("S_we_ram", port_o_K, wrappedObj);
   structural_objectRef S_oe_ram_port = wrappedObj->find_member("S_oe_ram", port_o_K, wrappedObj);

   // check consitency of the interfaces
   bool is_slave = false, is_master = false;
   bool only_mm_parameters_allocated =
       HLSMgr->Rmem->get_allocated_parameters_memory() == HLSMgr->Rmem->get_allocated_internal_memory();

   if(S_data_ram_size_port && S_Wdata_ram_port && S_addr_ram_port && S_we_ram_port && S_oe_ram_port &&
      Sout_DataRdy_port && Sout_Rdata_ram_port)
   {
      is_slave = true;
   }
   else if(!S_data_ram_size_port && !S_Wdata_ram_port && !S_addr_ram_port && !S_we_ram_port && !S_oe_ram_port &&
           !Sout_DataRdy_port && !Sout_Rdata_ram_port)
   {
      is_slave = false;
   }
   else
   {
      THROW_UNREACHABLE("Inconsistent slave interface");
   }

   if(Mout_data_ram_size_port && Mout_Wdata_ram_port && Mout_addr_ram_port && Mout_we_ram_port && Mout_oe_ram_port &&
      M_DataRdy_port && M_Rdata_ram_port)
   {
      is_master = true;
   }
   else if(!Mout_data_ram_size_port && !Mout_Wdata_ram_port && !Mout_addr_ram_port && !Mout_we_ram_port &&
           !Mout_oe_ram_port && !M_DataRdy_port && !M_Rdata_ram_port)
   {
      is_master = false;
   }
   else
   {
      THROW_UNREACHABLE("Inconsistent master interface");
   }

   // check memory allocation consistency
   if(HLSMgr->Rmem->get_max_address() > parameters->getOption<unsigned long long int>(OPT_base_address))
   {
      THROW_ERROR("Internal memory addresses overlap with the external addresses: change the base address value with "
                  "--base-address");
   }

   // Connect clock, start, reset and done port since they are always present
   SM->add_connection(interfaceObj->find_member(CLOCK_PORT_NAME, port_o_K, interfaceObj),
                      wrappedObj->find_member(CLOCK_PORT_NAME, port_o_K, wrappedObj));

   SM->add_connection(interfaceObj->find_member(RESET_PORT_NAME, port_o_K, interfaceObj),
                      wrappedObj->find_member(RESET_PORT_NAME, port_o_K, wrappedObj));

   connect_with_signal_name(SM, wrappedObj, DONE_PORT_NAME, interfaceObj, WB_IRQ_PORT_NAME,
                            STR(DONE_PORT_NAME) + "_INT");

   auto data_bus_bitsize = get_data_bus_bitsize();
   auto addr_bus_bitsize = get_addr_bus_bitsize();

   structural_type_descriptorRef addr_type =
       structural_type_descriptorRef(new structural_type_descriptor("bool", addr_bus_bitsize));

   structural_type_descriptorRef data_type =
       structural_type_descriptorRef(new structural_type_descriptor("bool", data_bus_bitsize));

   structural_type_descriptorRef sel_type =
       structural_type_descriptorRef(new structural_type_descriptor("bool", data_bus_bitsize / 8));

   std::string functionName = tree_helper::name_function(HLSMgr->get_tree_manager(), HLS->functionId);
   std::string baseAddressParameter = STR(WB_BASE_ADDRESS) + "_" + functionName;
   // ---- Add the master output control logic ----
   structural_objectRef signControl;
   structural_objectRef signControl_delayed;
   if(is_master)
   {
      PRINT_DBG_MEX(OUTPUT_LEVEL_VERBOSE, debug_level, "Adding master output control logic");
      connect_with_signal(SM, Mout_we_ram_port, interfaceObj->find_member(WB_WEOM_PORT_NAME, port_o_K, interfaceObj));

      structural_objectRef orGateReWe = SM->add_module_from_technology_library(
          "orGateReWe", OR_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());

      structural_objectRef port_objReWe = orGateReWe->find_member("in", port_o_K, orGateReWe);
      auto* in_portReWe = GetPointer<port_o>(port_objReWe);
      in_portReWe->add_n_ports(2, port_objReWe);

      connect_with_signal(SM, Mout_we_ram_port, in_portReWe->get_port(0));
      connect_with_signal(SM, Mout_oe_ram_port, in_portReWe->get_port(1));

      structural_objectRef notGateSTB = SM->add_module_from_technology_library(
          "notGateSTB", NOT_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());

      SM->add_connection(interfaceObj->find_member(WB_ACKIM_PORT_NAME, port_o_K, interfaceObj),
                         notGateSTB->find_member("in1", port_o_K, notGateSTB));

      structural_objectRef andGateSTB = SM->add_module_from_technology_library(
          "andGateSTB", AND_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());

      structural_objectRef port_objAndSTB = andGateSTB->find_member("in", port_o_K, andGateSTB);
      auto* in_portAndSTB = GetPointer<port_o>(port_objAndSTB);
      in_portAndSTB->add_n_ports(2, port_objAndSTB);

      connect_with_signal_name(SM, notGateSTB->find_member("out1", port_o_K, notGateSTB), in_portAndSTB->get_port(1),
                               "NotAckIM");
      SM->add_connection(andGateSTB->find_member("out1", port_o_K, andGateSTB),
                         interfaceObj->find_member(WB_STBOM_PORT_NAME, port_o_K, interfaceObj));

      if(is_slave) // add the control logic for the multiplexers
      {
         PRINT_DBG_MEX(OUTPUT_LEVEL_VERBOSE, debug_level, "Adding mux control logic");

         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Adding addressRangeChecker");
         structural_objectRef addressRangeChecker =
             SM->add_module_from_technology_library("addressRangeChecker", ADDRESS_RANGE_CHECKER_WB, WBLIBRARY,
                                                    interfaceObj, HLS->HLS_D->get_technology_manager());

         structural_objectRef arcAddress = addressRangeChecker->find_member("address", port_o_K, addressRangeChecker);
         GetPointer<port_o>(arcAddress)->set_type(addr_type);
         connect_with_signal(SM, Mout_addr_ram_port, arcAddress);

         structural_objectRef arcBase = addressRangeChecker->find_member("base", port_o_K, addressRangeChecker);
         GetPointer<port_o>(arcBase)->set_type(addr_type);

         structural_objectRef arcMaxAddress =
             addressRangeChecker->find_member("max_address", port_o_K, addressRangeChecker);
         GetPointer<port_o>(arcMaxAddress)->set_type(addr_type);

         structural_objectRef constBaseAddress = SM->add_module_from_technology_library(
             "const_base_address", CONSTANT_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());

         structural_objectRef constBaseAddressOut1 = constBaseAddress->find_member("out1", port_o_K, constBaseAddress);
         GetPointer<port_o>(constBaseAddressOut1)->set_type(addr_type);
         constBaseAddress->SetParameter("value", baseAddressParameter + " + " +
                                                     STR(HLSMgr->Rmem->get_first_address(HLS->functionId)));
         connect_with_signal(SM, addressRangeChecker, "base", constBaseAddress, "out1");

         structural_objectRef constMaxAddress = SM->add_module_from_technology_library(
             "const_max_address", CONSTANT_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());

         structural_objectRef constMaxAddressOut1 = constMaxAddress->find_member("out1", port_o_K, constMaxAddress);
         GetPointer<port_o>(constMaxAddressOut1)->set_type(addr_type);
         constMaxAddress->SetParameter("value", baseAddressParameter + " + " +
                                                    STR(HLSMgr->Rmem->get_last_address(HLS->functionId, HLSMgr)));
         connect_with_signal(SM, addressRangeChecker, "max_address", constMaxAddress, "out1");
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Added addressRangeChecker");

         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Adding control signal");
         structural_objectRef internalNotGate = SM->add_module_from_technology_library(
             "internalNotGate", NOT_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());
         connect_with_signal_name(SM, addressRangeChecker, "isInRange", internalNotGate, "in1", "internal");
         structural_objectRef signNotInternal =
             SM->add_sign("notInternal", SM->get_circ(),
                          internalNotGate->find_member("out1", port_o_K, internalNotGate)->get_typeRef());
         SM->add_connection(internalNotGate->find_member("out1", port_o_K, internalNotGate), signNotInternal);
         if(!only_mm_parameters_allocated)
         {
            structural_objectRef orGateControl = SM->add_module_from_technology_library(
                "orGateControl", OR_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());
            structural_objectRef port_objControl = orGateControl->find_member("in", port_o_K, orGateControl);
            auto* in_portControl = GetPointer<port_o>(port_objControl);
            in_portControl->add_n_ports(2, port_objControl);

            SM->add_connection(signNotInternal, in_portControl->get_port(0));
            SM->add_connection(interfaceObj->find_member(WB_STBIS_PORT_NAME, port_o_K, interfaceObj),
                               in_portControl->get_port(1));

            signControl = SM->add_sign("control", SM->get_circ(), in_portControl->get_port(0)->get_typeRef());
            SM->add_connection(signControl, orGateControl->find_member("out1", port_o_K, orGateControl));
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Added control signal");

            const auto memory_allocation_policy = HLSMgr->CGetFunctionBehavior(funId)->GetMemoryAllocationPolicy();
            const auto Has_extern_allocated_data =
                ((HLSMgr->Rmem->get_memory_address() - HLSMgr->base_address) > 0 &&
                 memory_allocation_policy != MemoryAllocation_Policy::EXT_PIPELINED_BRAM) ||
                (HLSMgr->Rmem->has_unknown_addresses() &&
                 memory_allocation_policy != MemoryAllocation_Policy::ALL_BRAM &&
                 memory_allocation_policy != MemoryAllocation_Policy::EXT_PIPELINED_BRAM);
            if(Has_extern_allocated_data)
            {
               signControl_delayed = signControl;
            }
            else
            {
               PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Adding delayed mux control logic");
               structural_objectRef internalNotGate_delayed =
                   SM->add_module_from_technology_library("internalNotGate_delayed", NOT_INTERNAL_COMPONENT, WBLIBRARY,
                                                          interfaceObj, HLS->HLS_D->get_technology_manager());

               connect_with_signal_name(SM, addressRangeChecker, "isInRange", internalNotGate_delayed, "internal1",
                                        "internal");
               structural_objectRef port_ck1 =
                   internalNotGate_delayed->find_member(CLOCK_PORT_NAME, port_o_K, internalNotGate_delayed);
               structural_objectRef clock1 = interfaceObj->find_member(CLOCK_PORT_NAME, port_o_K, interfaceObj);

               SM->add_connection(port_ck1, clock1);
               connect_with_signal(SM, Mout_we_ram_port, internalNotGate_delayed, "we1");
               connect_with_signal(SM, Mout_oe_ram_port, internalNotGate_delayed, "oe1");

               structural_objectRef orGateControl_delayed =
                   SM->add_module_from_technology_library("orGateControl_delayed", OR_GATE_STD, LIBRARY_STD,
                                                          interfaceObj, HLS->HLS_D->get_technology_manager());
               structural_objectRef port_objControl_delayed =
                   orGateControl_delayed->find_member("in", port_o_K, orGateControl_delayed);
               auto* in_portControl_delayed = GetPointer<port_o>(port_objControl_delayed);
               in_portControl_delayed->add_n_ports(2, port_objControl_delayed);

               structural_objectRef signNotInternal_delayed = SM->add_sign(
                   "notInternal_delayed", SM->get_circ(), in_portControl_delayed->get_port(0)->get_typeRef());

               SM->add_connection(signNotInternal_delayed,
                                  internalNotGate_delayed->find_member("out1", port_o_K, internalNotGate_delayed));
               SM->add_connection(signNotInternal_delayed, in_portControl_delayed->get_port(0));
               SM->add_connection(in_portControl_delayed->get_port(1),
                                  interfaceObj->find_member(WB_STBIS_PORT_NAME, port_o_K, interfaceObj));

               signControl_delayed =
                   SM->add_sign("control_delayed", SM->get_circ(), in_portControl->get_port(0)->get_typeRef());
               SM->add_connection(signControl_delayed,
                                  orGateControl_delayed->find_member("out1", port_o_K, orGateControl_delayed));
               PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Added delayed mux control logic");
            }
         }

         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting mux control logic to master output logic");
         structural_objectRef andGateStbCyc = SM->add_module_from_technology_library(
             "andGateStbCyc", AND_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());

         structural_objectRef port_objStbCyc = andGateStbCyc->find_member("in", port_o_K, andGateStbCyc);
         auto* in_portStbCyc = GetPointer<port_o>(port_objStbCyc);
         in_portStbCyc->add_n_ports(2, port_objStbCyc);

         SM->add_connection(signNotInternal, in_portStbCyc->get_port(1));
         connect_with_signal_name(SM, orGateReWe->find_member("out1", port_o_K, orGateReWe), in_portStbCyc->get_port(0),
                                  "Mout_we_or_oe");

         connect_with_signal_name(SM, andGateStbCyc->find_member("out1", port_o_K, andGateStbCyc),
                                  in_portAndSTB->get_port(0), "StbCyc");
         connect_with_signal_name(SM, andGateStbCyc->find_member("out1", port_o_K, andGateStbCyc),
                                  interfaceObj->find_member(WB_CYCOM_PORT_NAME, port_o_K, interfaceObj), "StbCyc");
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected mux control logic to master output logic");

         PRINT_DBG_MEX(OUTPUT_LEVEL_VERBOSE, debug_level, "Added mux control logic");
      }
      else // no need for multiplexers nor range checker. master output control logic is also easier
      {
         connect_with_signal_name(SM, orGateReWe->find_member("out1", port_o_K, orGateReWe),
                                  interfaceObj->find_member(WB_CYCOM_PORT_NAME, port_o_K, interfaceObj),
                                  "Mout_we_or_oe");
         connect_with_signal_name(SM, orGateReWe->find_member("out1", port_o_K, orGateReWe), in_portAndSTB->get_port(0),
                                  "Mout_we_or_oe");
      }
      PRINT_DBG_MEX(OUTPUT_LEVEL_VERBOSE, debug_level, "Added master output control logic");
   }

   THROW_ASSERT(((is_master && is_slave) && ((signControl && signControl_delayed) || only_mm_parameters_allocated)) ||
                    (!(is_master && is_slave) && !signControl && !signControl_delayed),
                "If we have both master and slave we need control signals for multiplexers");

   // ---- Add the slave input R/W enable signals ----
   if(is_slave)
   {
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Adding slave input R/W enable logic");
      structural_objectRef andGateWeICS = SM->add_module_from_technology_library(
          "andGateWeICS", AND_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());
      structural_objectRef port_objWeICS = andGateWeICS->find_member("in", port_o_K, andGateWeICS);
      auto* in_portWeICS = GetPointer<port_o>(port_objWeICS);
      in_portWeICS->add_n_ports(3, port_objWeICS);

      SM->add_connection(interfaceObj->find_member(WB_WEIS_PORT_NAME, port_o_K, interfaceObj),
                         in_portWeICS->get_port(0));
      SM->add_connection(interfaceObj->find_member(WB_STBIS_PORT_NAME, port_o_K, interfaceObj),
                         in_portWeICS->get_port(1));
      SM->add_connection(interfaceObj->find_member(WB_CYCIS_PORT_NAME, port_o_K, interfaceObj),
                         in_portWeICS->get_port(2));

      structural_objectRef weISNotGate = SM->add_module_from_technology_library(
          "weISNotGate", NOT_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());
      SM->add_connection(interfaceObj->find_member(WB_WEIS_PORT_NAME, port_o_K, interfaceObj),
                         weISNotGate->find_member("in1", port_o_K, weISNotGate));

      structural_objectRef andGateReICS = SM->add_module_from_technology_library(
          "andGateReICS", AND_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());
      structural_objectRef port_objReICS = andGateReICS->find_member("in", port_o_K, andGateReICS);
      auto* in_portReICS = GetPointer<port_o>(port_objReICS);
      in_portReICS->add_n_ports(3, port_objReICS);

      structural_objectRef signNotWeIS =
          SM->add_sign("notWeIS", SM->get_circ(), in_portReICS->get_port(0)->get_typeRef());

      SM->add_connection(weISNotGate->find_member("out1", port_o_K, weISNotGate), signNotWeIS);
      SM->add_connection(signNotWeIS, in_portReICS->get_port(0));
      SM->add_connection(interfaceObj->find_member(WB_STBIS_PORT_NAME, port_o_K, interfaceObj),
                         in_portReICS->get_port(1));
      SM->add_connection(interfaceObj->find_member(WB_CYCIS_PORT_NAME, port_o_K, interfaceObj),
                         in_portReICS->get_port(2));
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Added slave input R/W enable logic");
      if(is_master)
      {
         if(only_mm_parameters_allocated)
         {
            connect_with_signal_name(SM, S_we_ram_port, andGateWeICS, "out1", "weI_CS");
            connect_with_signal_name(SM, S_oe_ram_port, andGateReICS, "out1", "reI_CS");
         }
         else
         {
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting weMux");
            // insert weMux
            structural_objectRef weMux = SM->add_module_from_technology_library(
                "weMux", MUX_GATE_STD, HLS->HLS_D->get_technology_manager()->get_library(MUX_GATE_STD), interfaceObj,
                HLS->HLS_D->get_technology_manager());

            connect_with_signal_name(SM, andGateWeICS, "out1", weMux, "in1", "weI_CS");
            connect_with_signal(SM, Mout_we_ram_port, weMux->find_member("in2", port_o_K, weMux));
            connect_with_signal(SM, S_we_ram_port, weMux->find_member("out1", port_o_K, weMux));
            SM->add_connection(signControl, weMux->find_member("sel", port_o_K, weMux));
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserted weMux");
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting oeMux");
            // insert oeMux
            structural_objectRef oeMux = SM->add_module_from_technology_library(
                "oeMux", MUX_GATE_STD, HLS->HLS_D->get_technology_manager()->get_library(MUX_GATE_STD), interfaceObj,
                HLS->HLS_D->get_technology_manager());

            connect_with_signal_name(SM, andGateReICS, "out1", oeMux, "in1", "reI_CS");
            connect_with_signal(SM, Mout_oe_ram_port, oeMux->find_member("in2", port_o_K, oeMux));
            connect_with_signal(SM, S_oe_ram_port, oeMux->find_member("out1", port_o_K, oeMux));
            SM->add_connection(signControl, oeMux->find_member("sel", port_o_K, oeMux));
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserted oeMux");
         }
      }
      else
      {
         // no need for multiplexing, connect directly
         connect_with_signal_name(SM, S_we_ram_port, andGateWeICS, "out1", "weI_CS");
         connect_with_signal_name(SM, S_oe_ram_port, andGateReICS, "out1", "reI_CS");
      }
   }

   // ---- Add the Wdata logic ----
   if(is_master)
   {
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting Mout_Wdata_ram");
      connect_with_signal(SM, Mout_Wdata_ram_port,
                          interfaceObj->find_member(WB_DATOM_PORT_NAME, port_o_K, interfaceObj));
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected Mout_Wdata_ram");
   }
   if(is_slave)
   {
      if(is_master)
      {
         if(only_mm_parameters_allocated)
         {
            connect_with_signal(SM, S_Wdata_ram_port,
                                interfaceObj->find_member(WB_DATIS_PORT_NAME, port_o_K, interfaceObj));
         }
         else
         {
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting wDataMux");
            structural_objectRef wDataMux = SM->add_module_from_technology_library(
                "wDataMux", MUX_GATE_STD, HLS->HLS_D->get_technology_manager()->get_library(MUX_GATE_STD), interfaceObj,
                HLS->HLS_D->get_technology_manager());

            structural_objectRef wDataMuxIn1 = wDataMux->find_member("in1", port_o_K, wDataMux);
            GetPointer<port_o>(wDataMuxIn1)->set_type(data_type);

            structural_objectRef wDataMuxIn2 = wDataMux->find_member("in2", port_o_K, wDataMux);
            GetPointer<port_o>(wDataMuxIn2)->set_type(data_type);

            structural_objectRef wDataMuxOut1 = wDataMux->find_member("out1", port_o_K, wDataMux);
            GetPointer<port_o>(wDataMuxOut1)->set_type(data_type);

            SM->add_connection(interfaceObj->find_member(WB_DATIS_PORT_NAME, port_o_K, interfaceObj), wDataMuxIn1);
            connect_with_signal(SM, Mout_Wdata_ram_port, wDataMuxIn2);
            connect_with_signal(SM, S_Wdata_ram_port, wDataMuxOut1);
            SM->add_connection(signControl, wDataMux->find_member("sel", port_o_K, wDataMux));
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserted wDataMux");
         }
      }
      else
      {
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting S_Wdata_ram");
         connect_with_signal(SM, S_Wdata_ram_port,
                             interfaceObj->find_member(WB_DATIS_PORT_NAME, port_o_K, interfaceObj));
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected S_Wdata_ram");
      }
      // ---- Add the Rdata logic ----
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting Sout_Rdata_ram");
      connect_with_signal(SM, Sout_Rdata_ram_port,
                          interfaceObj->find_member(WB_DATOS_PORT_NAME, port_o_K, interfaceObj));
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected Sout_Rdata_ram");
   }

   if(is_master)
   {
      if(is_slave)
      {
         if(only_mm_parameters_allocated)
         {
            connect_with_signal(SM, M_Rdata_ram_port,
                                interfaceObj->find_member(WB_DATIM_PORT_NAME, port_o_K, interfaceObj));
         }
         else
         {
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting rDataMux");
            structural_objectRef rDataMux = SM->add_module_from_technology_library(
                "rDataMux", MUX_GATE_STD, HLS->HLS_D->get_technology_manager()->get_library(MUX_GATE_STD), interfaceObj,
                HLS->HLS_D->get_technology_manager());

            structural_objectRef rDataMuxIn1 = rDataMux->find_member("in1", port_o_K, rDataMux);
            GetPointer<port_o>(rDataMuxIn1)->set_type(data_type);

            structural_objectRef rDataMuxIn2 = rDataMux->find_member("in2", port_o_K, rDataMux);
            GetPointer<port_o>(rDataMuxIn2)->set_type(data_type);

            structural_objectRef rDataMuxOut1 = rDataMux->find_member("out1", port_o_K, rDataMux);
            GetPointer<port_o>(rDataMuxOut1)->set_type(data_type);

            SM->add_connection(interfaceObj->find_member(WB_DATIM_PORT_NAME, port_o_K, interfaceObj), rDataMuxIn1);
            connect_with_signal(SM, Sout_Rdata_ram_port, rDataMuxIn2);
            connect_with_signal(SM, M_Rdata_ram_port, rDataMuxOut1);
            SM->add_connection(signControl_delayed, rDataMux->find_member("sel", port_o_K, rDataMux));
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserted rDataMux");
         }
      }
      else
      {
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting Sout_Rdata_ram");
         connect_with_signal(SM, M_Rdata_ram_port,
                             interfaceObj->find_member(WB_DATIM_PORT_NAME, port_o_K, interfaceObj));
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected Sout_Rdata_ram");
      }
   }

   // ---- Data Ram Size Logic ----
   structural_type_descriptorRef drs_type;
   if(is_master)
   {
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting master dataRamSizeConverter");
      drs_type = Mout_data_ram_size_port->get_typeRef();
      structural_objectRef dataRamSizeConverter =
          SM->add_module_from_technology_library("dataRamSizeConverter", DATARAMSIZE_CONVERTER_WB, WBLIBRARY,
                                                 interfaceObj, HLS->HLS_D->get_technology_manager());

      structural_objectRef dRSCIn = dataRamSizeConverter->find_member("dataRamSize", port_o_K, dataRamSizeConverter);
      GetPointer<port_o>(dRSCIn)->set_type(drs_type);

      structural_objectRef dRSCOut = dataRamSizeConverter->find_member("sel", port_o_K, dataRamSizeConverter);
      GetPointer<port_o>(dRSCOut)->set_type(sel_type);

      connect_with_signal(SM, interfaceObj, WB_SELOM_PORT_NAME, dataRamSizeConverter, "sel");
      connect_with_signal(SM, Mout_data_ram_size_port, dataRamSizeConverter, "dataRamSize");
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserted master dataRamSizeConverter");
   }

   if(is_slave)
   {
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting slave selConverter");

      drs_type = S_data_ram_size_port->get_typeRef();
      // sel converter
      structural_objectRef selConverter = SM->add_module_from_technology_library(
          "selConverter", SEL_CONVERTER_WB, WBLIBRARY, interfaceObj, HLS->HLS_D->get_technology_manager());

      structural_objectRef selCOut = selConverter->find_member("dataRamSize", port_o_K, selConverter);
      GetPointer<port_o>(selCOut)->set_type(drs_type);

      structural_objectRef selCIn = selConverter->find_member("sel", port_o_K, selConverter);
      GetPointer<port_o>(selCIn)->set_type(sel_type);

      SM->add_connection(interfaceObj->find_member(WB_SELIS_PORT_NAME, port_o_K, interfaceObj),
                         selConverter->find_member("sel", port_o_K, selConverter));

      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserted slave selConverter");

      if(is_master)
      {
         if(only_mm_parameters_allocated)
         {
            connect_with_signal(SM, S_data_ram_size_port, selCOut);
         }
         else
         {
            THROW_ASSERT(structural_type_descriptor::check_type(drs_type, Mout_data_ram_size_port->get_typeRef()),
                         "Mout_data_ram_size->get_typeRef() != S_data_ram_size->get_typeRef()");
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting dRSMux");
            structural_objectRef dRSMux = SM->add_module_from_technology_library(
                "dRSMux", MUX_GATE_STD, HLS->HLS_D->get_technology_manager()->get_library(MUX_GATE_STD), interfaceObj,
                HLS->HLS_D->get_technology_manager());

            structural_objectRef dRSMuxIn1 = dRSMux->find_member("in1", port_o_K, dRSMux);
            GetPointer<port_o>(dRSMuxIn1)->set_type(drs_type);
            structural_objectRef dRSMuxIn2 = dRSMux->find_member("in2", port_o_K, dRSMux);
            GetPointer<port_o>(dRSMuxIn2)->set_type(drs_type);
            structural_objectRef dRSMuxOut1 = dRSMux->find_member("out1", port_o_K, dRSMux);
            GetPointer<port_o>(dRSMuxOut1)->set_type(drs_type);

            connect_with_signal(SM, Mout_data_ram_size_port, dRSMuxIn2);
            connect_with_signal_name(SM, dRSMuxIn1, selConverter, "dataRamSize", "sel_is_c");
            connect_with_signal(SM, S_data_ram_size_port, dRSMuxOut1);
            SM->add_connection(signControl, dRSMux->find_member("sel", port_o_K, dRSMux));
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserted dRSMux");
         }
      }
      else
      {
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting S_data_ram_size");
         connect_with_signal_name(SM, S_data_ram_size_port, selCOut, "sel_is_c");
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected S_data_ram_size");
      }
   }

   // ---- Address decoding/encoding logic ----
   if(is_master)
   {
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting Mout_addr_ram");
      connect_with_signal(SM, Mout_addr_ram_port,
                          interfaceObj->find_member(WB_ADDROM_PORT_NAME, port_o_K, interfaceObj));
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected Mout_addr_ram");
   }

   if(is_slave)
   {
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Adding slave addressFilter");
      structural_objectRef addressFilterAddrIS = SM->add_module_from_technology_library(
          "addressFilterAddrIS", ADDRESS_FILTER_WB, WBLIBRARY, interfaceObj, HLS->HLS_D->get_technology_manager());
      GetPointer<module>(addressFilterAddrIS)
          ->SetParameter("MAX_ADDRESS",
                         baseAddressParameter + " + " + STR(HLSMgr->Rmem->get_last_address(HLS->functionId, HLSMgr)));

      structural_objectRef afAddrISIn1 = addressFilterAddrIS->find_member("in1", port_o_K, addressFilterAddrIS);
      GetPointer<port_o>(afAddrISIn1)->set_type(addr_type);

      structural_objectRef afAddrISOut1 = addressFilterAddrIS->find_member("out1", port_o_K, addressFilterAddrIS);
      GetPointer<port_o>(afAddrISOut1)->set_type(addr_type);

      SM->add_connection(interfaceObj->find_member(WB_ADDRIS_PORT_NAME, port_o_K, interfaceObj), afAddrISIn1);
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Added slave addressFilter");

      if(is_master)
      {
         if(only_mm_parameters_allocated)
         {
            connect_with_signal(SM, S_addr_ram_port, afAddrISOut1);
         }
         else
         {
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Adding addrMux");
            structural_objectRef addrMux = SM->add_module_from_technology_library(
                "addrMux", MUX_GATE_STD, HLS->HLS_D->get_technology_manager()->get_library(MUX_GATE_STD), interfaceObj,
                HLS->HLS_D->get_technology_manager());

            structural_objectRef addrMuxIn1 = addrMux->find_member("in1", port_o_K, addrMux);
            GetPointer<port_o>(addrMuxIn1)->set_type(addr_type);

            structural_objectRef addrMuxIn2 = addrMux->find_member("in2", port_o_K, addrMux);
            GetPointer<port_o>(addrMuxIn2)->set_type(addr_type);

            structural_objectRef addrMuxOut1 = addrMux->find_member("out1", port_o_K, addrMux);
            GetPointer<port_o>(addrMuxOut1)->set_type(addr_type);

            SM->add_connection(signControl, addrMux->find_member("sel", port_o_K, addrMux));
            connect_with_signal_name(SM, afAddrISOut1, addrMuxIn1, "addr_is_f");
            connect_with_signal(SM, Mout_addr_ram_port, addrMuxIn2);
            connect_with_signal(SM, S_addr_ram_port, addrMuxOut1);
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Added addrMux");
         }
      }
      else
      {
         // if not master there is no need to check the addresses
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting S_addr_ram");
         connect_with_signal_name(SM, S_addr_ram_port, afAddrISOut1, "addr_is_f");
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected S_addr_ram");
      }

      // ---- Data ready ack logic ----
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting AckOSGate");
      structural_objectRef andGateAckOS = SM->add_module_from_technology_library(
          "andGateAckOS", AND_GATE_STD, LIBRARY_STD, interfaceObj, HLS->HLS_D->get_technology_manager());

      structural_objectRef port_objAndAckOS = andGateAckOS->find_member("in", port_o_K, andGateAckOS);
      auto* in_portAndAckOS = GetPointer<port_o>(port_objAndAckOS);
      in_portAndAckOS->add_n_ports(3, port_objAndAckOS);

      SM->add_connection(interfaceObj->find_member(WB_STBIS_PORT_NAME, port_o_K, interfaceObj),
                         in_portAndAckOS->get_port(1));

      SM->add_connection(interfaceObj->find_member(WB_CYCIS_PORT_NAME, port_o_K, interfaceObj),
                         in_portAndAckOS->get_port(2));

      SM->add_connection(interfaceObj->find_member(WB_ACKOS_PORT_NAME, port_o_K, interfaceObj),
                         andGateAckOS->find_member("out1", port_o_K, andGateAckOS));
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserted AckOSGate");

      if(is_master)
      {
         if(only_mm_parameters_allocated)
         {
            connect_with_signal(SM, interfaceObj->find_member(WB_ACKIM_PORT_NAME, port_o_K, interfaceObj),
                                M_DataRdy_port);
            connect_with_signal_name(SM, Sout_DataRdy_port, in_portAndAckOS->get_port(0), "Sout_DataRdyToWb");
         }
         else
         {
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting dataRdyDemux");
            structural_objectRef dataRdyDemux = SM->add_module_from_technology_library(
                "dataRdyDemux", DEMUX_GATE_STD, HLS->HLS_D->get_technology_manager()->get_library(DEMUX_GATE_STD),
                interfaceObj, HLS->HLS_D->get_technology_manager());

            connect_with_signal_name(SM, dataRdyDemux->find_member("out2", port_o_K, dataRdyDemux),
                                     in_portAndAckOS->get_port(0), "Sout_DataRdyToWb");
            SM->add_connection(signControl_delayed, dataRdyDemux->find_member("sel", port_o_K, dataRdyDemux));
            connect_with_signal(SM, Sout_DataRdy_port, dataRdyDemux->find_member("in1", port_o_K, dataRdyDemux));
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserted dataRdyDemux");

            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting soutDRMux");
            structural_objectRef soutDRMux = SM->add_module_from_technology_library(
                "soutDRMux", MUX_GATE_STD, HLS->HLS_D->get_technology_manager()->get_library(MUX_GATE_STD),
                interfaceObj, HLS->HLS_D->get_technology_manager());

            SM->add_connection(signControl, soutDRMux->find_member("sel", port_o_K, soutDRMux));
            SM->add_connection(interfaceObj->find_member(WB_ACKIM_PORT_NAME, port_o_K, interfaceObj),
                               soutDRMux->find_member("in1", port_o_K, soutDRMux));
            connect_with_signal_name(SM, dataRdyDemux->find_member("out1", port_o_K, dataRdyDemux),
                                     soutDRMux->find_member("in2", port_o_K, soutDRMux), "Sout_DataRdyDemux");
            connect_with_signal(SM, M_DataRdy_port, soutDRMux->find_member("out1", port_o_K, soutDRMux));
            PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Inserting soutDRMux");
         }
      }
      else
      {
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting Sout_DataRdy");
         connect_with_signal_name(SM, Sout_DataRdy_port, in_portAndAckOS->get_port(0), "Sout_DataRdyToWb");
         PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected Sout_DataRdy");
      }
   }
   else if(is_master)
   {
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connecting M_DataRdy");
      SM->add_connection(interfaceObj->find_member(WB_ACKIM_PORT_NAME, port_o_K, interfaceObj), M_DataRdy_port);
      PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Connected M_DataRdy");
   }
}
