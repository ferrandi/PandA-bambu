/*
 *
 *                   _/_/_/    _/_/   _/    _/ _/_/_/    _/_/
 *                  _/   _/ _/    _/ _/_/  _/ _/   _/ _/    _/
 *                 _/_/_/  _/_/_/_/ _/  _/_/ _/   _/ _/_/_/_/
 *                _/      _/    _/ _/    _/ _/   _/ _/    _/
 *               _/      _/    _/ _/    _/ _/_/_/  _/    _/
 *
 *             ***********************************************
 *                              PandA Project
 *                     URL: http://panda.dei.polimi.it
 *                       Politecnico di Milano - DEIB
 *                        System Architectures Group
 *             ***********************************************
 *              Copyright (C) 2004-2020 Politecnico di Milano
 *
 *   This file is part of the PandA framework.
 *
 *   The PandA framework is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
/**
 * @file minimal_interface.cpp
 * @brief Class to generate minimal interfaces for high-level synthesis
 *
 * This class generates minimal interfaces for connecting modules to
 * microprocessors or busses
 *
 * @author Marco Minutoli <mminutoli@gmail.com>
 * @author Fabrizio Ferrandi <fabrizio.ferrandi@polimi.it>
 *
 */
#include "minimal_interface.hpp"

#include "hls.hpp"
#include "hls_manager.hpp"
#include "hls_target.hpp"
#include "memory.hpp"
#include "memory_allocation.hpp"
#include "memory_symbol.hpp"

#include "Parameter.hpp"
#include "structural_manager.hpp"
#include "structural_objects.hpp"
#include "technology_manager.hpp"
#include "tree_helper.hpp"
#include "tree_manager.hpp"
#include "tree_node.hpp"
#include "tree_reindex.hpp"

// behavior/ include
#include "behavioral_helper.hpp"
#include "call_graph_manager.hpp"

// HLS/simulation include
#include "testbench_generation_base_step.hpp"

/// STD include
#include <string>

/// STL includes
#include "custom_map.hpp"
#include "custom_set.hpp"
#include <list>
#include <utility>
#include <vector>

// technology/physical_library include
#include "technology_node.hpp"

/// utility include
#include "copyrights_strings.hpp"
#include "fileIO.hpp"
#include "string_manipulation.hpp"

minimal_interface::minimal_interface(const ParameterConstRef _Param, const HLS_managerRef _HLSMgr, unsigned int _funId, const DesignFlowManagerConstRef _design_flow_manager, const HLSFlowStep_Type _hls_flow_step_type)
    : module_interface(_Param, _HLSMgr, _funId, _design_flow_manager, _hls_flow_step_type)
{
   THROW_ASSERT(funId, "Function not set in minimal interface");
}

minimal_interface::~minimal_interface() = default;

DesignFlowStep_Status minimal_interface::InternalExec()
{
   const structural_managerRef SM = HLS->top;
   if(!SM)
      THROW_ERROR("Top component has not been created yet!");

   const FunctionBehaviorConstRef FB = HLSMgr->CGetFunctionBehavior(funId);
   const BehavioralHelperConstRef BH = FB->CGetBehavioralHelper();
   const auto top_functions = HLSMgr->CGetCallGraphManager()->GetRootFunctions();
   bool is_top = top_functions.find(BH->get_function_index()) != top_functions.end();
   std::string module_name;
   structural_objectRef wrappedObj = SM->get_circ();
   if(is_top)
      module_name = BH->get_function_name();
   else
      module_name = wrappedObj->get_id() + "_minimal_interface";

   structural_managerRef SM_minimal_interface = structural_managerRef(new structural_manager(parameters));
   structural_type_descriptorRef module_type = structural_type_descriptorRef(new structural_type_descriptor(module_name));
   SM_minimal_interface->set_top_info(module_name, module_type);
   structural_objectRef interfaceObj = SM_minimal_interface->get_circ();

   // add the core to the wrapper
   wrappedObj->set_owner(interfaceObj);
   wrappedObj->set_id(wrappedObj->get_id() + "_i0");
   GetPointer<module>(interfaceObj)->add_internal_object(wrappedObj);
   /// Set some descriptions and legal stuff
   GetPointer<module>(interfaceObj)->set_description("Minimal interface for function: " + (is_top ? BH->get_function_name() : wrappedObj->get_typeRef()->id_type));
   GetPointer<module>(interfaceObj)->set_copyright(GENERATED_COPYRIGHT);
   GetPointer<module>(interfaceObj)->set_authors("Component automatically generated by bambu");
   GetPointer<module>(interfaceObj)->set_license(GENERATED_LICENSE);

   build_wrapper(wrappedObj, interfaceObj, SM_minimal_interface);

   if(!is_top || !parameters->isOption(OPT_do_not_expose_globals) || !parameters->getOption<bool>(OPT_do_not_expose_globals))
      memory::propagate_memory_parameters(HLS->top->get_circ(), SM_minimal_interface);
   // Generation completed, the new created module substitutes the current top-level one
   HLS->top = SM_minimal_interface;
   return DesignFlowStep_Status::SUCCESS;
}

static bool compareMemVarsPair(std::pair<unsigned int, memory_symbolRef>& first, std::pair<unsigned int, memory_symbolRef>& second)
{
   bool result = false;
   if(first.second->get_address() < second.second->get_address())
      result = true;

   return result;
}

void minimal_interface::build_wrapper(structural_objectRef wrappedObj, structural_objectRef interfaceObj, structural_managerRef SM_minimal_interface)
{
   std::map<unsigned int, structural_objectRef> null_values;

   unsigned long long int base_address = HLSMgr->base_address;
   bool Has_extern_allocated_data = HLSMgr->Rmem->get_memory_address() - base_address > 0;
   bool Has_unknown_addresses = HLSMgr->Rmem->has_unknown_addresses();
   const auto cg_man = HLSMgr->CGetCallGraphManager();
   const auto top_function_ids = cg_man->GetRootFunctions();
   bool Has_intern_shared_data = (HLSMgr->Rmem->has_intern_shared_data()) || (parameters->getOption<MemoryAllocation_Policy>(OPT_memory_allocation_policy) == MemoryAllocation_Policy::EXT_PIPELINED_BRAM) ||
                                 (parameters->getOption<MemoryAllocation_Policy>(OPT_memory_allocation_policy) == MemoryAllocation_Policy::NO_BRAM) ||
                                 (top_function_ids.find(funId) != top_function_ids.end() and parameters->getOption<HLSFlowStep_Type>(OPT_interface_type) == HLSFlowStep_Type::WB4_INTERFACE_GENERATION) ||
                                 (HLSMgr->hasToBeInterfaced(funId) and top_function_ids.find(funId) == top_function_ids.end()) || parameters->getOption<bool>(OPT_memory_mapped_top);
   bool with_master = false;
   bool with_slave = false;
   for(unsigned int i = 0; i < GetPointer<module>(wrappedObj)->get_in_port_size(); i++)
   {
      const structural_objectRef& port_obj = GetPointer<module>(wrappedObj)->get_in_port(i);
      if(GetPointer<port_o>(port_obj)->get_is_memory())
      {
         if(GetPointer<port_o>(port_obj)->get_is_master())
            with_master = true;
         else if(GetPointer<port_o>(port_obj)->get_is_slave())
            with_slave = true;
      }
   }

   CustomOrderedSet<structural_objectRef> portsToSkip;
   CustomOrderedSet<structural_objectRef> portsToConstant;
   const auto& DesignInterface = HLSMgr->design_interface;

   /// list of ports that have to be connected to constant 0
   if(with_slave)
   {
      portsToConstant.insert(wrappedObj->find_member("Sin_DataRdy", port_o_K, wrappedObj));
      portsToConstant.insert(wrappedObj->find_member("Sin_Rdata_ram", port_o_K, wrappedObj));
   }
   if(with_master)
   {
      portsToConstant.insert(wrappedObj->find_member("Min_oe_ram", port_o_K, wrappedObj));
      portsToConstant.insert(wrappedObj->find_member("Min_we_ram", port_o_K, wrappedObj));
      portsToConstant.insert(wrappedObj->find_member("Min_addr_ram", port_o_K, wrappedObj));
      portsToConstant.insert(wrappedObj->find_member("Min_Wdata_ram", port_o_K, wrappedObj));
      portsToConstant.insert(wrappedObj->find_member("Min_data_ram_size", port_o_K, wrappedObj));
   }

   std::map<structural_objectRef, structural_objectRef> portsToConnect;
   std::map<structural_objectRef, structural_objectRef> portsToSigConnect;

   CustomOrderedSet<std::string> param_renamed;
   if(!DesignInterface.empty())
   {
      const auto TM = HLSMgr->get_tree_manager();
      auto fnode = TM->get_tree_node_const(funId);
      auto fd = GetPointer<function_decl>(fnode);
      std::string fname;
      tree_helper::get_mangled_fname(fd, fname);
      if(DesignInterface.find(fname) != DesignInterface.end())
      {
         const auto& DesignInterfaceArgs = DesignInterface.find(fname)->second;
         for(auto arg : fd->list_of_args)
         {
            auto a = GetPointer<parm_decl>(GET_NODE(arg));
            auto argName = GET_NODE(a->name);
            THROW_ASSERT(GetPointer<identifier_node>(argName), "unexpected condition");
            const std::string& argName_string = GetPointer<identifier_node>(argName)->strg;
            THROW_ASSERT(DesignInterfaceArgs.find(argName_string) != DesignInterfaceArgs.end(), "unexpected condition:" + argName_string);
            auto interfaceType = DesignInterfaceArgs.find(argName_string)->second;
            if(interfaceType != "default")
            {
               auto argTypeNode = GET_NODE(a->type);
               if(tree_helper::is_a_pointer(TM, GET_INDEX_NODE(a->type)))
               {
                  auto p = wrappedObj->find_member(argName_string, port_o_K, wrappedObj);
                  THROW_ASSERT(p, "unexpected condition");
                  bool is_direct = interfaceType == "m_axi" && HLSMgr->design_interface_attribute2.find(fname) != HLSMgr->design_interface_attribute2.end() &&
                                   HLSMgr->design_interface_attribute2.find(fname)->second.find(argName_string) != HLSMgr->design_interface_attribute2.find(fname)->second.end() &&
                                   HLSMgr->design_interface_attribute2.find(fname)->second.find(argName_string)->second == "direct";
                  if(!is_direct)
                     portsToConstant.insert(p);
                  param_renamed.insert(argName_string);
               }
               else
                  THROW_ERROR("unexpected parameter type for " + argName_string + "(" + interfaceType + ")");
            }
         }
      }
   }

   if(!Has_intern_shared_data)
   {
      if(!Has_extern_allocated_data)
      {
         if(!with_master && with_slave)
         {
            /// slave INs
            portsToConstant.insert(wrappedObj->find_member("S_oe_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_we_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_addr_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_Wdata_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_data_ram_size", port_o_K, wrappedObj));
            /// slave OUTs
            portsToSkip.insert(wrappedObj->find_member("Sout_Rdata_ram", port_o_K, wrappedObj));
            portsToSkip.insert(wrappedObj->find_member("Sout_DataRdy", port_o_K, wrappedObj));
         }
         else if(with_master && !with_slave)
         {
            /// do nothing
            /// it may happen with ALL_BRAM memory allocation policy
         }
         else if(with_master && with_slave && Has_unknown_addresses && HLSMgr->Rmem->get_allocated_intern_memory() == 0)
         {
            /// intern data is not externally visible
            /// slave INs
            portsToConstant.insert(wrappedObj->find_member("S_oe_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_we_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_addr_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_Wdata_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_data_ram_size", port_o_K, wrappedObj));
            /// slave OUTs
            portsToSkip.insert(wrappedObj->find_member("Sout_Rdata_ram", port_o_K, wrappedObj));
            portsToSkip.insert(wrappedObj->find_member("Sout_DataRdy", port_o_K, wrappedObj));
         }
         else if(with_master && with_slave && !Has_unknown_addresses)
         {
            /// slave INs connections
            portsToConnect[wrappedObj->find_member("S_oe_ram", port_o_K, wrappedObj)] = wrappedObj->find_member("Mout_oe_ram", port_o_K, wrappedObj);
            portsToConnect[wrappedObj->find_member("S_we_ram", port_o_K, wrappedObj)] = wrappedObj->find_member("Mout_we_ram", port_o_K, wrappedObj);
            portsToConnect[wrappedObj->find_member("S_addr_ram", port_o_K, wrappedObj)] = wrappedObj->find_member("Mout_addr_ram", port_o_K, wrappedObj);
            portsToConnect[wrappedObj->find_member("S_Wdata_ram", port_o_K, wrappedObj)] = wrappedObj->find_member("Mout_Wdata_ram", port_o_K, wrappedObj);
            portsToConnect[wrappedObj->find_member("S_data_ram_size", port_o_K, wrappedObj)] = wrappedObj->find_member("Mout_data_ram_size", port_o_K, wrappedObj);
            /// master INs connections
            portsToConnect[wrappedObj->find_member("M_Rdata_ram", port_o_K, wrappedObj)] = wrappedObj->find_member("Sout_Rdata_ram", port_o_K, wrappedObj);
            portsToConnect[wrappedObj->find_member("M_DataRdy", port_o_K, wrappedObj)] = wrappedObj->find_member("Sout_DataRdy", port_o_K, wrappedObj);
            /// slave OUTs skip
            portsToSkip.insert(wrappedObj->find_member("Sout_Rdata_ram", port_o_K, wrappedObj));
            portsToSkip.insert(wrappedObj->find_member("Sout_DataRdy", port_o_K, wrappedObj));
            /// master OUTs skip
            portsToSkip.insert(wrappedObj->find_member("Mout_oe_ram", port_o_K, wrappedObj));
            portsToSkip.insert(wrappedObj->find_member("Mout_we_ram", port_o_K, wrappedObj));
            portsToSkip.insert(wrappedObj->find_member("Mout_addr_ram", port_o_K, wrappedObj));
            portsToSkip.insert(wrappedObj->find_member("Mout_Wdata_ram", port_o_K, wrappedObj));
            portsToSkip.insert(wrappedObj->find_member("Mout_data_ram_size", port_o_K, wrappedObj));
         }
         else
         {
            /// do nothing
         }
      }
      else
      {
         if(with_master && !Has_unknown_addresses && HLSMgr->Rmem->get_ext_memory_variables().empty())
         {
            THROW_ASSERT(parameters->getOption<MemoryAllocation_ChannelsType>(OPT_channels_type) != (MemoryAllocation_ChannelsType::MEM_ACC_P1N), "unexpected condition");
            /// allocate the unique shared memory
            structural_objectRef shared_memory;
            bool is_memory_splitted;
            std::string latency_postfix = "";
            if(parameters->getOption<std::string>(OPT_bram_high_latency) != "")
               latency_postfix = parameters->getOption<std::string>(OPT_bram_high_latency);
            if(parameters->getOption<MemoryAllocation_ChannelsType>(OPT_channels_type) == MemoryAllocation_ChannelsType::MEM_ACC_11 or parameters->getOption<MemoryAllocation_ChannelsType>(OPT_channels_type) == MemoryAllocation_ChannelsType::MEM_ACC_N1)
            {
               is_memory_splitted = false;
               shared_memory = SM_minimal_interface->add_module_from_technology_library("shared_memory", STD_BRAM + latency_postfix, LIBRARY_STD, interfaceObj, HLSMgr->get_HLS_target()->get_technology_manager());
            }
            else
            {
               is_memory_splitted = true;
               shared_memory = SM_minimal_interface->add_module_from_technology_library("shared_memory", STD_BRAMN + latency_postfix, LIBRARY_STD, interfaceObj, HLSMgr->get_HLS_target()->get_technology_manager());
            }
            unsigned int bus_data_bitsize = HLSMgr->Rmem->get_bus_data_bitsize();
            unsigned int bus_addr_bitsize = HLSMgr->get_address_bitsize();
            unsigned int bus_size_bitsize = HLSMgr->Rmem->get_bus_size_bitsize();
            unsigned int bram_bitsize = HLSMgr->Rmem->get_bram_bitsize();
            unsigned long long int n_bytes = HLSMgr->Rmem->get_memory_address() - base_address;
            unsigned long long int vec_size = n_bytes / (bus_data_bitsize / 8);
            std::string init_filename = "shared_memory.mem";
            std::ofstream init_file_a(GetPath((init_filename).c_str()));
            std::ofstream init_file_b(GetPath((+"0_" + init_filename).c_str()));

            module* shared_memory_module = GetPointer<module>(shared_memory);
            shared_memory_module->SetParameter("address_space_begin", STR(base_address));
            shared_memory_module->SetParameter("address_space_rangesize", STR(n_bytes));
            if(parameters->isOption(OPT_sparse_memory) && parameters->getOption<bool>(OPT_sparse_memory))
               shared_memory_module->SetParameter("USE_SPARSE_MEMORY", "1");
            else
               shared_memory_module->SetParameter("USE_SPARSE_MEMORY", "0");
            if(is_memory_splitted)
            {
               shared_memory_module->SetParameter("MEMORY_INIT_file_a", "\"\"" + init_filename + "\"\"");
               shared_memory_module->SetParameter("MEMORY_INIT_file_b", "\"\"0_" + init_filename + "\"\"");
            }
            else
               shared_memory_module->SetParameter("MEMORY_INIT_file", "\"\"" + init_filename + "\"\"");
            shared_memory_module->SetParameter("n_elements", STR(vec_size));
            shared_memory_module->SetParameter("data_size", STR(bus_data_bitsize));
            shared_memory_module->SetParameter("BRAM_BITSIZE", STR(bram_bitsize));
            if((Has_extern_allocated_data) || Has_unknown_addresses)
               shared_memory_module->SetParameter("BUS_PIPELINED", "0");
            else
               shared_memory_module->SetParameter("BUS_PIPELINED", "1");
            unsigned int n_ports = parameters->isOption(OPT_channels_number) ? parameters->getOption<unsigned int>(OPT_channels_number) : 0;
            for(unsigned int i = 0; i < shared_memory_module->get_in_port_size(); i++)
            {
               structural_objectRef port = shared_memory_module->get_in_port(i);
               if(GetPointer<port_o>(port)->get_kind() == port_vector_o_K && GetPointer<port_o>(port)->get_ports_size() == 0)
                  GetPointer<port_o>(port)->add_n_ports(n_ports, port);
               if(GetPointer<port_o>(port) && GetPointer<port_o>(port)->get_is_data_bus())
                  port->type_resize(bus_data_bitsize);
               else if(GetPointer<port_o>(port) && GetPointer<port_o>(port)->get_is_addr_bus())
                  port->type_resize(bus_addr_bitsize);
               else if(GetPointer<port_o>(port) && GetPointer<port_o>(port)->get_is_size_bus())
                  port->type_resize(bus_size_bitsize);
            }
            for(unsigned int i = 0; i < shared_memory_module->get_out_port_size(); i++)
            {
               structural_objectRef port = shared_memory_module->get_out_port(i);
               if(GetPointer<port_o>(port)->get_kind() == port_vector_o_K && GetPointer<port_o>(port)->get_ports_size() == 0)
                  GetPointer<port_o>(port)->add_n_ports(n_ports, port);
               if(GetPointer<port_o>(port) && GetPointer<port_o>(port)->get_is_data_bus())
                  port->type_resize(bus_data_bitsize);
               else if(GetPointer<port_o>(port) && GetPointer<port_o>(port)->get_is_addr_bus())
                  port->type_resize(bus_addr_bitsize);
               else if(GetPointer<port_o>(port) && GetPointer<port_o>(port)->get_is_size_bus())
                  port->type_resize(bus_size_bitsize);
            }
            const std::map<unsigned int, memory_symbolRef>& mem_vars = HLSMgr->Rmem->get_ext_memory_variables();
            unsigned int nbyte_on_memory = (bram_bitsize / 8);

            std::string init_v;
            std::string current_bits;
            unsigned int counter = 0;
            bool is_even = true;
            std::list<std::pair<unsigned int, memory_symbolRef>> mem_variables;
            for(const auto& mem_var : mem_vars)
               mem_variables.push_back(std::make_pair(mem_var.first, mem_var.second));
            mem_variables.sort(compareMemVarsPair);

            std::list<std::pair<unsigned int, memory_symbolRef>>::const_iterator m_next;
            for(std::list<std::pair<unsigned int, memory_symbolRef>>::const_iterator m = mem_variables.begin(); m != mem_variables.end(); ++m)
            {
               init_v = TestbenchGenerationBaseStep::print_var_init(HLSMgr->get_tree_manager(), m->first, HLSMgr->Rmem);
               std::vector<std::string> splitted = SplitString(init_v, ",");
               unsigned int byte_allocated = 0;
               unsigned long long int actual_byte = tree_helper::size(HLSMgr->get_tree_manager(), m->first) / 8;
               std::vector<std::string> eightbit_string;
               for(const auto& i : splitted)
               {
                  current_bits = i;
                  for(unsigned int base_index = 0; base_index < current_bits.size(); base_index = base_index + 8, ++byte_allocated)
                     eightbit_string.push_back(current_bits.substr(current_bits.size() - 8 - base_index, 8));
               }
               std::string str_bit;
               str_bit = "";
               for(unsigned int l = 0; l < eightbit_string.size();)
               {
                  do
                  {
                     str_bit = eightbit_string[l] + str_bit;
                     ++counter;
                     ++l;
                     if(counter % nbyte_on_memory == 0)
                     {
                        if(is_even || !is_memory_splitted)
                           init_file_a << str_bit << std::endl;
                        else
                           init_file_b << str_bit << std::endl;
                        str_bit = "";
                        is_even = !is_even;
                     }
                  } while(l < eightbit_string.size());
               }
               /// data padding
               if(actual_byte > byte_allocated)
               {
                  for(unsigned int base_index = 0; base_index < actual_byte - byte_allocated; ++base_index)
                  {
                     str_bit = "00000000" + str_bit;
                     counter++;
                     if(counter % nbyte_on_memory == 0)
                     {
                        if(is_even || !is_memory_splitted)
                           init_file_a << str_bit << std::endl;
                        else
                           init_file_b << str_bit << std::endl;
                        str_bit = "";
                        is_even = !is_even;
                     }
                  }
               }
               /// alignment padding
               m_next = m;
               ++m_next;
               unsigned long long int object_offset;
               if(m_next != mem_variables.end())
               {
                  object_offset = HLSMgr->Rmem->get_base_address(m_next->first, HLS->functionId) - HLSMgr->Rmem->get_base_address(m->first, HLS->functionId);
               }
               else
               {
                  object_offset = HLSMgr->Rmem->get_memory_address() - HLSMgr->Rmem->get_base_address(m->first, HLS->functionId);
               }
               THROW_ASSERT(object_offset >= actual_byte, "more allocated memory than expected");
               if(object_offset > actual_byte)
               {
                  for(unsigned long long int base_index = 0; base_index < object_offset - actual_byte; ++base_index)
                  {
                     str_bit = "00000000" + str_bit;
                     counter++;
                     if(counter % nbyte_on_memory == 0)
                     {
                        if(is_even || !is_memory_splitted)
                           init_file_a << str_bit << std::endl;
                        else
                           init_file_b << str_bit << std::endl;
                        str_bit = "";
                        is_even = !is_even;
                     }
                  }
               }
            }

            structural_objectRef clock_port, reset_port;
            structural_objectRef port_ck = shared_memory->find_member(CLOCK_PORT_NAME, port_o_K, shared_memory);
            if(parameters->isOption(OPT_clock_name))
               clock_port = SM_minimal_interface->add_port(parameters->getOption<std::string>(OPT_clock_name), port_o::IN, interfaceObj, port_ck->get_typeRef());
            else
               clock_port = SM_minimal_interface->add_port(GetPointer<port_o>(port_ck)->get_id(), port_o::IN, interfaceObj, port_ck->get_typeRef());
            SM_minimal_interface->add_connection(clock_port, port_ck);

            structural_objectRef port_rst = shared_memory->find_member(RESET_PORT_NAME, port_o_K, shared_memory);
            if(parameters->isOption(OPT_reset_name))
               reset_port = SM_minimal_interface->add_port(parameters->getOption<std::string>(OPT_reset_name), port_o::IN, interfaceObj, port_rst->get_typeRef());
            else
               reset_port = SM_minimal_interface->add_port(GetPointer<port_o>(port_rst)->get_id(), port_o::IN, interfaceObj, port_rst->get_typeRef());
            SM_minimal_interface->add_connection(reset_port, port_rst);

            if(!with_slave)
            {
               structural_objectRef port1, port2;
               structural_objectRef sign;
               /// slave INs connections
               port1 = shared_memory->find_member("S_oe_ram", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_oe_ram", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               port1 = shared_memory->find_member("S_we_ram", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_we_ram", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               port1 = shared_memory->find_member("S_addr_ram", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_addr_ram", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               port1 = shared_memory->find_member("S_Wdata_ram", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_Wdata_ram", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               port1 = shared_memory->find_member("S_data_ram_size", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_data_ram_size", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);

               port1 = shared_memory->find_member("Sin_DataRdy", port_o_K, shared_memory);
               if(null_values.find(GET_TYPE_SIZE(port1)) == null_values.end())
               {
                  structural_objectRef const_obj = SM_minimal_interface->add_constant("null_value_" + STR(GET_TYPE_SIZE(port1)), interfaceObj, port1->get_typeRef(), STR(0));
                  null_values[GET_TYPE_SIZE(port1)] = const_obj;
               }
               if(port1->get_kind() == port_vector_o_K)
               {
                  for(unsigned int p = 0; p < GetPointer<port_o>(port1)->get_ports_size(); ++p)
                  {
                     structural_objectRef port_d = GetPointer<port_o>(port1)->get_port(p);
                     SM_minimal_interface->add_connection(port_d, null_values[GET_TYPE_SIZE(port_d)]);
                  }
               }
               else
                  SM_minimal_interface->add_connection(port1, null_values[GET_TYPE_SIZE(port1)]);

               port1 = shared_memory->find_member("Sin_Rdata_ram", port_o_K, shared_memory);
               if(null_values.find(GET_TYPE_SIZE(port1)) == null_values.end())
               {
                  structural_objectRef const_obj = SM_minimal_interface->add_constant("null_value_" + STR(GET_TYPE_SIZE(port1)), interfaceObj, port1->get_typeRef(), STR(0));
                  null_values[GET_TYPE_SIZE(port1)] = const_obj;
               }
               if(port1->get_kind() == port_vector_o_K)
               {
                  for(unsigned int p = 0; p < GetPointer<port_o>(port1)->get_ports_size(); ++p)
                  {
                     structural_objectRef port_d = GetPointer<port_o>(port1)->get_port(p);
                     SM_minimal_interface->add_connection(port_d, null_values[GET_TYPE_SIZE(port_d)]);
                  }
               }
               else
                  SM_minimal_interface->add_connection(port1, null_values[GET_TYPE_SIZE(port1)]);

               /// master INs connections
               portsToConnect[wrappedObj->find_member("M_Rdata_ram", port_o_K, wrappedObj)] = shared_memory->find_member("Sout_Rdata_ram", port_o_K, shared_memory);
               portsToConnect[wrappedObj->find_member("M_DataRdy", port_o_K, wrappedObj)] = shared_memory->find_member("Sout_DataRdy", port_o_K, shared_memory);

               /// master OUTs skip
               portsToSkip.insert(wrappedObj->find_member("Mout_oe_ram", port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member("Mout_we_ram", port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member("Mout_addr_ram", port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member("Mout_Wdata_ram", port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member("Mout_data_ram_size", port_o_K, wrappedObj));
            }
            else
            {
               structural_objectRef port1, port2;
               structural_objectRef sign;
               /// slave INs connections
               port1 = shared_memory->find_member("S_oe_ram", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_oe_ram", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               port1 = wrappedObj->find_member("S_oe_ram", port_o_K, wrappedObj);
               portsToSkip.insert(port1);
               SM_minimal_interface->add_connection(port1, sign);

               port1 = shared_memory->find_member("S_we_ram", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_we_ram", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               port1 = wrappedObj->find_member("S_we_ram", port_o_K, wrappedObj);
               portsToSkip.insert(port1);
               SM_minimal_interface->add_connection(port1, sign);

               port1 = shared_memory->find_member("S_addr_ram", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_addr_ram", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               port1 = wrappedObj->find_member("S_addr_ram", port_o_K, wrappedObj);
               portsToSkip.insert(port1);
               SM_minimal_interface->add_connection(port1, sign);

               port1 = shared_memory->find_member("S_Wdata_ram", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_Wdata_ram", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               port1 = wrappedObj->find_member("S_Wdata_ram", port_o_K, wrappedObj);
               portsToSkip.insert(port1);
               SM_minimal_interface->add_connection(port1, sign);

               port1 = shared_memory->find_member("S_data_ram_size", port_o_K, shared_memory);
               port2 = wrappedObj->find_member("Mout_data_ram_size", port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               port1 = wrappedObj->find_member("S_data_ram_size", port_o_K, wrappedObj);
               portsToSkip.insert(port1);
               SM_minimal_interface->add_connection(port1, sign);

               port1 = wrappedObj->find_member("Sout_DataRdy", port_o_K, wrappedObj);
               port2 = shared_memory->find_member("Sin_DataRdy", port_o_K, shared_memory);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);

               port1 = wrappedObj->find_member("Sout_Rdata_ram", port_o_K, wrappedObj);
               port2 = shared_memory->find_member("Sin_Rdata_ram", port_o_K, shared_memory);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1->get_id() + "_INT", GetPointer<port_o>(port1)->get_ports_size(), interfaceObj, port1->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1->get_id() + "_INT", interfaceObj, port1->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);

               /// master INs connections
               portsToConnect[wrappedObj->find_member("M_Rdata_ram", port_o_K, wrappedObj)] = shared_memory->find_member("Sout_Rdata_ram", port_o_K, shared_memory);
               portsToConnect[wrappedObj->find_member("M_DataRdy", port_o_K, wrappedObj)] = shared_memory->find_member("Sout_DataRdy", port_o_K, shared_memory);

               /// slave OUTs skip
               portsToSkip.insert(wrappedObj->find_member("Sout_Rdata_ram", port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member("Sout_DataRdy", port_o_K, wrappedObj));
               /// master OUTs skip
               portsToSkip.insert(wrappedObj->find_member("Mout_oe_ram", port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member("Mout_we_ram", port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member("Mout_addr_ram", port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member("Mout_Wdata_ram", port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member("Mout_data_ram_size", port_o_K, wrappedObj));
            }
         }
         else if(with_slave && parameters->isOption(OPT_do_not_expose_globals))
         {
            auto manage_feedback1 = [&](const std::string& portS, const std::string& portM) {
               structural_objectRef port1, port2;
               structural_objectRef sign;
               /// slave INs connections
               port1 = wrappedObj->find_member(portS, port_o_K, wrappedObj);
               port2 = wrappedObj->find_member(portM, port_o_K, wrappedObj);
               if(port1->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port2->get_id() + "_INT", GetPointer<port_o>(port2)->get_ports_size(), interfaceObj, port2->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port2->get_id() + "_INT", interfaceObj, port2->get_typeRef());
               SM_minimal_interface->add_connection(port1, sign);
               SM_minimal_interface->add_connection(sign, port2);
               portsToSigConnect[port2] = sign;
               portsToSkip.insert(wrappedObj->find_member(portS, port_o_K, wrappedObj));
            };
            auto manage_feedback2 = [&](const std::string& portSin, const std::string& portSout, const std::string& portM) {
               structural_objectRef port1In, port1Out, port2;
               structural_objectRef sign;
               /// slave INs connections
               port2 = wrappedObj->find_member(portM, port_o_K, wrappedObj);
               if(port2->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port2->get_id() + "_INT", GetPointer<port_o>(port2)->get_ports_size(), interfaceObj, port2->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port2->get_id() + "_INT", interfaceObj, port2->get_typeRef());
               port1In = wrappedObj->find_member(portSin, port_o_K, wrappedObj);
               SM_minimal_interface->add_connection(port1In, sign);
               portsToSigConnect[port2] = sign;

               port1Out = wrappedObj->find_member(portSout, port_o_K, wrappedObj);
               if(port1Out->get_kind() == port_vector_o_K)
                  sign = SM_minimal_interface->add_sign_vector(port1Out->get_id() + "_INT", GetPointer<port_o>(port1Out)->get_ports_size(), interfaceObj, port1Out->get_typeRef());
               else
                  sign = SM_minimal_interface->add_sign(port1Out->get_id() + "_INT", interfaceObj, port1Out->get_typeRef());
               SM_minimal_interface->add_connection(port1Out, sign);
               SM_minimal_interface->add_connection(sign, port2);

               portsToSkip.insert(wrappedObj->find_member(portSin, port_o_K, wrappedObj));
               portsToSkip.insert(wrappedObj->find_member(portSout, port_o_K, wrappedObj));
            };
            manage_feedback1("S_oe_ram", "Mout_oe_ram");
            manage_feedback1("S_we_ram", "Mout_we_ram");
            manage_feedback1("S_addr_ram", "Mout_addr_ram");
            manage_feedback1("S_Wdata_ram", "Mout_Wdata_ram");
            manage_feedback1("S_data_ram_size", "Mout_data_ram_size");
            manage_feedback2("Sin_DataRdy", "Sout_DataRdy", "M_DataRdy");
            manage_feedback2("Sin_Rdata_ram", "Sout_Rdata_ram", "M_Rdata_ram");
            portsToConstant.erase(portsToConstant.find(wrappedObj->find_member("Sin_DataRdy", port_o_K, wrappedObj)));
            portsToConstant.erase(portsToConstant.find(wrappedObj->find_member("Sin_Rdata_ram", port_o_K, wrappedObj)));
         }
         else if(with_slave && (HLSMgr->Rmem->get_allocated_intern_memory() == 0))
         {
            /// slave INs
            portsToConstant.insert(wrappedObj->find_member("S_oe_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_we_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_addr_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_Wdata_ram", port_o_K, wrappedObj));
            portsToConstant.insert(wrappedObj->find_member("S_data_ram_size", port_o_K, wrappedObj));
            /// slave OUTs
            portsToSkip.insert(wrappedObj->find_member("Sout_Rdata_ram", port_o_K, wrappedObj));
            portsToSkip.insert(wrappedObj->find_member("Sout_DataRdy", port_o_K, wrappedObj));
         }
      }
   }

   // in ports
   for(unsigned int i = 0; i < GetPointer<module>(wrappedObj)->get_in_port_size(); ++i)
   {
      structural_objectRef port_in = GetPointer<module>(wrappedObj)->get_in_port(i);
      auto port_name = GetPointer<port_o>(port_in)->get_id();
      if(param_renamed.find(port_name) != param_renamed.end())
      {
         structural_objectRef ext_port = interfaceObj->find_member(port_name, port_o_K, interfaceObj);
         structural_objectRef int_port = wrappedObj->find_member("_" + port_name, port_o_K, wrappedObj);
         if(int_port)
         {
            if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_RNONE)
            {
               portsToSkip.insert(int_port);
               if(!ext_port)
               {
                  if(port_in->get_kind() == port_vector_o_K)
                     ext_port = SM_minimal_interface->add_port_vector(port_name, port_o::IN, GetPointer<port_o>(int_port)->get_ports_size(), interfaceObj, int_port->get_typeRef());
                  else
                     ext_port = SM_minimal_interface->add_port(port_name, port_o::IN, interfaceObj, int_port->get_typeRef());
               }
               port_o::fix_port_properties(int_port, ext_port);
               SM_minimal_interface->add_connection(int_port, ext_port);
            }
            else if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_WNONE)
            {
               THROW_ASSERT(GetPointer<port_o>(int_port)->get_port_direction() == port_o::port_direction::OUT, "unexpected condition");
            }
            else if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_M_AXI_OFF)
            {
               portsToConstant.insert(int_port);
            }
            else if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_M_AXI_DIRECT)
            {
               portsToConstant.insert(int_port);
            }
            else if(GetPointer<port_o>(int_port)->get_port_interface() != port_o::port_interface::PI_DEFAULT)
               THROW_ERROR("not yet supported port interface");
         }
         else
         {
            /// Check if we have an I/O interface
            int_port = wrappedObj->find_member("_" + port_name + "_i", port_o_K, wrappedObj);
            if(int_port)
            {
               if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_RNONE)
               {
                  portsToSkip.insert(int_port);
                  if(port_in->get_kind() == port_vector_o_K)
                     ext_port = SM_minimal_interface->add_port_vector(port_name + "_i", port_o::IN, GetPointer<port_o>(int_port)->get_ports_size(), interfaceObj, int_port->get_typeRef());
                  else
                     ext_port = SM_minimal_interface->add_port(port_name + "_i", port_o::IN, interfaceObj, int_port->get_typeRef());
                  port_o::fix_port_properties(int_port, ext_port);
                  SM_minimal_interface->add_connection(int_port, ext_port);
               }
               else if(GetPointer<port_o>(int_port)->get_port_interface() != port_o::port_interface::PI_DEFAULT)
                  THROW_ERROR("not yet supported port interface");
            }
            else
            {
               /// check if we have fifo-in interface
               int_port = wrappedObj->find_member("_" + port_name + "_dout", port_o_K, wrappedObj);
               if(int_port)
               {
                  if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_RNONE)
                  {
                     portsToSkip.insert(int_port);
                     if(port_in->get_kind() == port_vector_o_K)
                        ext_port = SM_minimal_interface->add_port_vector(port_name + "_dout", port_o::IN, GetPointer<port_o>(int_port)->get_ports_size(), interfaceObj, int_port->get_typeRef());
                     else
                        ext_port = SM_minimal_interface->add_port(port_name + "_dout", port_o::IN, interfaceObj, int_port->get_typeRef());
                     port_o::fix_port_properties(int_port, ext_port);
                     SM_minimal_interface->add_connection(int_port, ext_port);
                  }
                  else if(GetPointer<port_o>(int_port)->get_port_interface() != port_o::port_interface::PI_DEFAULT)
                     THROW_ERROR("not yet supported port interface");
               }
               else
               {
                  /// check if we have fifo-out interface
                  int_port = wrappedObj->find_member("_" + port_name + "_din", port_o_K, wrappedObj);
                  if(int_port)
                  {
                     if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_WNONE)
                     {
                        int_port = wrappedObj->find_member(port_name, port_o_K, wrappedObj);
                        THROW_ASSERT(int_port, "unexpected condition");
                        portsToSkip.insert(int_port);
                     }
                  }
                  else
                  {
                     /// check if we have array single port in interface
                     int_port = wrappedObj->find_member("_" + port_name + "_q0", port_o_K, wrappedObj);
                     if(int_port)
                     {
                        if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_DIN)
                        {
                           int_port = wrappedObj->find_member(port_name, port_o_K, wrappedObj);
                           THROW_ASSERT(int_port, "unexpected condition");
                           portsToSkip.insert(int_port);
                        }
                     }
                     else
                     {
                        /// check if we have array single port out interface
                        int_port = wrappedObj->find_member("_" + port_name + "_d0", port_o_K, wrappedObj);
                        if(int_port)
                        {
                           if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_DOUT)
                           {
                              int_port = wrappedObj->find_member(port_name, port_o_K, wrappedObj);
                              THROW_ASSERT(int_port, "unexpected condition");
                              portsToSkip.insert(int_port);
                           }
                        }
                        else
                        {
                           /// check if we have axis master interface
                           int_port = wrappedObj->find_member("_m_axis_" + port_name + "_TDATA", port_o_K, wrappedObj);
                           if(int_port)
                           {
                              if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_WNONE)
                              {
                                 int_port = wrappedObj->find_member(port_name, port_o_K, wrappedObj);
                                 THROW_ASSERT(int_port, "unexpected condition");
                                 portsToSkip.insert(int_port);
                              }
                           }
                           else
                           {
                              /// check if we have axis slave interface
                              int_port = wrappedObj->find_member("_s_axis_" + port_name + "_TDATA", port_o_K, wrappedObj);
                              if(int_port)
                              {
                                 if(GetPointer<port_o>(int_port)->get_port_interface() == port_o::port_interface::PI_RNONE)
                                 {
                                    portsToSkip.insert(int_port);
                                    if(port_in->get_kind() == port_vector_o_K)
                                       ext_port = SM_minimal_interface->add_port_vector("s_axis_" + port_name + "_TDATA", port_o::IN, GetPointer<port_o>(int_port)->get_ports_size(), interfaceObj, int_port->get_typeRef());
                                    else
                                       ext_port = SM_minimal_interface->add_port("s_axis_" + port_name + "_TDATA", port_o::IN, interfaceObj, int_port->get_typeRef());
                                    port_o::fix_port_properties(int_port, ext_port);
                                    SM_minimal_interface->add_connection(int_port, ext_port);
                                 }
                                 else if(GetPointer<port_o>(int_port)->get_port_interface() != port_o::port_interface::PI_DEFAULT)
                                    THROW_ERROR("not yet supported port interface");
                              }
                           }
                        }
                     }
                  }
               }
            }
            if(!int_port)
            {
               int_port = wrappedObj->find_member(port_name, port_o_K, wrappedObj);
               THROW_ASSERT(int_port, "unexpected condition");
               auto tnIndex = int_port->get_typeRef()->treenode;
               auto TreeM = HLSMgr->get_tree_manager();
               if(tnIndex > 0 && tree_helper::is_a_pointer(TreeM, tnIndex))
               {
                  unsigned int pt_type_index = tree_helper::get_pointed_type(TreeM, tree_helper::get_type_index(TreeM, tnIndex));
                  tree_nodeRef pt_node = TreeM->get_tree_node_const(pt_type_index);
                  structural_type_descriptorRef Intype = structural_type_descriptorRef(new structural_type_descriptor("bool", tree_helper::Size(pt_node)));
                  ext_port = SM_minimal_interface->add_port(port_name, port_o::IN, interfaceObj, Intype);
                  GetPointer<port_o>(ext_port)->set_port_interface(port_o::port_interface::PI_RNONE);
               }
            }
         }
      }

      if(parameters->isOption(OPT_clock_name) && port_name == CLOCK_PORT_NAME)
         port_name = parameters->getOption<std::string>(OPT_clock_name);
      else if(parameters->isOption(OPT_reset_name) && port_name == RESET_PORT_NAME)
         port_name = parameters->getOption<std::string>(OPT_reset_name);
      else if(parameters->isOption(OPT_start_name) && port_name == START_PORT_NAME)
         port_name = parameters->getOption<std::string>(OPT_start_name);

      if(portsToSkip.find(port_in) == portsToSkip.end() && portsToConnect.find(port_in) == portsToConnect.end() && portsToConstant.find(port_in) == portsToConstant.end() && portsToSigConnect.find(port_in) == portsToSigConnect.end())
      {
         if(GetPointer<port_o>(port_in)->get_port_interface() != port_o::port_interface::PI_DEFAULT)
         {
            std::string ext_name = port_name[0] == '_' ? port_name.substr(1) : port_name;
            structural_objectRef ext_port = interfaceObj->find_member(ext_name, port_o_K, interfaceObj);
            if(!ext_port)
            {
               if(port_in->get_kind() == port_vector_o_K)
                  ext_port = SM_minimal_interface->add_port_vector(ext_name, port_o::IN, GetPointer<port_o>(port_in)->get_ports_size(), interfaceObj, port_in->get_typeRef());
               else
                  ext_port = SM_minimal_interface->add_port(ext_name, port_o::IN, interfaceObj, port_in->get_typeRef());
            }
            port_o::fix_port_properties(port_in, ext_port);
            SM_minimal_interface->add_connection(port_in, ext_port);
         }
         else
         {
            structural_objectRef ext_port = interfaceObj->find_member(port_name, port_o_K, interfaceObj);

            if(!ext_port)
            {
               if(port_in->get_kind() == port_vector_o_K)
                  ext_port = SM_minimal_interface->add_port_vector(port_name, port_o::IN, GetPointer<port_o>(port_in)->get_ports_size(), interfaceObj, port_in->get_typeRef());
               else
               {
                  if(port_in->get_typeRef()->type == structural_type_descriptor::UINT || port_in->get_typeRef()->type == structural_type_descriptor::INT)
                  {
                     structural_type_descriptorRef vecbool = structural_type_descriptorRef(new structural_type_descriptor("bool", port_in->get_typeRef()->size));
                     ext_port = SM_minimal_interface->add_port(port_name, port_o::IN, interfaceObj, vecbool);
                  }
                  else
                     ext_port = SM_minimal_interface->add_port(port_name, port_o::IN, interfaceObj, port_in->get_typeRef());
               }
            }
            port_o::fix_port_properties(port_in, ext_port);
            SM_minimal_interface->add_connection(port_in, ext_port);
         }
      }
      else if(portsToConnect.find(port_in) != portsToConnect.end())
      {
         structural_objectRef sign;
         if(port_in->get_kind() == port_vector_o_K)
            sign = SM_minimal_interface->add_sign_vector(port_in->get_id() + "_INT", GetPointer<port_o>(port_in)->get_ports_size(), interfaceObj, port_in->get_typeRef());
         else
            sign = SM_minimal_interface->add_sign(port_in->get_id() + "_INT", interfaceObj, port_in->get_typeRef());
         SM_minimal_interface->add_connection(port_in, sign);
         SM_minimal_interface->add_connection(sign, portsToConnect[port_in]);
      }
      else if(portsToConstant.find(port_in) != portsToConstant.end())
      {
         if(null_values.find(GET_TYPE_SIZE(port_in)) == null_values.end())
         {
            structural_objectRef const_obj = SM_minimal_interface->add_constant("null_value_" + STR(GET_TYPE_SIZE(port_in)), interfaceObj, port_in->get_typeRef(), STR(0));
            null_values[GET_TYPE_SIZE(port_in)] = const_obj;
         }
         if(port_in->get_kind() == port_vector_o_K)
         {
            for(unsigned int p = 0; p < GetPointer<port_o>(port_in)->get_ports_size(); ++p)
            {
               structural_objectRef port_d = GetPointer<port_o>(port_in)->get_port(p);
               SM_minimal_interface->add_connection(port_d, null_values[GET_TYPE_SIZE(port_d)]);
            }
         }
         else
            SM_minimal_interface->add_connection(port_in, null_values[GET_TYPE_SIZE(port_in)]);
      }
      else if(portsToSigConnect.find(port_in) != portsToSigConnect.end())
      {
         structural_objectRef ext_port = interfaceObj->find_member(port_name, port_o_K, interfaceObj);
         if(!ext_port)
         {
            if(port_in->get_kind() == port_vector_o_K)
               ext_port = SM_minimal_interface->add_port_vector(port_name, port_o::IN, GetPointer<port_o>(port_in)->get_ports_size(), interfaceObj, port_in->get_typeRef());
            else
            {
               if(port_in->get_typeRef()->type == structural_type_descriptor::UINT || port_in->get_typeRef()->type == structural_type_descriptor::INT)
               {
                  structural_type_descriptorRef vecbool = structural_type_descriptorRef(new structural_type_descriptor("bool", port_in->get_typeRef()->size));
                  ext_port = SM_minimal_interface->add_port(port_name, port_o::IN, interfaceObj, vecbool);
               }
               else
                  ext_port = SM_minimal_interface->add_port(port_name, port_o::IN, interfaceObj, port_in->get_typeRef());
            }
         }
         port_o::fix_port_properties(port_in, ext_port);
         SM_minimal_interface->add_connection(portsToSigConnect[port_in], ext_port);
      }
   }

   // out ports
   for(unsigned int i = 0; i < GetPointer<module>(wrappedObj)->get_out_port_size(); ++i)
   {
      structural_objectRef port_out = GetPointer<module>(wrappedObj)->get_out_port(i);
      auto port_name = GetPointer<port_o>(port_out)->get_id();
      if(GetPointer<port_o>(port_out)->get_port_interface() != port_o::port_interface::PI_DEFAULT)
      {
         auto check_interfaces = [&](std::set<port_o::port_interface> interfList) -> bool { return interfList.find(GetPointer<port_o>(port_out)->get_port_interface()) != interfList.end(); };
         if(check_interfaces({port_o::port_interface::PI_WNONE,        port_o::port_interface::PI_WVALID,     port_o::port_interface::PI_RACK,        port_o::port_interface::PI_READ,        port_o::port_interface::PI_WRITE,
                              port_o::port_interface::PI_ADDRESS,      port_o::port_interface::PI_CHIPENABLE, port_o::port_interface::PI_WRITEENABLE, port_o::port_interface::PI_DOUT,        port_o::port_interface::M_AXI_AWVALID,
                              port_o::port_interface::M_AXI_AWADDR,    port_o::port_interface::M_AXI_AWID,    port_o::port_interface::M_AXI_AWLEN,    port_o::port_interface::M_AXI_AWSIZE,   port_o::port_interface::M_AXI_AWBURST,
                              port_o::port_interface::M_AXI_AWLOCK,    port_o::port_interface::M_AXI_AWCACHE, port_o::port_interface::M_AXI_AWPROT,   port_o::port_interface::M_AXI_AWQOS,    port_o::port_interface::M_AXI_AWREGION,
                              port_o::port_interface::M_AXI_AWUSER,    port_o::port_interface::M_AXI_WVALID,  port_o::port_interface::M_AXI_WDATA,    port_o::port_interface::M_AXI_WSTRB,    port_o::port_interface::M_AXI_WLAST,
                              port_o::port_interface::M_AXI_WID,       port_o::port_interface::M_AXI_WUSER,   port_o::port_interface::M_AXI_ARVALID,  port_o::port_interface::M_AXI_ARADDR,   port_o::port_interface::M_AXI_ARID,
                              port_o::port_interface::M_AXI_ARLEN,     port_o::port_interface::M_AXI_ARSIZE,  port_o::port_interface::M_AXI_ARBURST,  port_o::port_interface::M_AXI_ARLOCK,   port_o::port_interface::M_AXI_ARCACHE,
                              port_o::port_interface::M_AXI_ARPROT,    port_o::port_interface::M_AXI_ARQOS,   port_o::port_interface::M_AXI_ARREGION, port_o::port_interface::M_AXI_ARUSER,   port_o::port_interface::M_AXI_RREADY,
                              port_o::port_interface::M_AXI_BREADY,    port_o::port_interface::M_AXI_BUSER,   port_o::port_interface::S_AXIL_AWVALID, port_o::port_interface::S_AXIL_AWREADY, port_o::port_interface::S_AXIL_AWADDR,
                              port_o::port_interface::S_AXIL_WVALID,   port_o::port_interface::S_AXIL_WREADY, port_o::port_interface::S_AXIL_WDATA,   port_o::port_interface::S_AXIL_WSTRB,   port_o::port_interface::S_AXIL_ARVALID,
                              port_o::port_interface::S_AXIL_ARREADY,  port_o::port_interface::S_AXIL_ARADDR, port_o::port_interface::S_AXIL_RVALID,  port_o::port_interface::S_AXIL_RREADY,  port_o::port_interface::S_AXIL_RDATA,
                              port_o::port_interface::S_AXIL_RRESP,    port_o::port_interface::S_AXIL_BVALID, port_o::port_interface::S_AXIL_BREADY,  port_o::port_interface::S_AXIL_BRESP,   port_o::port_interface::PI_S_AXIS_TREADY,
                              port_o::port_interface::PI_M_AXIS_TVALID}))
         {
            portsToSkip.insert(port_out);
            std::string ext_name = port_name[0] == '_' ? port_name.substr(1) : port_name;
            structural_objectRef ext_port = interfaceObj->find_member(ext_name, port_o_K, interfaceObj);
            if(!ext_port)
            {
               if(port_out->get_kind() == port_vector_o_K)
                  ext_port = SM_minimal_interface->add_port_vector(ext_name, port_o::OUT, GetPointer<port_o>(port_out)->get_ports_size(), interfaceObj, port_out->get_typeRef());
               else
                  ext_port = SM_minimal_interface->add_port(ext_name, port_o::OUT, interfaceObj, port_out->get_typeRef());
            }
            port_o::fix_port_properties(port_out, ext_port);
            SM_minimal_interface->add_connection(port_out, ext_port);
         }
         else
            THROW_ERROR("not yet supported port interface" + STR(GetPointer<port_o>(port_out)->get_port_interface()));
      }
      if(portsToSkip.find(port_out) == portsToSkip.end() && portsToConnect.find(port_out) == portsToConnect.end() && portsToSigConnect.find(port_out) == portsToSigConnect.end())
      {
         if(parameters->isOption(OPT_done_name) && port_name == DONE_PORT_NAME)
            port_name = parameters->getOption<std::string>(OPT_done_name);
         structural_objectRef ext_port;
         if(port_out->get_kind() == port_vector_o_K)
            ext_port = SM_minimal_interface->add_port_vector(port_name, port_o::OUT, GetPointer<port_o>(port_out)->get_ports_size(), interfaceObj, port_out->get_typeRef());
         else
         {
            if(port_out->get_typeRef()->type == structural_type_descriptor::INT)
            {
               auto TM = HLSMgr->get_HLS_target()->get_technology_manager();
               std::string library_name = TM->get_library(VIEW_CONVERT_STD_INT);
               auto c_obj = SM_minimal_interface->add_module_from_technology_library(port_name + "_" + VIEW_CONVERT_STD_INT, VIEW_CONVERT_STD_INT, library_name, interfaceObj, TM);
               auto bit_size_port = port_out->get_typeRef()->size;
               structural_objectRef in1 = GetPointer<module>(c_obj)->get_in_port(0);
               in1->type_resize(bit_size_port);
               structural_objectRef sign = SM_minimal_interface->add_sign("out_" + c_obj->get_id(), interfaceObj, port_out->get_typeRef());
               SM_minimal_interface->add_connection(port_out, sign);
               SM_minimal_interface->add_connection(sign, in1);
               structural_objectRef out0 = GetPointer<module>(c_obj)->get_out_port(0);
               out0->type_resize(bit_size_port);
               THROW_ASSERT(out0->get_typeRef()->size, "size greater than one expected");
               structural_type_descriptorRef vecbool = structural_type_descriptorRef(new structural_type_descriptor("bool", port_out->get_typeRef()->size));
               ext_port = SM_minimal_interface->add_port(port_name, port_o::OUT, interfaceObj, vecbool);
               port_out = out0;
            }
            else if(port_out->get_typeRef()->type == structural_type_descriptor::UINT)
            {
               auto TM = HLSMgr->get_HLS_target()->get_technology_manager();
               std::string library_name = TM->get_library(VIEW_CONVERT_STD_UINT);
               auto c_obj = SM_minimal_interface->add_module_from_technology_library(port_name + "_" + VIEW_CONVERT_STD_UINT, VIEW_CONVERT_STD_UINT, library_name, interfaceObj, TM);
               auto bit_size_port = port_out->get_typeRef()->size;
               structural_objectRef in1 = GetPointer<module>(c_obj)->get_in_port(0);
               in1->type_resize(bit_size_port);
               structural_objectRef sign = SM_minimal_interface->add_sign("out_" + c_obj->get_id(), interfaceObj, port_out->get_typeRef());
               SM_minimal_interface->add_connection(port_out, sign);
               SM_minimal_interface->add_connection(sign, in1);
               structural_objectRef out0 = GetPointer<module>(c_obj)->get_out_port(0);
               out0->type_resize(bit_size_port);
               THROW_ASSERT(out0->get_typeRef()->size, "size greater than one expected");
               structural_type_descriptorRef vecbool = structural_type_descriptorRef(new structural_type_descriptor("bool", port_out->get_typeRef()->size));
               ext_port = SM_minimal_interface->add_port(port_name, port_o::OUT, interfaceObj, vecbool);
               port_out = out0;
            }
            else
               ext_port = SM_minimal_interface->add_port(port_name, port_o::OUT, interfaceObj, port_out->get_typeRef());
         }
         port_o::fix_port_properties(port_out, ext_port);
         SM_minimal_interface->add_connection(port_out, ext_port);
      }
      else if(portsToSigConnect.find(port_out) != portsToSigConnect.end())
      {
         structural_objectRef ext_port = interfaceObj->find_member(port_name, port_o_K, interfaceObj);
         if(!ext_port)
         {
            if(port_out->get_kind() == port_vector_o_K)
               ext_port = SM_minimal_interface->add_port_vector(port_name, port_o::OUT, GetPointer<port_o>(port_out)->get_ports_size(), interfaceObj, port_out->get_typeRef());
            else
            {
               if(port_out->get_typeRef()->type == structural_type_descriptor::UINT || port_out->get_typeRef()->type == structural_type_descriptor::INT)
               {
                  THROW_ERROR("unexpected condition");
               }
               else
                  ext_port = SM_minimal_interface->add_port(port_name, port_o::OUT, interfaceObj, port_out->get_typeRef());
            }
         }
         port_o::fix_port_properties(port_out, ext_port);
         SM_minimal_interface->add_connection(portsToSigConnect.find(port_out)->second, ext_port);
      }
      else if(port_out->get_kind() == port_vector_o_K && !GetPointer<port_o>(port_out)->find_bounded_object())
      {
         for(unsigned int p = 0; p < GetPointer<port_o>(port_out)->get_ports_size(); ++p)
         {
            structural_objectRef port_d = GetPointer<port_o>(port_out)->get_port(p);
            if(!GetPointer<port_o>(port_d)->find_bounded_object())
            {
               std::string name = "null_out_signal_" + port_out->get_owner()->get_id() + "_" + port_out->get_id() + "_" + port_d->get_id();
               structural_objectRef sign = SM_minimal_interface->add_sign(name, interfaceObj, port_d->get_typeRef());
               SM_minimal_interface->add_connection(port_d, sign);
            }
         }
      }
   }

   // in-out ports
   for(unsigned int i = 0; i < GetPointer<module>(wrappedObj)->get_in_out_port_size(); ++i)
   {
      structural_objectRef port_in_out = GetPointer<module>(wrappedObj)->get_in_out_port(i);
      structural_objectRef ext_port;
      if(port_in_out->get_kind() == port_vector_o_K)
         ext_port = SM_minimal_interface->add_port_vector(GetPointer<port_o>(port_in_out)->get_id(), port_o::IO, GetPointer<port_o>(port_in_out)->get_ports_size(), interfaceObj, port_in_out->get_typeRef());
      else
         ext_port = SM_minimal_interface->add_port(GetPointer<port_o>(port_in_out)->get_id(), port_o::IO, interfaceObj, port_in_out->get_typeRef());
      port_o::fix_port_properties(port_in_out, ext_port);
      SM_minimal_interface->add_connection(port_in_out, ext_port);
   }
}
