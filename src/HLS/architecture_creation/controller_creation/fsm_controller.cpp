/*
 *
 *                   _/_/_/    _/_/   _/    _/ _/_/_/    _/_/
 *                  _/   _/ _/    _/ _/_/  _/ _/   _/ _/    _/
 *                 _/_/_/  _/_/_/_/ _/  _/_/ _/   _/ _/_/_/_/
 *                _/      _/    _/ _/    _/ _/   _/ _/    _/
 *               _/      _/    _/ _/    _/ _/_/_/  _/    _/
 *
 *             ***********************************************
 *                              PandA Project
 *                     URL: http://panda.dei.polimi.it
 *                       Politecnico di Milano - DEIB
 *                        System Architectures Group
 *             ***********************************************
 *              Copyright (C) 2004-2024 Politecnico di Milano
 *
 *   This file is part of the PandA framework.
 *
 *   The PandA framework is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
/**
 * @file fsm_controller.cpp
 * @brief Starting from the FSM graph, it builds a state transition table
 *
 * @author Christian Pilato <pilato@elet.polimi.it>
 * @author Fabrizio Ferrandi <fabrizio.ferrandi@polimi.it>
 *
 */
#include "fsm_controller.hpp"
#include "BambuParameter.hpp"
#include "allocation_information.hpp"
#include "basic_block.hpp"
#include "behavioral_helper.hpp"
#include "commandport_obj.hpp"
#include "conn_binding.hpp"
#include "copyrights_strings.hpp"
#include "custom_map.hpp"
#include "custom_set.hpp"
#include "dbgPrintHelper.hpp"
#include "exceptions.hpp"
#include "fu_binding.hpp"
#include "function_behavior.hpp"
#include "funit_obj.hpp"
#include "hls.hpp"
#include "hls_manager.hpp"
#include "liveness.hpp"
#include "multi_unbounded_obj.hpp"
#include "mux_obj.hpp"
#include "op_graph.hpp"
#include "reg_binding.hpp"
#include "register_obj.hpp"
#include "schedule.hpp"
#include "state_transition_graph.hpp"
#include "state_transition_graph_manager.hpp"
#include "storage_value_information.hpp"
#include "string_manipulation.hpp" // for GET_CLASS
#include "structural_manager.hpp"
#include "structural_objects.hpp"
#include "technology_manager.hpp"
#include "technology_node.hpp"
#include "tree_helper.hpp"
#include "tree_manager.hpp"
#include "tree_node.hpp"
#include "tree_reindex.hpp"
#include <deque>
#include <iosfwd>
#include <list>
#include <utility>
#include <vector>

fsm_controller::fsm_controller(const ParameterConstRef _Param, const HLS_managerRef _HLSMgr, unsigned int _funId,
                               const DesignFlowManagerConstRef _design_flow_manager,
                               const HLSFlowStep_Type _hls_flow_step_type)
    : ControllerCreatorBaseStep(_Param, _HLSMgr, _funId, _design_flow_manager, _hls_flow_step_type)
{
   debug_level = parameters->get_class_debug_level(GET_CLASS(*this), DEBUG_LEVEL_NONE);
}

fsm_controller::~fsm_controller() = default;

DesignFlowStep_Status fsm_controller::InternalExec()
{
   THROW_ASSERT(HLS->STG, "State transition graph not created");

   /// top circuit creation
   PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "FSM based controller creation");
   const FunctionBehaviorConstRef FB = HLSMgr->CGetFunctionBehavior(funId);

   const std::string function_name = FB->CGetBehavioralHelper()->get_function_name();
   /// main circuit type
   structural_type_descriptorRef module_type =
       structural_type_descriptorRef(new structural_type_descriptor("controller_" + function_name));
   structural_managerRef SM = this->HLS->controller;

   SM->set_top_info("Controller_i", module_type);
   structural_objectRef circuit = SM->get_circ();
   // Now the top circuit is created, just as an empty box. <circuit> is a reference to the structural object that
   // will contain all the circuit components

   circuit->set_black_box(false);

   /// Set some descriptions and legal stuff
   GetPointer<module>(circuit)->set_description("FSM based controller description for " + function_name);
   GetPointer<module>(circuit)->set_copyright(GENERATED_COPYRIGHT);
   GetPointer<module>(circuit)->set_authors("Component automatically generated by bambu");
   GetPointer<module>(circuit)->set_license(GENERATED_LICENSE);

   // Add clock, reset, done and command ports
   this->add_common_ports(circuit, SM);

   PRINT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "Creating state machine representations...");
   std::string state_representation;
   this->create_state_machine(state_representation);
   add_FSM(state_representation, SM);
   add_FSM_stages(SM);

   PRINT_DBG_MEX(DEBUG_LEVEL_VERBOSE, debug_level, "Circuit created without errors!");
   out_ports.clear();
   mu_ports.clear();
   cond_ports.clear();
   return DesignFlowStep_Status::SUCCESS;
}

static std::string input_vector_to_string(const std::vector<long long int>& to_be_printed)
{
   std::string output;
   for(unsigned int i = 0; i < to_be_printed.size(); i++)
   {
      output += (to_be_printed[i] == default_COND ? "-" : std::to_string(to_be_printed[i]));
      if(i != (to_be_printed.size() - 1))
      {
         output += "/";
      }
   }
   return output;
}

void fsm_controller::create_state_machine(std::string& parse)
{
   INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "-->Create state machine");
   const auto stg = HLS->STG->CGetStg();
   const auto astg = HLS->STG->CGetAstg();
   const auto FB = HLSMgr->CGetFunctionBehavior(funId);
   const auto data = FB->CGetOpGraph(FunctionBehavior::CFG);
   const auto is_function_pipelined = FB->is_function_pipelined();
   const auto TreeM = HLSMgr->get_tree_manager();

   const auto entry = HLS->STG->get_entry_state();
   THROW_ASSERT(boost::out_degree(entry, *stg) == 1, "Non deterministic initial state");
   /// Getting first state (initial one). It will be also first state for resetting
   const auto first_state = boost::target(*boost::out_edges(entry, *stg).first, *stg);
   /// adding reset state to machine encoding
   parse += stg->CGetStateInfo(first_state)->name + " " + RESET_PORT_NAME + " " + START_PORT_NAME + " " +
            CLOCK_PORT_NAME + ";\n";

   const auto& selectors = HLS->Rconn->GetSelectors();

   std::map<vertex, std::vector<long long int>> present_state;
   CustomOrderedSet<unsigned int> unbounded_ports;

   /// analysis for each state to compute the default output
   INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "-->Computation of default output of each state");
   std::list<vertex> working_list;
   astg->TopologicalSort(working_list);
   THROW_ASSERT(std::find(working_list.begin(), working_list.end(), first_state) != working_list.end(),
                "unexpected case");
   working_list.erase(std::find(working_list.begin(), working_list.end(), first_state));
   working_list.push_front(first_state); /// ensure that first_state is the really first one...

   std::map<vertex, std::vector<bool>> state_Xregs;
   std::map<unsigned int, unsigned int> wren_list;
   std::map<unsigned int, unsigned int> register_selectors;

   // detect entry and exit node for each loop
   std::map<unsigned int, std::map<vertex, std::set<unsigned int>>> bypass_signals;
   for(const auto& v : working_list)
   {
      state_Xregs[v] = std::vector<bool>(HLS->Rreg->get_used_regs(), true);
      INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "-->Analyzing state " + astg->CGetStateInfo(v)->name);

      INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level,
                     "Analyzing loop " + std::to_string(stg->CGetStateInfo(v)->loopId));
      present_state[v] = std::vector<long long int>(out_num, 0);

      if(selectors.find(conn_binding::IN) != selectors.end())
      {
         for(const auto& s : selectors.at(conn_binding::IN))
         {
#ifndef NDEBUG
            std::map<vertex, CustomOrderedSet<vertex>> activations_check;
#endif
            const auto& activations = GetPointer<commandport_obj>(s.second)->get_activations();
            for(const auto& a : activations)
            {
#ifndef NDEBUG
               if(activations_check.find(std::get<0>(a)) != activations_check.end())
               {
                  THROW_ASSERT(!activations_check.find(std::get<0>(a))->second.empty(), "empty set not expected here");
                  if(activations_check.at(std::get<0>(a)).find(std::get<1>(a)) ==
                     activations_check.at(std::get<0>(a)).end())
                  {
                     if(std::get<1>(a) == NULL_VERTEX)
                     {
                        THROW_ERROR("non compatible transitions added");
                     }
                     else if(activations_check.at(std::get<0>(a)).find(NULL_VERTEX) !=
                             activations_check.at(std::get<0>(a)).end())
                     {
                        THROW_ERROR("non compatible transitions added");
                     }
                     else
                     {
                        activations_check[std::get<0>(a)].insert(std::get<1>(a));
                     }
                  }
                  else
                  {
                     THROW_ERROR("activation already added " + astg->CGetStateInfo(std::get<0>(a))->name + "->" +
                                 astg->CGetStateInfo(std::get<1>(a))->name + " -- " +
                                 FB->CGetBehavioralHelper()->PrintVariable(std::get<2>(a).first));
                  }
               }
               else
               {
                  activations_check[std::get<0>(a)].insert(std::get<1>(a));
               }
#endif
               if(std::get<0>(a) == v)
               {
                  present_state[v][out_ports[s.second]] = 1;
               }
            }
         }
      }

      CustomOrderedSet<generic_objRef> active_fu;
      const auto& operations = astg->CGetStateInfo(v)->executing_operations;
      for(const auto& op : operations)
      {
         active_fu.insert(HLS->Rfu->get(op));
         const auto tn = HLS->allocation_information->get_fu(HLS->Rfu->get_assign(op));
         const auto op_tn = GetPointer<functional_unit>(tn)->get_operation(
             tree_helper::NormalizeTypename(data->CGetOpNodeInfo(op)->GetOperation()));
         THROW_ASSERT(GetPointer<operation>(op_tn)->time_m,
                      "Time model not available for operation: " + GET_NAME(data, op));
         const auto CM = GetPointer<functional_unit>(tn)->CM;
         if(!CM)
         {
            continue;
         }
         const auto top = CM->get_circ();
         THROW_ASSERT(top, "expected");
         const auto fu_module = GetPointer<module>(top);
         THROW_ASSERT(fu_module, "expected");
         const auto start_port_i = fu_module->find_member(START_PORT_NAME, port_o_K, top);
         const auto done_port_i = fu_module->find_member(DONE_PORT_NAME, port_o_K, top);
         /// do some checks
         if(!GetPointer<operation>(op_tn)->is_bounded() && (!start_port_i || !done_port_i))
         {
            THROW_ERROR("Unbounded operations have to have both done_port and start_port ports!" +
                        STR(TreeM->CGetTreeNode(data->CGetOpNodeInfo(op)->GetNodeId())));
         }
         bool is_starting_operation = std::find(stg->CGetStateInfo(v)->starting_operations.begin(),
                                                stg->CGetStateInfo(v)->starting_operations.end(),
                                                op) != stg->CGetStateInfo(v)->starting_operations.end();

         if((!GetPointer<operation>(op_tn)->is_bounded()))
         {
            auto node = TreeM->CGetTreeNode(data->CGetOpNodeInfo(op)->GetNodeId());
            if(node->get_kind() == gimple_assign_K)
            {
               const auto nodeGA = GetPointerS<const gimple_assign>(node);
               const auto ssaIndex = GET_INDEX_CONST_NODE(nodeGA->op0);
               const auto stepOut = HLS->Rliv->GetStep(v, op, ssaIndex, false);
               if(HLS->storage_value_information->is_a_storage_value(v, ssaIndex, stepOut))
               {
                  const auto storage_value_index =
                      HLS->storage_value_information->get_storage_value_index(v, ssaIndex, stepOut);
                  const auto written_reg = HLS->Rreg->get_register(storage_value_index);
                  const auto doneCommand =
                      HLS->Rconn->bind_selector_port(conn_binding::OUT, commandport_obj::UNBOUNDED, op, data);
                  const auto doneVertex = GetPointer<commandport_obj>(doneCommand)->get_vertex();
                  THROW_ASSERT(cond_ports.find(doneVertex) != cond_ports.end(), "unexpected condition");
                  const auto reg_obj = HLS->Rreg->get(written_reg);
                  const auto sel_port = GetPointer<register_obj>(reg_obj)->get_wr_enable();
                  THROW_ASSERT(out_ports.find(sel_port) != out_ports.end(), "");
                  bypass_signals[1 + out_ports.find(sel_port)->second][v].insert(cond_ports.find(doneVertex)->second);
               }
            }
         }

         if((!GetPointer<operation>(op_tn)->is_bounded() || start_port_i) && (!stg->CGetStateInfo(v)->is_dummy) &&
            is_starting_operation)
         {
            const auto unbounded_port =
                out_ports[HLS->Rconn->bind_selector_port(conn_binding::IN, commandport_obj::UNBOUNDED, op, data)];
            unbounded_ports.insert(unbounded_port);
            present_state[v][unbounded_port] = 1;
         }
      }

      for(auto in0 : HLS->Rliv->get_live_in(v))
      {
         if(HLS->storage_value_information->is_a_storage_value(v, in0.first, in0.second))
         {
            const auto storage_value_index =
                HLS->storage_value_information->get_storage_value_index(v, in0.first, in0.second);
            const auto accessed_reg = HLS->Rreg->get_register(storage_value_index);
            state_Xregs[v][accessed_reg] = false;
         }
      }

      if(selectors.find(conn_binding::IN) != selectors.end())
      {
         for(const auto& s : selectors.at(conn_binding::IN))
         {
            if(s.second->get_type() == generic_obj::COMMAND_PORT)
            {
               auto current_port = GetPointer<commandport_obj>(s.second);
               // compute X values for wr_enable signals
               if(current_port->get_command_type() == commandport_obj::command_type::WRENABLE)
               {
                  auto reg_obj = GetPointer<register_obj>(current_port->get_elem());
                  wren_list.insert(std::make_pair(reg_obj->get_register_index(), out_ports[s.second]));
                  if(parameters->IsParameter("enable-FSMX") && parameters->GetParameter<int>("enable-FSMX") == 1)
                  {
                     if(state_Xregs[v][reg_obj->get_register_index()] && v != first_state)
                     {
                        present_state[v][out_ports[s.second]] = 2;
                        INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level,
                                       "Set X value for wr_en on register reg_" +
                                           std::to_string(reg_obj->get_register_index()));
                     }
                  }
               }
               else if(current_port->get_command_type() == commandport_obj::command_type::SELECTOR)
               {
                  const auto selector_slave = current_port->get_elem();
                  if(GetPointer<mux_obj>(selector_slave))
                  {
                     auto mux_slave = GetPointer<mux_obj>(selector_slave)->get_final_target();
                     if(mux_slave->get_type() == generic_obj::resource_type::REGISTER)
                     {
                        const auto reg_index = GetPointer<register_obj>(mux_slave)->get_register_index();
                        register_selectors[out_ports[s.second]] = reg_index;
                     }
                     else if(mux_slave->get_type() == generic_obj::resource_type::FUNCTIONAL_UNIT &&
                             active_fu.find(mux_slave) == active_fu.end())
                     {
                        if(parameters->IsParameter("enable-FSMX") && parameters->GetParameter<int>("enable-FSMX") == 1)
                        {
                           present_state[v][out_ports[s.second]] = 2;
                        }
                     }
                  }
               }
               else if(current_port->get_command_type() == commandport_obj::command_type::OPERATION)
               {
               }
            }
         }
      }

      INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level,
                     "---default output after considering unbounded: " + container_to_string(present_state[v], " "));
      INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "<--");
   }
   INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "<--Computed default output of each state");

   /// write bypass assignments
   bool first_io = true;
   for(const auto& vio : bypass_signals)
   {
      if(first_io)
      {
         first_io = false;
      }
      else
      {
         parse += ":";
      }
      parse += STR(vio.first) + "=";
      bool first_vi = true;
      for(const auto& vi : vio.second)
      {
         if(first_vi)
         {
            first_vi = false;
         }
         else
         {
            parse += ",";
         }
         parse += stg->CGetStateInfo(vi.first)->name + ">";
         bool first_i = true;
         for(const auto& i : vi.second)
         {
            if(first_i)
            {
               first_i = false;
            }
            else
            {
               parse += "<";
            }
            parse += STR(i);
         }
      }
   }
   parse += ";\n";

   const auto exit_state = HLS->STG->get_exit_state();
   const auto entry_state = HLS->STG->get_entry_state();
   for(const auto& v : working_list)
   {
      // for every loop controller set the proper transition depending on the done port
      if(entry_state == v or (exit_state == v && !is_function_pipelined))
      {
         continue;
      }

      INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "-->Analyzing state " + stg->CGetStateInfo(v)->name);

      parse += stg->CGetStateInfo(v)->name + " 0/" + input_vector_to_string(present_state[v]);

      std::list<EdgeDescriptor> sorted;
      EdgeDescriptor default_edge;
      bool found_default = false;
      vertex ver = v;

      BOOST_FOREACH(EdgeDescriptor oe, boost::out_edges(ver, *stg))
      {
         if(!found_default)
         {
            if(stg->CGetTransitionInfo(oe)->get_has_default())
            {
               found_default = true;
               default_edge = oe;
            }
            if(!found_default)
            {
               sorted.push_back(oe);
            }
         }
         else
         {
            sorted.push_back(oe);
         }
      }
      if(found_default)
      {
         sorted.push_back(default_edge);
      }
      INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "---Sorted next states");

      bool done_port_is_registered = HLS->registered_done_port;
      for(const auto e : sorted)
      {
         INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level,
                        "-->Considering successor state " + stg->CGetStateInfo(boost::target(e, *stg))->name);
         INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "---Number of inputs is " + std::to_string(in_num));
         std::vector<std::string> in(in_num, "-");

         INDENT_DBG_MEX(DEBUG_LEVEL_VERY_PEDANTIC, debug_level, "-->Analyzing condition");
         auto transitionType = stg->CGetTransitionInfo(e)->get_type();
         if(transitionType == DONTCARE_COND)
         {
            ; // do nothing
         }
         else if(transitionType == TRUE_COND)
         {
            auto op = stg->CGetTransitionInfo(e)->get_operation();
            THROW_ASSERT(cond_ports.find(op) != cond_ports.end(), "the port is missing");
            THROW_ASSERT(in[cond_ports.find(op)->second] == "-", "two different values for the same condition port");
            in[cond_ports.find(op)->second] = "1";
         }
         else if(transitionType == FALSE_COND)
         {
            auto op = stg->CGetTransitionInfo(e)->get_operation();
            THROW_ASSERT(cond_ports.find(op) != cond_ports.end(), "the port is missing");
            THROW_ASSERT(in[cond_ports.find(op)->second] == "-", "two different values for the same condition port");
            in[cond_ports.find(op)->second] = "0";
         }
         else if(transitionType == ALL_FINISHED)
         {
            auto ops = stg->CGetTransitionInfo(e)->get_operations();
            if(ops.size() == 1)
            {
               auto op = *(ops.begin());
               THROW_ASSERT(cond_ports.find(op) != cond_ports.end(), "the port is missing");
               THROW_ASSERT(in[cond_ports.find(op)->second] == "-", "two different values for the same condition port");
               in[cond_ports.find(op)->second] = "1";
            }
            else
            {
               auto state = stg->CGetTransitionInfo(e)->get_ref_state();
               THROW_ASSERT(mu_ports.find(state) != mu_ports.end(), "the port is missing");
               THROW_ASSERT(in[mu_ports.find(state)->second] == "-",
                            "two different values for the same condition port");
               in[mu_ports.find(state)->second] = "1";
            }
         }
         else if(transitionType == NOT_ALL_FINISHED)
         {
            auto ops = stg->CGetTransitionInfo(e)->get_operations();
            if(ops.size() == 1)
            {
               auto op = *(ops.begin());
               THROW_ASSERT(cond_ports.find(op) != cond_ports.end(), "the port is missing");
               THROW_ASSERT(in[cond_ports.find(op)->second] == "-", "two different values for the same condition port");
               in[cond_ports.find(op)->second] = "0";
            }
            else
            {
               auto state = stg->CGetTransitionInfo(e)->get_ref_state();
               THROW_ASSERT(mu_ports.find(state) != mu_ports.end(), "the port is missing");
               THROW_ASSERT(in[mu_ports.find(state)->second] == "-",
                            "two different values for the same condition port");
               in[mu_ports.find(state)->second] = "0";
            }
         }
         else if(transitionType == CASE_COND)
         {
            auto op = stg->CGetTransitionInfo(e)->get_operation();
            THROW_ASSERT(cond_ports.find(op) != cond_ports.end(), "the port is missing");
            THROW_ASSERT(in[cond_ports.find(op)->second] == "-", "two different values for the same condition port");
            std::string value = in[cond_ports.find(op)->second];
            THROW_ASSERT(value == "-", "two different values for the same condition port");
            auto labels = stg->CGetTransitionInfo(e)->get_labels();
            for(auto label : labels)
            {
               if(value == "-")
               {
                  value = get_guard_value(TreeM, label, op, data);
               }
               else
               {
                  value += "|" + get_guard_value(TreeM, label, op, data);
               }
            }
            if(stg->CGetTransitionInfo(e)->get_has_default())
            {
               if(value == "-")
               {
                  value = STR(default_COND);
               }
               else
               {
                  value += "|" + STR(default_COND);
               }
            }
            in[cond_ports.find(op)->second] = value;
         }
         else
         {
            THROW_ERROR("transition type not supported yet");
         }
         INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "<--Analyzed conditions");

         parse += " : ";
         for(auto in_it = in.begin(); in_it != in.end(); ++in_it)
         {
            if(in_it == in.begin())
            {
               parse += *in_it;
            }
            else
            {
               parse += "," + *in_it;
            }
         }

         vertex tgt = boost::target(e, *stg);
         bool last_transition = (tgt == exit_state && !is_function_pipelined) ||
                                (is_function_pipelined && exit_state == boost::source(e, *stg));
         vertex next_state = last_transition && !is_function_pipelined ? first_state : tgt;
         bool assert_done_port = false;
         if(done_port_is_registered)
         {
            BOOST_FOREACH(EdgeDescriptor os, boost::out_edges(tgt, *stg))
            {
               if((boost::target(os, *stg) == exit_state && !is_function_pipelined) ||
                  boost::source(os, *stg) == exit_state)
               {
                  assert_done_port = true;
                  break;
               }
            }
         }
         else
         {
            assert_done_port = last_transition;
         }

         std::vector<long long int> transition_outputs(out_num, default_COND);
         for(unsigned int k = 0; k < out_num; k++)
         {
            if(present_state[v][k] == 1 && unbounded_ports.find(k) == unbounded_ports.end())
            {
               transition_outputs[k] = 0;
            }
         }

         if(selectors.find(conn_binding::IN) != selectors.end())
         {
            for(const auto& s : selectors.at(conn_binding::IN))
            {
               auto current_port = GetPointer<commandport_obj>(s.second);
               if(current_port->get_command_type() == commandport_obj::command_type::MULTI_UNBOUNDED_ENABLE)
               {
                  auto mu_obj = GetPointer<multi_unbounded_obj>(current_port->get_elem());
                  if(v == mu_obj->get_fsm_state())
                  {
                     transition_outputs[out_ports[s.second]] = 1;
                  }
               }
               const auto& activations = current_port->get_activations();
               for(const auto& a : activations)
               {
                  THROW_ASSERT(v != NULL_VERTEX && std::get<0>(a) != NULL_VERTEX, "error on source vertex");
                  const auto source_activation = std::get<0>(a) == v;

                  if(source_activation && (std::get<1>(a) == tgt || std::get<1>(a) == NULL_VERTEX))
                  {
                     THROW_ASSERT(present_state[v][out_ports[s.second]] != 0, "unexpected condition");
                     auto data_operation = std::get<2>(a);
                     if(data_operation.second != NULL_VERTEX)
                     {
                        THROW_ASSERT(cond_ports.find(data_operation.second) != cond_ports.end(),
                                     "unexpected condition");
                        transition_outputs[out_ports[s.second]] = cond_ports.at(data_operation.second) + 3;
                     }
                     else
                     {
                        transition_outputs[out_ports[s.second]] = 1;
                     }
                  }
               }
            }

            for(auto const& sel : register_selectors)
            {
               if(parameters->IsParameter("enable-FSMX") && parameters->GetParameter<int>("enable-FSMX") == 1)
               {
                  if(wren_list.find(sel.second) != wren_list.end() &&
                     ((transition_outputs[wren_list[sel.second]] == 0) ||
                      (transition_outputs[wren_list[sel.second]] == default_COND &&
                       present_state[v][wren_list[sel.second]] != 1)))
                  {
                     transition_outputs[sel.first] = 2;
                  }
               }
            }
         }

         for(unsigned int k = 0; k < out_num; k++)
         {
            if(present_state[v][k] == transition_outputs[k])
            {
               transition_outputs[k] = default_COND;
            }
            else if(present_state[v][k] != transition_outputs[k] && present_state[v][k] == 1 &&
                    transition_outputs[k] == 0)
            {
               // std::cerr << "k " << k << " to " << HLS->STG->get_state_name(tgt)<< std::endl;
               // abort();
            }
         }

         parse += " " + stg->CGetStateInfo(next_state)->name + " " + (assert_done_port ? "1/" : "-/") +
                  input_vector_to_string(transition_outputs);
         INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "<--");
      }

      parse += "; ";

      parse += "\n";
      INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "<--Analyzed state " + stg->CGetStateInfo(v)->name);
   }

   INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "<--Created state machine");
   INDENT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "---Finite_state_machine representation\n" + parse);
}

std::string fsm_controller::get_guard_value(const tree_managerRef TM, const unsigned int index, vertex op,
                                            const OpGraphConstRef data)
{
   if((GET_TYPE(data, op) & TYPE_MULTIIF) != 0)
   {
      unsigned int node_id = data->CGetOpNodeInfo(op)->GetNodeId();
      unsigned int pos = tree_helper::get_multi_way_if_pos(TM, node_id, index);
      return "&" + STR(pos);
   }
   else
   {
      tree_nodeRef node = TM->get_tree_node_const(index);
      THROW_ASSERT(node->get_kind() == case_label_expr_K, "case_label_expr expected " + GET_NAME(data, op));
      auto cle = GetPointer<case_label_expr>(node);
      THROW_ASSERT(cle->op0, "guard expected in a case_label_expr");
      THROW_ASSERT(GetPointer<integer_cst>(GET_NODE(cle->op0)),
                   "expected integer_cst object as guard in a case_label_expr");
      const auto low_result = tree_helper::GetConstValue(cle->op0);
      integer_cst_t high_result = 0;
      if(cle->op1)
      {
         THROW_ASSERT(GetPointer<integer_cst>(GET_NODE(cle->op1)),
                      "expected integer_cst object as guard in a case_label_expr");
         high_result = tree_helper::GetConstValue(cle->op1);
      }
      if(high_result == 0)
      {
         return STR(low_result);
      }
      else
      {
         std::string res_string;
         for(auto current_value = low_result; current_value <= high_result; ++current_value)
         {
            if(current_value == low_result)
            {
               res_string = STR(current_value);
            }
            else
            {
               res_string += "|" + STR(current_value);
            }
         }
         return res_string;
      }
   }
}

void fsm_controller::add_FSM(const std::string& state_representation, structural_managerRef SM)
{
   structural_objectRef circuit = SM->get_circ();
   SM->add_NP_functionality(circuit, NP_functionality::FSM, state_representation);
   PRINT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "Machine encoding");
   PRINT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, state_representation);
   PRINT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "****");
}

void fsm_controller::add_FSM_stages(structural_managerRef SM)
{
   const auto FB = HLSMgr->CGetFunctionBehavior(funId);
   const auto is_function_pipelined = FB->is_function_pipelined();
   if(is_function_pipelined && !FB->is_stp())
   {
      const auto data = FB->CGetOpGraph(FunctionBehavior::CFG);
      std::list<vertex> working_list;
      const auto astg = HLS->STG->CGetAstg();
      const auto stg = HLS->STG->CGetStg();
      astg->TopologicalSort(working_list);
      const auto n_stages = HLS->STG->CGetStg()->CGetStateTransitionGraphInfo()->n_stages;
      std::string stage_table = std::to_string(n_stages) + "|";
      const auto TreeM = HLSMgr->get_tree_manager();
      const auto entry_state = HLS->STG->get_entry_state();
      const auto exit_state = HLS->STG->get_exit_state();
      bool first_ds_state = false;
      bool done_port_is_registered = HLS->registered_done_port;

      for(const auto& v : working_list)
      {
         if(entry_state == v)
         {
            continue;
         }
         if(astg->CGetStateInfo(v)->is_dummy)
         {
            if(!first_ds_state)
            {
               first_ds_state = true;
            }
            else
            {
               stage_table += ";";
            }
            stage_table += astg->CGetStateInfo(v)->name;
         }
      }
      stage_table += "|";
      for(const auto& v : working_list)
      {
         if(entry_state == v)
         {
            continue;
         }
         for(const auto& op : astg->CGetStateInfo(v)->ending_operations)
         {
            auto node = TreeM->CGetTreeNode(data->CGetOpNodeInfo(op)->GetNodeId());
            if(node->get_kind() == gimple_assign_K)
            {
               const auto nodeGA = GetPointerS<const gimple_assign>(node);
               const auto ssaIndex = GET_INDEX_CONST_NODE(nodeGA->op0);
               const auto reg_stage = HLS->Rliv->GetStepWrite(v, op);
               if(HLS->storage_value_information->is_a_storage_value(v, ssaIndex, reg_stage))
               {
                  const auto storage_value_index =
                      HLS->storage_value_information->get_storage_value_index(v, ssaIndex, reg_stage);
                  const auto written_reg = HLS->Rreg->get_register(storage_value_index);
                  const auto reg_obj = HLS->Rreg->get(written_reg);

                  const auto sel_port = GetPointer<register_obj>(reg_obj)->get_wr_enable();

                  THROW_ASSERT(out_ports.find(sel_port) != out_ports.end(), "");
                  auto reg_port = 1 + out_ports.at(sel_port);
                  stage_table += astg->CGetStateInfo(v)->name + ":" + std::to_string(reg_port) + ":" +
                                 std::to_string(reg_stage) + ";";
               }
            }
         }
         for(const auto& op : astg->CGetStateInfo(v)->starting_operations)
         {
            const auto tn = HLS->allocation_information->get_fu(HLS->Rfu->get_assign(op));
            const auto op_tn = GetPointer<functional_unit>(tn)->get_operation(
                tree_helper::NormalizeTypename(data->CGetOpNodeInfo(op)->GetOperation()));
            const auto CM = GetPointer<functional_unit>(tn)->CM;
            if(!CM)
            {
               continue;
            }
            const auto top = CM->get_circ();
            THROW_ASSERT(top, "expected");
            const auto fu_module = GetPointer<module>(top);
            THROW_ASSERT(fu_module, "expected");
            const auto start_port_i = fu_module->find_member(START_PORT_NAME, port_o_K, top);
            if(start_port_i)
            {
               const auto op_port =
                   1 +
                   out_ports[HLS->Rconn->bind_selector_port(conn_binding::IN, commandport_obj::UNBOUNDED, op, data)];
               auto op_stage = 1 + HLS->Rliv->GetStepOp(v, op);
               stage_table +=
                   astg->CGetStateInfo(v)->name + ":" + std::to_string(op_port) + ":" + std::to_string(op_stage) + ";";
            }
         }
         for(const auto& op : astg->CGetStateInfo(v)->executing_operations)
         {
            if((GET_TYPE(data, op) & TYPE_PHI) == 0)
            {
               auto fu = HLS->Rfu->get_assign(op);
               auto idx = HLS->Rfu->get_index(op);
               const auto tmp_ops_node_size =
                   GetPointer<functional_unit>(HLS->allocation_information->get_fu(fu))->get_operations().size();
               bool is_starting_operation = std::find(astg->CGetStateInfo(v)->starting_operations.begin(),
                                                      astg->CGetStateInfo(v)->starting_operations.end(),
                                                      op) != astg->CGetStateInfo(v)->starting_operations.end();

               if(tmp_ops_node_size > 1U && (!(GET_TYPE(data, op) & (TYPE_LOAD | TYPE_STORE)) || is_starting_operation))
               {
                  const auto selector_obj = GetPointer<funit_obj>(HLS->Rfu->get(fu, idx))
                                                ->GetSelector_op(data->CGetOpNodeInfo(op)->GetOperation());
                  const auto op_port = 1 + out_ports[selector_obj];
                  auto op_stage = 1 + HLS->Rliv->GetStepOp(v, op);
                  stage_table += astg->CGetStateInfo(v)->name + ":" + std::to_string(op_port) + ":" +
                                 std::to_string(op_stage) + ";";
               }
            }
         }
         if(done_port_is_registered)
         {
            bool assert_done_port = false;
            BOOST_FOREACH(EdgeDescriptor oe, boost::out_edges(v, *stg))
            {
               vertex tgt = boost::target(oe, *stg);
               if(tgt == exit_state)
               {
                  assert_done_port = true;
                  break;
               }
            }
            if(assert_done_port)
            {
               stage_table +=
                   astg->CGetStateInfo(v)->name + ":" + std::to_string(0) + ":" + std::to_string(n_stages) + ";";
            }
         }
         else if(exit_state == v)
         {
            stage_table +=
                astg->CGetStateInfo(v)->name + ":" + std::to_string(0) + ":" + std::to_string(n_stages) + ";";
         }
      }

      /// manage input condition
      stage_table += "|";
      for(const auto& v : working_list)
      {
         if(entry_state == v)
         {
            continue;
         }
         BOOST_FOREACH(EdgeDescriptor oe, boost::out_edges(v, *stg))
         {
            auto transitionType = stg->CGetTransitionInfo(oe)->get_type();
            if(transitionType == ALL_FINISHED || transitionType == NOT_ALL_FINISHED)
            {
               auto ops = stg->CGetTransitionInfo(oe)->get_operations();
               if(ops.size() == 1)
               {
                  auto op = *(ops.begin());
                  auto op_port = cond_ports.find(op)->second;
                  auto op_stage = HLS->Rliv->GetStepOp(v, op);
                  stage_table += astg->CGetStateInfo(v)->name + ":" + std::to_string(op_port) + ":" +
                                 std::to_string(op_stage) + ";";
               }
            }
         }
      }

      PRINT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "FSM stage table");
      PRINT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, stage_table);
      PRINT_DBG_MEX(DEBUG_LEVEL_PEDANTIC, debug_level, "****");
      structural_objectRef circuit = SM->get_circ();
      SM->add_NP_functionality(circuit, NP_functionality::FSM_STAGES, stage_table);
   }
}
