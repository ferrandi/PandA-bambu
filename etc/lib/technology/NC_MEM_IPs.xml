<?xml version="1.0"?>
<technology>
  <library>
    <name>STD</name>
    <cell>
      <name>STD_BRAM</name>
      <attribute name="area" value_type="float64">1</attribute>
      <memory_type>SYNCHRONOUS_UNALIGNED</memory_type>
      <channels_type>MEM_ACC_11,MEM_ACC_N1</channels_type>
      <bram_load_latency>2</bram_load_latency>
      <circuit>
        <component_o id="STD_BRAM">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAM"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_BRAM S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY" IP_COMPONENT="STD_BRAM_SP" VERILOG_PROVIDED="STD_BRAM_SP #(.BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(0)) STD_BRAM_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAM_3</name>
      <attribute name="area" value_type="float64">1</attribute>
      <memory_type>SYNCHRONOUS_UNALIGNED</memory_type>
      <channels_type>MEM_ACC_11,MEM_ACC_N1</channels_type>
      <bram_load_latency>3</bram_load_latency>
      <circuit>
        <component_o id="STD_BRAM_3">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAM_3"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_BRAM_3 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY" IP_COMPONENT="STD_BRAM_SP" VERILOG_PROVIDED="STD_BRAM_SP #(.BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(1)) STD_BRAM_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAM_4</name>
      <attribute name="area" value_type="float64">1</attribute>
      <memory_type>SYNCHRONOUS_UNALIGNED</memory_type>
      <channels_type>MEM_ACC_11,MEM_ACC_N1</channels_type>
      <bram_load_latency>4</bram_load_latency>
      <circuit>
        <component_o id="STD_BRAM_4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAM_4"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_BRAM_4 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY" IP_COMPONENT="STD_BRAM_SP" VERILOG_PROVIDED="STD_BRAM_SP #(.BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(2)) STD_BRAM_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAMN</name>
      <memory_type>SYNCHRONOUS_UNALIGNED</memory_type>
      <channels_type>MEM_ACC_NN</channels_type>
      <bram_load_latency>2</bram_load_latency>
      <circuit>
        <component_o id="STD_BRAMN">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAMN"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_BRAMN S_oe_ram S_we_ram S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY" IP_COMPONENT="STD_BRAMN_SP" VERILOG_PROVIDED="STD_BRAMN_SP #(.BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(0)) STD_BRAMN_SP_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAMN_3</name>
      <memory_type>SYNCHRONOUS_UNALIGNED</memory_type>
      <channels_type>MEM_ACC_NN</channels_type>
      <bram_load_latency>3</bram_load_latency>
      <circuit>
        <component_o id="STD_BRAMN_3">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAMN_3"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_BRAMN_3 S_oe_ram S_we_ram S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY" IP_COMPONENT="STD_BRAMN_SP" VERILOG_PROVIDED="STD_BRAMN_SP #(.BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(1)) STD_BRAMN_SP_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAMN_4</name>
      <memory_type>SYNCHRONOUS_UNALIGNED</memory_type>
      <channels_type>MEM_ACC_NN</channels_type>
      <bram_load_latency>4</bram_load_latency>
      <circuit>
        <component_o id="STD_BRAMN_4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAMN_4"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_BRAMN_4 S_oe_ram S_we_ram S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY" IP_COMPONENT="STD_BRAMN_SP" VERILOG_PROVIDED="STD_BRAMN_SP #(.BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(2)) STD_BRAMN_SP_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>PROXY_CTRL</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="2"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_11</channels_type>
      <memory_ctrl_type>PROXY</memory_ctrl_type>
      <bram_load_latency>2</bram_load_latency>
      <circuit>
        <component_o id="PROXY_CTRL">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="PROXY_CTRL"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="PROXY_CTRL in1 in2 in3 out1 proxy_in1 proxy_in2 proxy_in3 proxy_out1" VERILOG_PROVIDED="
wire int_sel_LOAD;
wire int_sel_STORE;
assign int_sel_LOAD = sel_LOAD &amp; in4;
assign int_sel_STORE = sel_STORE &amp; in4;
assign out1 = proxy_out1;
assign proxy_in1 = int_sel_STORE ? in1 : 0;
assign proxy_in2 = (int_sel_LOAD|int_sel_STORE) ? in2 : 0;
assign proxy_in3 = (int_sel_LOAD|int_sel_STORE) ? in3 : 0;
assign proxy_sel_LOAD = int_sel_LOAD;
assign proxy_sel_STORE = int_sel_STORE;
" VHDL_PROVIDED="
signal int_sel_LOAD : std_logic;
signal int_sel_STORE : std_logic;
begin
  int_sel_LOAD &lt;= sel_LOAD and in4;
  int_sel_STORE &lt;= sel_STORE and in4;
  out1 &lt;= std_logic_vector(resize(unsigned(proxy_out1), BITSIZE_out1));
  proxy_in1 &lt;= std_logic_vector(resize(unsigned(in1), BITSIZE_proxy_in1)) when (int_sel_STORE /= &apos;0&apos;) else (others =&gt; &apos;0&apos;);
  proxy_in2 &lt;= in2 when ((int_sel_LOAD or int_sel_STORE) /= &apos;0&apos;) else (others =&gt; &apos;0&apos;);
  proxy_in3 &lt;= in3 when ((int_sel_LOAD or int_sel_STORE) /= &apos;0&apos;) else (others =&gt; &apos;0&apos;);
  proxy_sel_LOAD &lt;= int_sel_LOAD;
  proxy_sel_STORE &lt;= int_sel_STORE;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>PROXY_CTRL_3</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="3"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_11</channels_type>
      <memory_ctrl_type>PROXY</memory_ctrl_type>
      <bram_load_latency>3</bram_load_latency>
      <circuit>
        <component_o id="PROXY_CTRL_3">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="PROXY_CTRL_3"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="PROXY_CTRL_3 in1 in2 in3 out1 proxy_in1 proxy_in2 proxy_in3 proxy_out1" IP_COMPONENT="PROXY_CTRL" VERILOG_PROVIDED="
PROXY_CTRL #(.BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1)) PROXY_CTRL_i0 (.out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .in4(in4),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1));" VHDL_PROVIDED="begin
  PROXY_CTRL_i0 : PROXY_CTRL generic map(BITSIZE_in1=>BITSIZE_in1,
  BITSIZE_in2=>BITSIZE_in2,
  BITSIZE_in3=>BITSIZE_in3,
  BITSIZE_out1=>BITSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  BITSIZE_proxy_in2=>BITSIZE_proxy_in2,
  BITSIZE_proxy_in3=>BITSIZE_proxy_in3,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1) port map (out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2 => proxy_in2,
  proxy_in3 => proxy_in3,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2 => in2,
  in3 => in3,
  in4 => in4,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>PROXY_CTRL_4</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="4"/>
      <operation operation_name="STORE" initiation_time="1" cycles="2"/>
      <channels_type>MEM_ACC_11</channels_type>
      <memory_ctrl_type>PROXY</memory_ctrl_type>
      <bram_load_latency>4</bram_load_latency>
      <circuit>
        <component_o id="PROXY_CTRL_4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="PROXY_CTRL_4"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="PROXY_CTRL_4 in1 in2 in3 out1 proxy_in1 proxy_in2 proxy_in3 proxy_out1" 
          IP_COMPONENT="PROXY_CTRL" VERILOG_PROVIDED="
PROXY_CTRL #(
  .BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1)
) PROXY_CTRL_i0 (
  .out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .in4(in4),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1));"
  VHDL_PROVIDED="
begin
  PROXY_CTRL_i0 : PROXY_CTRL generic map(
  BITSIZE_in1=>BITSIZE_in1,
  BITSIZE_in2=>BITSIZE_in2,
  BITSIZE_in3=>BITSIZE_in3,
  BITSIZE_out1=>BITSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  BITSIZE_proxy_in2=>BITSIZE_proxy_in2,
  BITSIZE_proxy_in3=>BITSIZE_proxy_in3,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1
) port map (
  out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2 => proxy_in2,
  proxy_in3 => proxy_in3,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2 => in2,
  in3 => in3,
  in4 => in4,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>PROXY_CTRLN</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="2"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_N1,MEM_ACC_NN</channels_type>
      <memory_ctrl_type>PROXYN</memory_ctrl_type>
      <bram_load_latency>2</bram_load_latency>
      <circuit>
        <component_o id="PROXY_CTRLN">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="PROXY_CTRLN"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="PROXY_CTRLN in1 in2 in3 in4 sel_LOAD sel_STORE out1 proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1" VERILOG_PROVIDED="
wire [PORTSIZE_sel_STORE-1:0] int_sel_STORE;
wire [PORTSIZE_sel_LOAD-1:0] int_sel_LOAD;
assign int_sel_STORE = sel_STORE &amp; in4;
assign int_sel_LOAD = sel_LOAD &amp; in4;
generate
genvar i0;
for (i0=0; i0&lt;PORTSIZE_out1; i0=i0+1)
  begin : L0
    assign out1[(i0+1)*BITSIZE_out1-1:i0*BITSIZE_out1] = proxy_out1[(i0+1)*BITSIZE_proxy_out1-1:i0*BITSIZE_proxy_out1];
  end
endgenerate
generate
genvar i1;
for (i1=0; i1&lt;PORTSIZE_in1; i1=i1+1)
  begin : L1
    assign proxy_in1[(i1+1)*BITSIZE_proxy_in1-1:i1*BITSIZE_proxy_in1] = int_sel_STORE[i1] ? in1[(i1+1)*BITSIZE_in1-1:i1*BITSIZE_in1] : 0;
  end
endgenerate
generate
genvar i2;
for (i2=0; i2&lt;PORTSIZE_in2; i2=i2+1)
  begin : L2
    assign proxy_in2[(i2+1)*BITSIZE_proxy_in2-1:i2*BITSIZE_proxy_in2] = int_sel_LOAD[i2]|int_sel_STORE[i2] ? in2[(i2+1)*BITSIZE_in2-1:i2*BITSIZE_in2] : 0;
  end
endgenerate
generate
genvar i3;
for (i3=0; i3&lt;PORTSIZE_in3; i3=i3+1)
  begin : L3
    assign proxy_in3[(i3+1)*BITSIZE_proxy_in3-1:i3*BITSIZE_proxy_in3] = int_sel_LOAD[i3]|int_sel_STORE[i3] ? in3[(i3+1)*BITSIZE_in3-1:i3*BITSIZE_in3] : 0;
  end
endgenerate
assign proxy_sel_LOAD = int_sel_LOAD;
assign proxy_sel_STORE = int_sel_STORE;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>PROXY_CTRLN_3</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="3"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_N1,MEM_ACC_NN</channels_type>
      <memory_ctrl_type>PROXYN</memory_ctrl_type>
      <bram_load_latency>3</bram_load_latency>
      <circuit>
        <component_o id="PROXY_CTRLN_3">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="PROXY_CTRLN_3"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="PROXY_CTRLN_3 in1 in2 in3 in4 sel_LOAD sel_STORE out1 proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1" IP_COMPONENT="PROXY_CTRLN" VERILOG_PROVIDED="
PROXY_CTRLN #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_in4(BITSIZE_in4),
  .PORTSIZE_in4(PORTSIZE_in4),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1)) PROXY_CTRLN_i0 (.out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .in4(in4),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1));
" VHDL_PROVIDED="begin
  PROXY_CTRLN_i0 : PROXY_CTRLN generic map(BITSIZE_in1=>BITSIZE_in1,
  PORTSIZE_in1=>PORTSIZE_in1,
  BITSIZE_in2=>BITSIZE_in2,
  PORTSIZE_in2=>PORTSIZE_in2,
  BITSIZE_in3=>BITSIZE_in3,
  PORTSIZE_in3=>PORTSIZE_in3,
  BITSIZE_in4=>BITSIZE_in4,
  PORTSIZE_in4=>PORTSIZE_in4,
  BITSIZE_sel_LOAD=>BITSIZE_sel_LOAD,
  PORTSIZE_sel_LOAD=>PORTSIZE_sel_LOAD,
  BITSIZE_sel_STORE=>BITSIZE_sel_STORE,
  PORTSIZE_sel_STORE=>PORTSIZE_sel_STORE,
  BITSIZE_out1=>BITSIZE_out1,
  PORTSIZE_out1=>PORTSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  PORTSIZE_proxy_in1=>PORTSIZE_proxy_in1,
  BITSIZE_proxy_in2=>BITSIZE_proxy_in2,
  PORTSIZE_proxy_in2=>PORTSIZE_proxy_in2,
  BITSIZE_proxy_in3=>BITSIZE_proxy_in3,
  PORTSIZE_proxy_in3=>PORTSIZE_proxy_in3,
  BITSIZE_proxy_sel_LOAD=>BITSIZE_proxy_sel_LOAD,
  PORTSIZE_proxy_sel_LOAD=>PORTSIZE_proxy_sel_LOAD,
  BITSIZE_proxy_sel_STORE=>BITSIZE_proxy_sel_STORE,
  PORTSIZE_proxy_sel_STORE=>PORTSIZE_proxy_sel_STORE,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1,
  PORTSIZE_proxy_out1=>PORTSIZE_proxy_out1) port map (out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2 => proxy_in2,
  proxy_in3 => proxy_in3,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2 => in2,
  in3 => in3,
  in4 => in4,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>PROXY_CTRLN_4</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="4"/>
      <operation operation_name="STORE" initiation_time="1" cycles="2"/>
      <channels_type>MEM_ACC_N1,MEM_ACC_NN</channels_type>
      <memory_ctrl_type>PROXYN</memory_ctrl_type>
      <bram_load_latency>4</bram_load_latency>
      <circuit>
        <component_o id="PROXY_CTRLN_4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="PROXY_CTRLN_4"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="PROXY_CTRLN_4 in1 in2 in3 in4 sel_LOAD sel_STORE out1 proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1" IP_COMPONENT="PROXY_CTRLN" VERILOG_PROVIDED="
PROXY_CTRLN #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_in4(BITSIZE_in4),
  .PORTSIZE_in4(PORTSIZE_in4),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1)) PROXY_CTRLN_i0 (.out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .in4(in4),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1));
" VHDL_PROVIDED="begin
  PROXY_CTRLN_i0 : PROXY_CTRLN generic map(BITSIZE_in1=>BITSIZE_in1,
  PORTSIZE_in1=>PORTSIZE_in1,
  BITSIZE_in2=>BITSIZE_in2,
  PORTSIZE_in2=>PORTSIZE_in2,
  BITSIZE_in3=>BITSIZE_in3,
  PORTSIZE_in3=>PORTSIZE_in3,
  BITSIZE_in4=>BITSIZE_in4,
  PORTSIZE_in4=>PORTSIZE_in4,
  BITSIZE_sel_LOAD=>BITSIZE_sel_LOAD,
  PORTSIZE_sel_LOAD=>PORTSIZE_sel_LOAD,
  BITSIZE_sel_STORE=>BITSIZE_sel_STORE,
  PORTSIZE_sel_STORE=>PORTSIZE_sel_STORE,
  BITSIZE_out1=>BITSIZE_out1,
  PORTSIZE_out1=>PORTSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  PORTSIZE_proxy_in1=>PORTSIZE_proxy_in1,
  BITSIZE_proxy_in2=>BITSIZE_proxy_in2,
  PORTSIZE_proxy_in2=>PORTSIZE_proxy_in2,
  BITSIZE_proxy_in3=>BITSIZE_proxy_in3,
  PORTSIZE_proxy_in3=>PORTSIZE_proxy_in3,
  BITSIZE_proxy_sel_LOAD=>BITSIZE_proxy_sel_LOAD,
  PORTSIZE_proxy_sel_LOAD=>PORTSIZE_proxy_sel_LOAD,
  BITSIZE_proxy_sel_STORE=>BITSIZE_proxy_sel_STORE,
  PORTSIZE_proxy_sel_STORE=>PORTSIZE_proxy_sel_STORE,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1,
  PORTSIZE_proxy_out1=>PORTSIZE_proxy_out1) port map (out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2 => proxy_in2,
  proxy_in3 => proxy_in3,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2 => in2,
  in3 => in3,
  in4 => in4,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>SPROXY_CTRL</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="2"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_11</channels_type>
      <memory_ctrl_type>SPROXY</memory_ctrl_type>
      <bram_load_latency>2</bram_load_latency>
      <circuit>
        <component_o id="SPROXY_CTRL">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="SPROXY_CTRL"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2r" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2w" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3r" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3w" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in4r" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in4w" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="SPROXY_CTRL in1 in2r in2w in3r in3w out1 proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_out1" VERILOG_PROVIDED="
wire int_sel_LOAD;
wire int_sel_STORE;
assign int_sel_LOAD = sel_LOAD &amp; in4r;
assign int_sel_STORE = sel_STORE &amp; in4w;
assign out1 = proxy_out1;
assign proxy_in1 = int_sel_STORE ? in1 : 0;
assign proxy_in2r = int_sel_LOAD ? in2r : 0;
assign proxy_in2w = int_sel_STORE ? in2w : 0;
assign proxy_in3r = int_sel_LOAD ? in3r : 0;
assign proxy_in3w = int_sel_STORE ? in3w : 0;
assign proxy_in4r = int_sel_LOAD;
assign proxy_in4w = int_sel_STORE;
assign proxy_sel_LOAD = int_sel_LOAD;
assign proxy_sel_STORE = int_sel_STORE;
"
VHDL_PROVIDED="
signal int_sel_LOAD : std_logic;
signal int_sel_STORE : std_logic;
begin
  int_sel_LOAD &lt;= sel_LOAD and in4r;
  int_sel_STORE &lt;= sel_STORE and in4w;
  out1 &lt;= std_logic_vector(resize(unsigned(proxy_out1), BITSIZE_out1));
  proxy_in1 &lt;= std_logic_vector(resize(unsigned(in1), BITSIZE_proxy_in1)) when (int_sel_STORE /= &apos;0&apos;) else (others =&gt; &apos;0&apos;);
  proxy_in2r &lt;= in2r when (int_sel_LOAD /= &apos;0&apos;) else (others =&gt; &apos;0&apos;);
  proxy_in2w &lt;= in2w when (int_sel_STORE /= &apos;0&apos;) else (others =&gt; &apos;0&apos;);
  proxy_in3r &lt;= in3r when (int_sel_LOAD /= &apos;0&apos;) else (others =&gt; &apos;0&apos;);
  proxy_in3w &lt;= in3w when (int_sel_STORE /= &apos;0&apos;) else (others =&gt; &apos;0&apos;);
  proxy_in4r &lt;= int_sel_LOAD;
  proxy_in4w &lt;= int_sel_STORE;
  proxy_sel_LOAD &lt;= int_sel_LOAD;
  proxy_sel_STORE &lt;= int_sel_STORE;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>SPROXY_CTRL_3</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="3"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_11</channels_type>
      <memory_ctrl_type>SPROXY</memory_ctrl_type>
      <bram_load_latency>3</bram_load_latency>
      <circuit>
        <component_o id="SPROXY_CTRL_3">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="SPROXY_CTRL_3"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2r" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2w" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3r" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3w" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in4r" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in4w" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="SPROXY_CTRL_3 in1 in2r in2w in3r in3w out1 proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_out1" 
          IP_COMPONENT="SPROXY_CTRL" VERILOG_PROVIDED="
SPROXY_CTRL #(.BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2r(BITSIZE_in2r),
  .BITSIZE_in2w(BITSIZE_in2w),
  .BITSIZE_in3r(BITSIZE_in3r),
  .BITSIZE_in3w(BITSIZE_in3w),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2r(BITSIZE_proxy_in2r),
  .BITSIZE_proxy_in2w(BITSIZE_proxy_in2w),
  .BITSIZE_proxy_in3r(BITSIZE_proxy_in3r),
  .BITSIZE_proxy_in3w(BITSIZE_proxy_in3w),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1)
) SPROXY_CTRL_i0 (
  .out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2r(proxy_in2r),
  .proxy_in2w(proxy_in2w),
  .proxy_in3r(proxy_in3r),
  .proxy_in3w(proxy_in3w),
  .proxy_in4r(proxy_in4r),
  .proxy_in4w(proxy_in4w),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2r(in2r),
  .in2w(in2w),
  .in3r(in3r),
  .in3w(in3w),
  .in4r(in4r),
  .in4w(in4w),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1));" VHDL_PROVIDED="
begin
SPROXY_CTRL_i0 : SPROXY_CTRL generic map(
  BITSIZE_in1=>BITSIZE_in1,
  BITSIZE_in2r=>BITSIZE_in2r,
  BITSIZE_in2w=>BITSIZE_in2w,
  BITSIZE_in3r=>BITSIZE_in3r,
  BITSIZE_in3w=>BITSIZE_in3w,
  BITSIZE_out1=>BITSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  BITSIZE_proxy_in2r=>BITSIZE_proxy_in2r,
  BITSIZE_proxy_in2w=>BITSIZE_proxy_in2w,
  BITSIZE_proxy_in3r=>BITSIZE_proxy_in3r,
  BITSIZE_proxy_in3w=>BITSIZE_proxy_in3w,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1
) port map (
  out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2r => proxy_in2r,
  proxy_in2w => proxy_in2w,
  proxy_in3r => proxy_in3r,
  proxy_in3w => proxy_in3w,
  proxy_in4r => proxy_in4r,
  proxy_in4w => proxy_in4w,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2r => in2r,
  in2w => in2w,
  in3r => in3r,
  in3w => in3w,
  in4r => in4r,
  in4w => in4w,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);"
  />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>SPROXY_CTRL_4</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="4"/>
      <operation operation_name="STORE" initiation_time="1" cycles="2"/>
      <channels_type>MEM_ACC_11</channels_type>
      <memory_ctrl_type>SPROXY</memory_ctrl_type>
      <bram_load_latency>4</bram_load_latency>
      <circuit>
        <component_o id="SPROXY_CTRL_4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="SPROXY_CTRL_4"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2r" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2w" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3r" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3w" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in4r" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in4w" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="SPROXY_CTRL_4 in1 in2r in2w in3r in3w out1 proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_out1" IP_COMPONENT="SPROXY_CTRL" VERILOG_PROVIDED="
SPROXY_CTRL #(.BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2r(BITSIZE_in2r),
  .BITSIZE_in2w(BITSIZE_in2w),
  .BITSIZE_in3r(BITSIZE_in3r),
  .BITSIZE_in3w(BITSIZE_in3w),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2r(BITSIZE_proxy_in2r),
  .BITSIZE_proxy_in2w(BITSIZE_proxy_in2w),
  .BITSIZE_proxy_in3r(BITSIZE_proxy_in3r),
  .BITSIZE_proxy_in3w(BITSIZE_proxy_in3w),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1)
) SPROXY_CTRL_i0 (
  .out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2r(proxy_in2r),
  .proxy_in2w(proxy_in2w),
  .proxy_in3r(proxy_in3r),
  .proxy_in3w(proxy_in3w),
  .proxy_in4r(proxy_in4r),
  .proxy_in4w(proxy_in4w),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2r(in2r),
  .in2w(in2w),
  .in3r(in3r),
  .in3w(in3w),
  .in4r(in4r),
  .in4w(in4w),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1));" VHDL_PROVIDED="
begin
SPROXY_CTRL_i0 : SPROXY_CTRL generic map(
  BITSIZE_in1=>BITSIZE_in1,
  BITSIZE_in2r=>BITSIZE_in2r,
  BITSIZE_in2w=>BITSIZE_in2w,
  BITSIZE_in3r=>BITSIZE_in3r,
  BITSIZE_in3w=>BITSIZE_in3w,
  BITSIZE_out1=>BITSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  BITSIZE_proxy_in2r=>BITSIZE_proxy_in2r,
  BITSIZE_proxy_in2w=>BITSIZE_proxy_in2w,
  BITSIZE_proxy_in3r=>BITSIZE_proxy_in3r,
  BITSIZE_proxy_in3w=>BITSIZE_proxy_in3w,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1
) port map (
  out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2r => proxy_in2r,
  proxy_in2w => proxy_in2w,
  proxy_in3r => proxy_in3r,
  proxy_in3w => proxy_in3w,
  proxy_in4r => proxy_in4r,
  proxy_in4w => proxy_in4w,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2r => in2r,
  in2w => in2w,
  in3r => in3r,
  in3w => in3w,
  in4r => in4r,
  in4w => in4w,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>SPROXY_CTRLN</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="2"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_N1,MEM_ACC_NN</channels_type>
      <memory_ctrl_type>SPROXYN</memory_ctrl_type>
      <bram_load_latency>2</bram_load_latency>
      <circuit>
        <component_o id="SPROXY_CTRLN">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="SPROXY_CTRLN"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2r" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2w" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3r" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3w" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4r" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4w" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="SPROXY_CTRLN in1 in2r in2w in3r in3w in4r in4w sel_LOAD sel_STORE out1 proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_in4r proxy_in4w proxy_sel_LOAD proxy_sel_STORE proxy_out1" 
          VERILOG_PROVIDED="
wire [PORTSIZE_sel_LOAD-1:0] int_sel_LOAD;
wire [PORTSIZE_sel_STORE-1:0] int_sel_STORE;
assign int_sel_LOAD = sel_LOAD &amp; in4r;
assign int_sel_STORE = sel_STORE &amp; in4w;
generate
genvar i0;
for (i0=0; i0&lt;PORTSIZE_out1; i0=i0+1)
  begin : L0
    assign out1[(i0+1)*BITSIZE_out1-1:i0*BITSIZE_out1] = proxy_out1[(i0+1)*BITSIZE_proxy_out1-1:i0*BITSIZE_proxy_out1];
  end
endgenerate
generate
genvar i1;
for (i1=0; i1&lt;PORTSIZE_in1; i1=i1+1)
  begin : L1
    assign proxy_in1[(i1+1)*BITSIZE_proxy_in1-1:i1*BITSIZE_proxy_in1] = int_sel_STORE[i1] ? in1[(i1+1)*BITSIZE_in1-1:i1*BITSIZE_in1] : 0;
  end
endgenerate
generate
genvar i2r;
for (i2r=0; i2r&lt;PORTSIZE_in2r; i2r=i2r+1)
  begin : L2r
    assign proxy_in2r[(i2r+1)*BITSIZE_proxy_in2r-1:i2r*BITSIZE_proxy_in2r] = int_sel_LOAD[i2r] ? in2r[(i2r+1)*BITSIZE_in2r-1:i2r*BITSIZE_in2r] : 0;
  end
endgenerate

generate
genvar i2w;
for (i2w=0; i2w&lt;PORTSIZE_in2w; i2w=i2w+1)
  begin : L2w
    assign proxy_in2w[(i2w+1)*BITSIZE_proxy_in2w-1:i2w*BITSIZE_proxy_in2w] = int_sel_STORE[i2w] ? in2w[(i2w+1)*BITSIZE_in2w-1:i2w*BITSIZE_in2w] : 0;
  end
endgenerate

generate
genvar i3r;
for (i3r=0; i3r&lt;PORTSIZE_in3r; i3r=i3r+1)
  begin : L3r
    assign proxy_in3r[(i3r+1)*BITSIZE_proxy_in3r-1:i3r*BITSIZE_proxy_in3r] = int_sel_LOAD[i3r] ? in3r[(i3r+1)*BITSIZE_in3r-1:i3r*BITSIZE_in3r] : 0;
  end
endgenerate

generate
genvar i3w;
for (i3w=0; i3w&lt;PORTSIZE_in3w; i3w=i3w+1)
  begin : L3w
    assign proxy_in3w[(i3w+1)*BITSIZE_proxy_in3w-1:i3w*BITSIZE_proxy_in3w] = int_sel_STORE[i3w] ? in3w[(i3w+1)*BITSIZE_in3w-1:i3w*BITSIZE_in3w] : 0;
  end
endgenerate

assign proxy_in4r = int_sel_LOAD;
assign proxy_in4w = int_sel_STORE;
assign proxy_sel_LOAD = int_sel_LOAD;
assign proxy_sel_STORE = int_sel_STORE;

"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>SPROXY_CTRLN_3</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="3"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_N1,MEM_ACC_NN</channels_type>
      <memory_ctrl_type>SPROXYN</memory_ctrl_type>
      <bram_load_latency>3</bram_load_latency>
      <circuit>
        <component_o id="SPROXY_CTRLN_3">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="SPROXY_CTRLN_3"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2r" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2w" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3r" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3w" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4r" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4w" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="SPROXY_CTRLN_3 in1 in2r in2w in3r in3w in4r in4w sel_LOAD sel_STORE out1 proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_in4r proxy_in4w proxy_sel_LOAD proxy_sel_STORE proxy_out1" 
          IP_COMPONENT="SPROXY_CTRLN" VERILOG_PROVIDED="
SPROXY_CTRLN #(
  .BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2r(BITSIZE_in2r),
  .PORTSIZE_in2r(PORTSIZE_in2r),
  .BITSIZE_in2w(BITSIZE_in2w),
  .PORTSIZE_in2w(PORTSIZE_in2w),
  .BITSIZE_in3r(BITSIZE_in3r),
  .PORTSIZE_in3r(PORTSIZE_in3r),
  .BITSIZE_in3w(BITSIZE_in3w),
  .PORTSIZE_in3w(PORTSIZE_in3w),
  .BITSIZE_in4r(BITSIZE_in4r),
  .PORTSIZE_in4r(PORTSIZE_in4r),
  .BITSIZE_in4w(BITSIZE_in4w),
  .PORTSIZE_in4w(PORTSIZE_in4w),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2r(BITSIZE_proxy_in2r),
  .PORTSIZE_proxy_in2r(PORTSIZE_proxy_in2r),
  .BITSIZE_proxy_in2w(BITSIZE_proxy_in2w),
  .PORTSIZE_proxy_in2w(PORTSIZE_proxy_in2w),
  .BITSIZE_proxy_in3r(BITSIZE_proxy_in3r),
  .PORTSIZE_proxy_in3r(PORTSIZE_proxy_in3r),
  .BITSIZE_proxy_in3w(BITSIZE_proxy_in3w),
  .PORTSIZE_proxy_in3w(PORTSIZE_proxy_in3w),
  .BITSIZE_proxy_in4r(BITSIZE_proxy_in4r),
  .PORTSIZE_proxy_in4r(PORTSIZE_proxy_in4r),
  .BITSIZE_proxy_in4w(BITSIZE_proxy_in4w),
  .PORTSIZE_proxy_in4w(PORTSIZE_proxy_in4w),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1)
) SPROXY_CTRLN_i0 (
  .out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2r(proxy_in2r),
  .proxy_in2w(proxy_in2w),
  .proxy_in3r(proxy_in3r),
  .proxy_in3w(proxy_in3w),
  .proxy_in4r(proxy_in4r),
  .proxy_in4w(proxy_in4w),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2r(in2r),
  .in2w(in2w),
  .in3r(in3r),
  .in3w(in3w),
  .in4r(in4r),
  .in4w(in4w),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1)
);
" VHDL_PROVIDED="begin
  SPROXY_CTRLN_i0 : SPROXY_CTRLN generic map(BITSIZE_in1=>BITSIZE_in1,
  PORTSIZE_in1=>PORTSIZE_in1,
  BITSIZE_in2r=>BITSIZE_in2r,
  PORTSIZE_in2r=>PORTSIZE_in2r,
  BITSIZE_in2w=>BITSIZE_in2w,
  PORTSIZE_in2w=>PORTSIZE_in2w,
  BITSIZE_in3r=>BITSIZE_in3r,
  PORTSIZE_in3r=>PORTSIZE_in3r,
  BITSIZE_in3w=>BITSIZE_in3w,
  PORTSIZE_in3w=>PORTSIZE_in3w,
  BITSIZE_in4r=>BITSIZE_in4r,
  PORTSIZE_in4r=>PORTSIZE_in4r,
  BITSIZE_in4w=>BITSIZE_in4w,
  PORTSIZE_in4w=>PORTSIZE_in4w,
  BITSIZE_sel_LOAD=>BITSIZE_sel_LOAD,
  PORTSIZE_sel_LOAD=>PORTSIZE_sel_LOAD,
  BITSIZE_sel_STORE=>BITSIZE_sel_STORE,
  PORTSIZE_sel_STORE=>PORTSIZE_sel_STORE,
  BITSIZE_out1=>BITSIZE_out1,
  PORTSIZE_out1=>PORTSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  PORTSIZE_proxy_in1=>PORTSIZE_proxy_in1,
  BITSIZE_proxy_in2r=>BITSIZE_proxy_in2r,
  PORTSIZE_proxy_in2r=>PORTSIZE_proxy_in2r,
  BITSIZE_proxy_in2w=>BITSIZE_proxy_in2w,
  PORTSIZE_proxy_in2w=>PORTSIZE_proxy_in2w,
  BITSIZE_proxy_in3r=>BITSIZE_proxy_in3r,
  PORTSIZE_proxy_in3r=>PORTSIZE_proxy_in3r,
  BITSIZE_proxy_in3w=>BITSIZE_proxy_in3w,
  PORTSIZE_proxy_in3w=>PORTSIZE_proxy_in3w,
  BITSIZE_proxy_in4r=>BITSIZE_proxy_in4r,
  PORTSIZE_proxy_in4r=>PORTSIZE_proxy_in4r,
  BITSIZE_proxy_in4w=>BITSIZE_proxy_in4w,
  PORTSIZE_proxy_in4w=>PORTSIZE_proxy_in4w,
  BITSIZE_proxy_sel_LOAD=>BITSIZE_proxy_sel_LOAD,
  PORTSIZE_proxy_sel_LOAD=>PORTSIZE_proxy_sel_LOAD,
  BITSIZE_proxy_sel_STORE=>BITSIZE_proxy_sel_STORE,
  PORTSIZE_proxy_sel_STORE=>PORTSIZE_proxy_sel_STORE,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1,
  PORTSIZE_proxy_out1=>PORTSIZE_proxy_out1
) port map (
  out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2r => proxy_in2r,
  proxy_in2w => proxy_in2w,
  proxy_in3r => proxy_in3r,
  proxy_in3w => proxy_in3w,
  proxy_in4r => proxy_in4r,
  proxy_in4w => proxy_in4w,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2r => in2r,
  in2w => in2w,
  in3r => in3r,
  in3w => in3w,
  in4r => in4r,
  in4w => in4w,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);"
  />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>SPROXY_CTRLN_4</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="4"/>
      <operation operation_name="STORE" initiation_time="1" cycles="2"/>
      <channels_type>MEM_ACC_N1,MEM_ACC_NN</channels_type>
      <memory_ctrl_type>SPROXYN</memory_ctrl_type>
      <bram_load_latency>4</bram_load_latency>
      <circuit>
        <component_o id="SPROXY_CTRLN_4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="SPROXY_CTRLN_4"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2r" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2w" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3r" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3w" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4r" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4w" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="SPROXY_CTRLN_4 in1 in2r in2w in3r in3w in4r in4w sel_LOAD sel_STORE out1 proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_in4r proxy_in4w proxy_sel_LOAD proxy_sel_STORE proxy_out1" 
          IP_COMPONENT="SPROXY_CTRLN" VERILOG_PROVIDED="
SPROXY_CTRLN #(
  .BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2r(BITSIZE_in2r),
  .PORTSIZE_in2r(PORTSIZE_in2r),
  .BITSIZE_in2w(BITSIZE_in2w),
  .PORTSIZE_in2w(PORTSIZE_in2w),
  .BITSIZE_in3r(BITSIZE_in3r),
  .PORTSIZE_in3r(PORTSIZE_in3r),
  .BITSIZE_in3w(BITSIZE_in3w),
  .PORTSIZE_in3w(PORTSIZE_in3w),
  .BITSIZE_in4r(BITSIZE_in4r),
  .PORTSIZE_in4r(PORTSIZE_in4r),
  .BITSIZE_in4w(BITSIZE_in4w),
  .PORTSIZE_in4w(PORTSIZE_in4w),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2r(BITSIZE_proxy_in2r),
  .PORTSIZE_proxy_in2r(PORTSIZE_proxy_in2r),
  .BITSIZE_proxy_in2w(BITSIZE_proxy_in2w),
  .PORTSIZE_proxy_in2w(PORTSIZE_proxy_in2w),
  .BITSIZE_proxy_in3r(BITSIZE_proxy_in3r),
  .PORTSIZE_proxy_in3r(PORTSIZE_proxy_in3r),
  .BITSIZE_proxy_in3w(BITSIZE_proxy_in3w),
  .PORTSIZE_proxy_in3w(PORTSIZE_proxy_in3w),
  .BITSIZE_proxy_in4r(BITSIZE_proxy_in4r),
  .PORTSIZE_proxy_in4r(PORTSIZE_proxy_in4r),
  .BITSIZE_proxy_in4w(BITSIZE_proxy_in4w),
  .PORTSIZE_proxy_in4w(PORTSIZE_proxy_in4w),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1)
) SPROXY_CTRLN_i0 (
  .out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2r(proxy_in2r),
  .proxy_in2w(proxy_in2w),
  .proxy_in3r(proxy_in3r),
  .proxy_in3w(proxy_in3w),
  .proxy_in4r(proxy_in4r),
  .proxy_in4w(proxy_in4w),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2r(in2r),
  .in2w(in2w),
  .in3r(in3r),
  .in3w(in3w),
  .in4r(in4r),
  .in4w(in4w),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1)
);
" VHDL_PROVIDED="begin
  SPROXY_CTRLN_i0 : SPROXY_CTRLN generic map(BITSIZE_in1=>BITSIZE_in1,
  PORTSIZE_in1=>PORTSIZE_in1,
  BITSIZE_in2r=>BITSIZE_in2r,
  PORTSIZE_in2r=>PORTSIZE_in2r,
  BITSIZE_in2w=>BITSIZE_in2w,
  PORTSIZE_in2w=>PORTSIZE_in2w,
  BITSIZE_in3r=>BITSIZE_in3r,
  PORTSIZE_in3r=>PORTSIZE_in3r,
  BITSIZE_in3w=>BITSIZE_in3w,
  PORTSIZE_in3w=>PORTSIZE_in3w,
  BITSIZE_in4r=>BITSIZE_in4r,
  PORTSIZE_in4r=>PORTSIZE_in4r,
  BITSIZE_in4w=>BITSIZE_in4w,
  PORTSIZE_in4w=>PORTSIZE_in4w,
  BITSIZE_sel_LOAD=>BITSIZE_sel_LOAD,
  PORTSIZE_sel_LOAD=>PORTSIZE_sel_LOAD,
  BITSIZE_sel_STORE=>BITSIZE_sel_STORE,
  PORTSIZE_sel_STORE=>PORTSIZE_sel_STORE,
  BITSIZE_out1=>BITSIZE_out1,
  PORTSIZE_out1=>PORTSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  PORTSIZE_proxy_in1=>PORTSIZE_proxy_in1,
  BITSIZE_proxy_in2r=>BITSIZE_proxy_in2r,
  PORTSIZE_proxy_in2r=>PORTSIZE_proxy_in2r,
  BITSIZE_proxy_in2w=>BITSIZE_proxy_in2w,
  PORTSIZE_proxy_in2w=>PORTSIZE_proxy_in2w,
  BITSIZE_proxy_in3r=>BITSIZE_proxy_in3r,
  PORTSIZE_proxy_in3r=>PORTSIZE_proxy_in3r,
  BITSIZE_proxy_in3w=>BITSIZE_proxy_in3w,
  PORTSIZE_proxy_in3w=>PORTSIZE_proxy_in3w,
  BITSIZE_proxy_in4r=>BITSIZE_proxy_in4r,
  PORTSIZE_proxy_in4r=>PORTSIZE_proxy_in4r,
  BITSIZE_proxy_in4w=>BITSIZE_proxy_in4w,
  PORTSIZE_proxy_in4w=>PORTSIZE_proxy_in4w,
  BITSIZE_proxy_sel_LOAD=>BITSIZE_proxy_sel_LOAD,
  PORTSIZE_proxy_sel_LOAD=>PORTSIZE_proxy_sel_LOAD,
  BITSIZE_proxy_sel_STORE=>BITSIZE_proxy_sel_STORE,
  PORTSIZE_proxy_sel_STORE=>PORTSIZE_proxy_sel_STORE,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1,
  PORTSIZE_proxy_out1=>PORTSIZE_proxy_out1
) port map (
  out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2r => proxy_in2r,
  proxy_in2w => proxy_in2w,
  proxy_in3r => proxy_in3r,
  proxy_in3w => proxy_in3w,
  proxy_in4r => proxy_in4r,
  proxy_in4w => proxy_in4w,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2r => in2r,
  in2w => in2w,
  in3r => in3r,
  in3w => in3w,
  in4r => in4r,
  in4w => in4w,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>DPROXY_CTRL</name>
      <operation operation_name="LOAD"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_11</channels_type>
      <memory_ctrl_type>DPROXY</memory_ctrl_type>
      <circuit>
        <component_o id="DPROXY_CTRL">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="DPROXY_CTRL"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2r" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2w" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3r" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3w" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in4r" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in4w" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="DPROXY_CTRL in1 in2r in2w in3r in3w out1 proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_out1" 
          IP_COMPONENT="SPROXY_CTRL" VERILOG_PROVIDED="
SPROXY_CTRL #(.BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2r(BITSIZE_in2r),
  .BITSIZE_in2w(BITSIZE_in2w),
  .BITSIZE_in3r(BITSIZE_in3r),
  .BITSIZE_in3w(BITSIZE_in3w),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2r(BITSIZE_proxy_in2r),
  .BITSIZE_proxy_in2w(BITSIZE_proxy_in2w),
  .BITSIZE_proxy_in3r(BITSIZE_proxy_in3r),
  .BITSIZE_proxy_in3w(BITSIZE_proxy_in3w),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1)
) SPROXY_CTRL_i0 (
  .out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2r(proxy_in2r),
  .proxy_in2w(proxy_in2w),
  .proxy_in3r(proxy_in3r),
  .proxy_in3w(proxy_in3w),
  .proxy_in4r(proxy_in4r),
  .proxy_in4w(proxy_in4w),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2r(in2r),
  .in2w(in2w),
  .in3r(in3r),
  .in3w(in3w),
  .in4r(in4r),
  .in4w(in4w),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1));" VHDL_PROVIDED="
begin
SPROXY_CTRL_i0 : SPROXY_CTRL generic map(
  BITSIZE_in1=>BITSIZE_in1,
  BITSIZE_in2r=>BITSIZE_in2r,
  BITSIZE_in2w=>BITSIZE_in2w,
  BITSIZE_in3r=>BITSIZE_in3r,
  BITSIZE_in3w=>BITSIZE_in3w,
  BITSIZE_out1=>BITSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  BITSIZE_proxy_in2r=>BITSIZE_proxy_in2r,
  BITSIZE_proxy_in2w=>BITSIZE_proxy_in2w,
  BITSIZE_proxy_in3r=>BITSIZE_proxy_in3r,
  BITSIZE_proxy_in3w=>BITSIZE_proxy_in3w,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1
) port map (
  out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2r => proxy_in2r,
  proxy_in2w => proxy_in2w,
  proxy_in3r => proxy_in3r,
  proxy_in3w => proxy_in3w,
  proxy_in4r => proxy_in4r,
  proxy_in4w => proxy_in4w,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2r => in2r,
  in2w => in2w,
  in3r => in3r,
  in3w => in3w,
  in4r => in4r,
  in4w => in4w,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);"
  />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>DPROXY_CTRLN</name>
      <operation operation_name="LOAD"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_N1,MEM_ACC_NN</channels_type>
      <memory_ctrl_type>DPROXYN</memory_ctrl_type>
      <circuit>
        <component_o id="DPROXY_CTRLN">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="DPROXY_CTRLN"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2r" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2w" dir="OUT" is_addr_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3r" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3w" dir="OUT" is_size_bus="1" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4r" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4w" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="DPROXY_CTRLN in1 in2r in2w in3r in3w in4r in4w sel_LOAD sel_STORE out1 proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_in4r proxy_in4w proxy_sel_LOAD proxy_sel_STORE proxy_out1" 
          IP_COMPONENT="SPROXY_CTRLN" VERILOG_PROVIDED="
SPROXY_CTRLN #(
  .BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2r(BITSIZE_in2r),
  .PORTSIZE_in2r(PORTSIZE_in2r),
  .BITSIZE_in2w(BITSIZE_in2w),
  .PORTSIZE_in2w(PORTSIZE_in2w),
  .BITSIZE_in3r(BITSIZE_in3r),
  .PORTSIZE_in3r(PORTSIZE_in3r),
  .BITSIZE_in3w(BITSIZE_in3w),
  .PORTSIZE_in3w(PORTSIZE_in3w),
  .BITSIZE_in4r(BITSIZE_in4r),
  .PORTSIZE_in4r(PORTSIZE_in4r),
  .BITSIZE_in4w(BITSIZE_in4w),
  .PORTSIZE_in4w(PORTSIZE_in4w),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2r(BITSIZE_proxy_in2r),
  .PORTSIZE_proxy_in2r(PORTSIZE_proxy_in2r),
  .BITSIZE_proxy_in2w(BITSIZE_proxy_in2w),
  .PORTSIZE_proxy_in2w(PORTSIZE_proxy_in2w),
  .BITSIZE_proxy_in3r(BITSIZE_proxy_in3r),
  .PORTSIZE_proxy_in3r(PORTSIZE_proxy_in3r),
  .BITSIZE_proxy_in3w(BITSIZE_proxy_in3w),
  .PORTSIZE_proxy_in3w(PORTSIZE_proxy_in3w),
  .BITSIZE_proxy_in4r(BITSIZE_proxy_in4r),
  .PORTSIZE_proxy_in4r(PORTSIZE_proxy_in4r),
  .BITSIZE_proxy_in4w(BITSIZE_proxy_in4w),
  .PORTSIZE_proxy_in4w(PORTSIZE_proxy_in4w),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1)
) SPROXY_CTRLN_i0 (
  .out1(out1),
  .proxy_in1(proxy_in1),
  .proxy_in2r(proxy_in2r),
  .proxy_in2w(proxy_in2w),
  .proxy_in3r(proxy_in3r),
  .proxy_in3w(proxy_in3w),
  .proxy_in4r(proxy_in4r),
  .proxy_in4w(proxy_in4w),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .in1(in1),
  .in2r(in2r),
  .in2w(in2w),
  .in3r(in3r),
  .in3w(in3w),
  .in4r(in4r),
  .in4w(in4w),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .proxy_out1(proxy_out1)
);
" VHDL_PROVIDED="begin
  SPROXY_CTRLN_i0 : SPROXY_CTRLN generic map(BITSIZE_in1=>BITSIZE_in1,
  PORTSIZE_in1=>PORTSIZE_in1,
  BITSIZE_in2r=>BITSIZE_in2r,
  PORTSIZE_in2r=>PORTSIZE_in2r,
  BITSIZE_in2w=>BITSIZE_in2w,
  PORTSIZE_in2w=>PORTSIZE_in2w,
  BITSIZE_in3r=>BITSIZE_in3r,
  PORTSIZE_in3r=>PORTSIZE_in3r,
  BITSIZE_in3w=>BITSIZE_in3w,
  PORTSIZE_in3w=>PORTSIZE_in3w,
  BITSIZE_in4r=>BITSIZE_in4r,
  PORTSIZE_in4r=>PORTSIZE_in4r,
  BITSIZE_in4w=>BITSIZE_in4w,
  PORTSIZE_in4w=>PORTSIZE_in4w,
  BITSIZE_sel_LOAD=>BITSIZE_sel_LOAD,
  PORTSIZE_sel_LOAD=>PORTSIZE_sel_LOAD,
  BITSIZE_sel_STORE=>BITSIZE_sel_STORE,
  PORTSIZE_sel_STORE=>PORTSIZE_sel_STORE,
  BITSIZE_out1=>BITSIZE_out1,
  PORTSIZE_out1=>PORTSIZE_out1,
  BITSIZE_proxy_in1=>BITSIZE_proxy_in1,
  PORTSIZE_proxy_in1=>PORTSIZE_proxy_in1,
  BITSIZE_proxy_in2r=>BITSIZE_proxy_in2r,
  PORTSIZE_proxy_in2r=>PORTSIZE_proxy_in2r,
  BITSIZE_proxy_in2w=>BITSIZE_proxy_in2w,
  PORTSIZE_proxy_in2w=>PORTSIZE_proxy_in2w,
  BITSIZE_proxy_in3r=>BITSIZE_proxy_in3r,
  PORTSIZE_proxy_in3r=>PORTSIZE_proxy_in3r,
  BITSIZE_proxy_in3w=>BITSIZE_proxy_in3w,
  PORTSIZE_proxy_in3w=>PORTSIZE_proxy_in3w,
  BITSIZE_proxy_in4r=>BITSIZE_proxy_in4r,
  PORTSIZE_proxy_in4r=>PORTSIZE_proxy_in4r,
  BITSIZE_proxy_in4w=>BITSIZE_proxy_in4w,
  PORTSIZE_proxy_in4w=>PORTSIZE_proxy_in4w,
  BITSIZE_proxy_sel_LOAD=>BITSIZE_proxy_sel_LOAD,
  PORTSIZE_proxy_sel_LOAD=>PORTSIZE_proxy_sel_LOAD,
  BITSIZE_proxy_sel_STORE=>BITSIZE_proxy_sel_STORE,
  PORTSIZE_proxy_sel_STORE=>PORTSIZE_proxy_sel_STORE,
  BITSIZE_proxy_out1=>BITSIZE_proxy_out1,
  PORTSIZE_proxy_out1=>PORTSIZE_proxy_out1
) port map (
  out1 => out1,
  proxy_in1 => proxy_in1,
  proxy_in2r => proxy_in2r,
  proxy_in2w => proxy_in2w,
  proxy_in3r => proxy_in3r,
  proxy_in3w => proxy_in3w,
  proxy_in4r => proxy_in4r,
  proxy_in4w => proxy_in4w,
  proxy_sel_LOAD => proxy_sel_LOAD,
  proxy_sel_STORE => proxy_sel_STORE,
  in1 => in1,
  in2r => in2r,
  in2w => in2w,
  in3r => in3r,
  in3w => in3w,
  in4r => in4r,
  in4w => in4w,
  sel_LOAD => sel_LOAD,
  sel_STORE => sel_STORE,
  proxy_out1 => proxy_out1);"
/>
        </component_o>
      </circuit>
    </cell>
  </library>
  <library>
    <name>STD_COMMON</name>
    <cell>
      <name>STD_BRAM_TP</name>
      <circuit>
        <component_o id="STD_BRAM_TP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAM_TP"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_BRAM_TP S_addr_ram S_Wdata_ram Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="ARRAY_1D_STD_BRAM_TP" 
          VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_TP #(.BITSIZE_in1(1),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_out1(1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .READ_ONLY_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(1),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_proxy_out1(1)) ARRAY_1D_STD_BRAM_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1(1&apos;b0),
  .in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD(1&apos;b0),
  .sel_STORE(1&apos;b0),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(1&apos;b0),
  .proxy_in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD(1&apos;b0),
  .proxy_sel_STORE(1&apos;b0));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAM_SP</name>
      <circuit>
        <component_o id="STD_BRAM_SP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAM_SP"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_BRAM_SP S_addr_ram S_Wdata_ram Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" IP_COMPONENT="ARRAY_1D_STD_BRAM_SP" VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_SP #(.BITSIZE_in1(1),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_out1(1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .READ_ONLY_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(1),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_proxy_out1(1)) ARRAY_1D_STD_BRAM_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1(1&apos;b0),
  .in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD(1&apos;b0),
  .sel_STORE(1&apos;b0),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(1&apos;b0),
  .proxy_in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD(1&apos;b0),
  .proxy_sel_STORE(1&apos;b0));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAMN_TP</name>
      <circuit>
        <component_o id="STD_BRAMN_TP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAMN_TP"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_BRAMN_TP S_oe_ram S_we_ram S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_TP" VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_NN_TP #(.BITSIZE_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_sel_LOAD(1),
  .PORTSIZE_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_sel_STORE(1),
  .PORTSIZE_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_out1(1),
  .PORTSIZE_out1(PORTSIZE_S_addr_ram),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .READ_ONLY_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_proxy_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_proxy_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_proxy_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_proxy_sel_LOAD(1),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_sel_STORE(1),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_out1(1),
  .PORTSIZE_proxy_out1(PORTSIZE_S_addr_ram)) ARRAY_1D_STD_BRAM_NN_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .proxy_in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAMN_SP</name>
      <circuit>
        <component_o id="STD_BRAMN_SP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAMN_SP"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_BRAMN_SP S_oe_ram S_we_ram S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_SP" VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_NN_SP #(.BITSIZE_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_sel_LOAD(1),
  .PORTSIZE_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_sel_STORE(1),
  .PORTSIZE_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_out1(1),
  .PORTSIZE_out1(PORTSIZE_S_addr_ram),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .READ_ONLY_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_proxy_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_proxy_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_proxy_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_proxy_sel_LOAD(1),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_sel_STORE(1),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_out1(1),
  .PORTSIZE_proxy_out1(PORTSIZE_S_addr_ram)) ARRAY_1D_STD_BRAM_NN_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .proxy_in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ADDRESS_DECODING_LOGIC</name>
      <circuit>
        <component_o id="ADDRESS_DECODING_LOGIC">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ADDRESS_DECODING_LOGIC"/>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="n_bytes">4</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="bram_write" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ADDRESS_DECODING_LOGIC in1 in2 in3 out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_out1 dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated be nbit_read_addr n_byte_on_databus n_mem_elements n_bytes" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_addr = BITSIZE_S_addr_ram/*n_bytes ==  1 ? 1 : $clog2(n_bytes)*/;
  localparam nbits_address_space_rangesize = $clog2(address_space_rangesize);
  localparam nbits_byte_offset = n_byte_on_databus==1 ? 1 : $clog2(n_byte_on_databus);
`else
  localparam nbit_addr = BITSIZE_S_addr_ram/*n_bytes ==  1 ? 1 : log2(n_bytes)*/;
  localparam nbits_address_space_rangesize = log2(address_space_rangesize);
  localparam nbits_byte_offset = n_byte_on_databus==1 ? 1 : log2(n_byte_on_databus);
`endif


function [n_byte_on_databus*2-1:0] CONV;
  input [n_byte_on_databus*2-1:0] po2;
begin
  case (po2)
    1:CONV=(1&lt;&lt;1)-1;
    2:CONV=(1&lt;&lt;2)-1;
    4:CONV=(1&lt;&lt;4)-1;
    8:CONV=(1&lt;&lt;8)-1;
    16:CONV=(1&lt;&lt;16)-1;
    32:CONV=(1&lt;&lt;32)-1;
    default:CONV=-1;
  endcase
end
endfunction
wire [2*BRAM_BITSIZE-1:0] dout;
wire [2*BRAM_BITSIZE-1:0] out1_shifted;
wire [2*BRAM_BITSIZE-1:0] S_Wdata_ram_int;
wire cs, oe_ram_cs, we_ram_cs;
wire [n_byte_on_databus*2-1:0] conv_in;
wire [n_byte_on_databus*2-1:0] conv_out;
wire [nbits_byte_offset-1:0] byte_offset;
wire [BITSIZE_in2-1:0] tmp_addr;
wire [nbit_addr-1:0] relative_addr;

reg we_ram_cs_delayed;
reg oe_ram_cs_delayed;
reg oe_ram_cs_delayed_registered;
reg oe_ram_cs_delayed_registered1;
reg [nbits_byte_offset-1:0] delayed_byte_offset;
reg [nbits_byte_offset-1:0] delayed_byte_offset_registered;
reg [nbits_byte_offset-1:0] delayed_byte_offset_registered1;

assign tmp_addr = (proxy_sel_LOAD||proxy_sel_STORE) ? proxy_in2 : in2;

generate
genvar j0_a;
  for (j0_a=0; j0_a&lt;n_byte_on_databus; j0_a=j0_a+1)
  begin  : dout_a_computation
    assign dout[(j0_a+1)*8-1:j0_a*8] = dout_a[(j0_a+1)*8-1:j0_a*8];
  end
endgenerate

generate
genvar j0_b;
  for (j0_b=0; j0_b&lt;n_byte_on_databus; j0_b=j0_b+1)
  begin  : dout_b_computation
    assign dout[(j0_b+n_byte_on_databus+1)*8-1:(j0_b+n_byte_on_databus)*8] = dout_b[(j0_b+1)*8-1:j0_b*8];
  end
endgenerate

generate
  if(PRIVATE_MEMORY==0 &amp;&amp; USE_SPARSE_MEMORY==0)
    assign cs = (S_addr_ram &gt;= (address_space_begin)) &amp;&amp; (S_addr_ram &lt; (address_space_begin+address_space_rangesize));
  else if(PRIVATE_MEMORY==0 &amp;&amp; nbits_address_space_rangesize &lt; 32)
    assign cs = S_addr_ram[nbit_addr-1:nbits_address_space_rangesize] == address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):nbits_address_space_rangesize];
  else
    assign cs = 1&apos;b0;
endgenerate
assign oe_ram_cs = S_oe_ram &amp;&amp; cs;
assign we_ram_cs = S_we_ram &amp;&amp; cs;
generate
  if(PRIVATE_MEMORY==0 &amp;&amp; USE_SPARSE_MEMORY==0)
    assign relative_addr = (sel_STORE===1&apos;b1 || sel_LOAD===1&apos;b1 || proxy_sel_STORE===1&apos;b1 || proxy_sel_LOAD===1&apos;b1) ? tmp_addr-address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):0] : S_addr_ram-address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):0];
  else if(PRIVATE_MEMORY==0)
    assign relative_addr = (sel_STORE===1&apos;b1 || sel_LOAD===1&apos;b1 || proxy_sel_STORE===1&apos;b1 || proxy_sel_LOAD===1&apos;b1) ? tmp_addr[nbits_address_space_rangesize-1:0] : S_addr_ram[nbits_address_space_rangesize-1:0];
  else if(USE_SPARSE_MEMORY==1)
    assign relative_addr = tmp_addr[nbits_address_space_rangesize-1:0];
  else
    assign relative_addr = tmp_addr-address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):0];
endgenerate

generate
  if (n_mem_elements==1)
    assign memory_addr_a = {nbit_read_addr{1&apos;b0}};
  else if(n_byte_on_databus==1)
    assign memory_addr_a = relative_addr[nbit_read_addr-1:0];
  else
    assign memory_addr_a = relative_addr[nbit_read_addr+nbits_byte_offset-1:nbits_byte_offset];
endgenerate

generate
  if (n_bytes &lt;= BRAM_BITSIZE/8)
    assign memory_addr_b = {nbit_read_addr{1&apos;b0}};
  else if(n_byte_on_databus==1)
    assign memory_addr_b = relative_addr[nbit_read_addr-1:0] + 1&apos;b1;
  else
    assign memory_addr_b = relative_addr[nbit_read_addr+nbits_byte_offset-1:nbits_byte_offset] + 1&apos;b1;
endgenerate

generate
  if (n_byte_on_databus==1)
    assign byte_offset = {nbits_byte_offset{1&apos;b0}};
  else
    assign byte_offset = relative_addr[nbits_byte_offset-1:0];
endgenerate

generate
  if(PRIVATE_MEMORY==0)
  begin
    assign conv_in = proxy_sel_STORE ? proxy_in3[BITSIZE_proxy_in3-1:3] : (sel_STORE ? in3[BITSIZE_in3-1:3] : S_data_ram_size[BITSIZE_S_data_ram_size-1:3]);
    assign conv_out = CONV(conv_in);
    assign be = conv_out &lt;&lt; byte_offset;
  end
  else
  begin
    assign conv_in = proxy_sel_STORE ? proxy_in3[BITSIZE_proxy_in3-1:3] : in3[BITSIZE_in3-1:3];
    assign conv_out = CONV(conv_in);
    assign be = conv_out &lt;&lt; byte_offset;
  end
endgenerate

generate
  if (BITSIZE_S_Wdata_ram &lt; 2*BRAM_BITSIZE)
    assign S_Wdata_ram_int = {{2*BRAM_BITSIZE-BITSIZE_S_Wdata_ram{1&apos;b0}}, S_Wdata_ram};
  else
    assign S_Wdata_ram_int = S_Wdata_ram[2*BRAM_BITSIZE-1:0];
endgenerate

generate
  if(PRIVATE_MEMORY==0)
    assign din_value_aggregated = proxy_sel_STORE ? proxy_in1 &lt;&lt; byte_offset*8 : (sel_STORE ? in1 &lt;&lt; byte_offset*8 : S_Wdata_ram_int &lt;&lt; byte_offset*8);
  else
    assign din_value_aggregated = proxy_sel_STORE ? proxy_in1 &lt;&lt; byte_offset*8 : in1 &lt;&lt; byte_offset*8;
endgenerate

assign out1_shifted = dout &gt;&gt; delayed_byte_offset*8;
assign out1 = out1_shifted;
assign proxy_out1 = out1_shifted;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    oe_ram_cs_delayed &lt;= 1&apos;b0;
    if(HIGH_LATENCY != 0) oe_ram_cs_delayed_registered &lt;= 1&apos;b0;
    if(HIGH_LATENCY == 2) oe_ram_cs_delayed_registered1 &lt;= 1&apos;b0;
  end
  else
  begin
    if(HIGH_LATENCY == 0)
    begin
      oe_ram_cs_delayed &lt;= oe_ram_cs &amp; (!oe_ram_cs_delayed | BUS_PIPELINED);
    end
    else if(HIGH_LATENCY == 1)
    begin
      oe_ram_cs_delayed_registered &lt;= oe_ram_cs &amp; ((!oe_ram_cs_delayed_registered &amp; !oe_ram_cs_delayed) | BUS_PIPELINED);
      oe_ram_cs_delayed &lt;= oe_ram_cs_delayed_registered;
    end
    else
    begin
      oe_ram_cs_delayed_registered1 &lt;= oe_ram_cs &amp; ((!oe_ram_cs_delayed_registered1 &amp; !oe_ram_cs_delayed_registered &amp; !oe_ram_cs_delayed) | BUS_PIPELINED);
      oe_ram_cs_delayed_registered &lt;= oe_ram_cs_delayed_registered1;
      oe_ram_cs_delayed &lt;= oe_ram_cs_delayed_registered;
    end
  end
end

always @(posedge clock)
begin
  if(HIGH_LATENCY == 0)
    delayed_byte_offset &lt;= byte_offset;
  else if(HIGH_LATENCY == 1)
  begin
    delayed_byte_offset_registered &lt;= byte_offset;
    delayed_byte_offset &lt;= delayed_byte_offset_registered;
  end
  else
  begin
    delayed_byte_offset_registered1 &lt;= byte_offset;
    delayed_byte_offset_registered &lt;= delayed_byte_offset_registered1;
    delayed_byte_offset &lt;= delayed_byte_offset_registered;
  end
end

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
    we_ram_cs_delayed &lt;= 1&apos;b0;
  else
    we_ram_cs_delayed &lt;= we_ram_cs &amp; !we_ram_cs_delayed;
end

generate
  if(PRIVATE_MEMORY==1)
    assign Sout_Rdata_ram =Sin_Rdata_ram;
  else if (BITSIZE_Sout_Rdata_ram &lt;= 2*BRAM_BITSIZE)
    assign Sout_Rdata_ram = oe_ram_cs_delayed ? out1_shifted[BITSIZE_Sout_Rdata_ram-1:0] : Sin_Rdata_ram;
  else
    assign Sout_Rdata_ram = oe_ram_cs_delayed ? {{BITSIZE_Sout_Rdata_ram-2*BRAM_BITSIZE{1&apos;b0}}, out1_shifted} : Sin_Rdata_ram;
endgenerate

generate
  if(PRIVATE_MEMORY==1)
    assign Sout_DataRdy = Sin_DataRdy;
  else
    assign Sout_DataRdy = oe_ram_cs_delayed | Sin_DataRdy | we_ram_cs_delayed;
endgenerate

assign bram_write = sel_STORE || proxy_sel_STORE || we_ram_cs;

// Add assertion here
// psl default clock = (posedge clock);
// psl ERROR_S_data_ram_size: assert never {S_data_ram_size&gt;2*BRAM_BITSIZE &amp;&amp; (we_ram_cs || oe_ram_cs)};
// psl ERROR_memory_addr: assert never {memory_addr_a&gt;=n_mem_elements &amp;&amp; (we_ram_cs || oe_ram_cs || sel_STORE || sel_LOAD || proxy_sel_STORE || proxy_sel_LOAD)};
// psl ERROR_relative_addr: assert never {relative_addr+(S_data_ram_size/8) &gt;n_bytes &amp;&amp; (we_ram_cs || oe_ram_cs)};
// psl ERROR_unaligned_access: assert never {byte_offset+S_data_ram_size[BITSIZE_S_data_ram_size-1:3] &gt; BRAM_BITSIZE/4 &amp;&amp; (we_ram_cs || oe_ram_cs)};
// psl ERROR_oe_ram_cs_we_ram_cs: assert never {(we_ram_cs &amp; oe_ram_cs) != 0};
// psl ERROR_LOAD_S_oe_ram: assert never {sel_LOAD &amp;&amp; oe_ram_cs};
// psl ERROR_proxy_LOAD_S_oe_ram: assert never {proxy_sel_LOAD &amp;&amp; oe_ram_cs};
// psl ERROR_STORE_S_we_ram: assert never {sel_STORE &amp;&amp; we_ram_cs};
// psl ERROR_proxy_STORE_S_we_ram: assert never {proxy_sel_STORE &amp;&amp; we_ram_cs};
// psl ERROR_LOAD_we_ram_cs: assert never {sel_LOAD &amp;&amp; we_ram_cs};
// psl ERROR_proxy_LOAD_we_ram_cs: assert never {proxy_sel_LOAD &amp;&amp; we_ram_cs};
// psl ERROR_STORE_oe_ram_cs: assert never {sel_STORE &amp;&amp; oe_ram_cs};
// psl ERROR_proxy_STORE_oe_ram_cs: assert never {proxy_sel_STORE &amp;&amp; oe_ram_cs};
// psl ERROR_Sin_DataRdy_oe_ram_cs_delayed: assert never {Sin_DataRdy &amp;&amp; oe_ram_cs_delayed};
// psl ERROR_in3_size: assert never {in3&gt;2*BRAM_BITSIZE &amp;&amp; (sel_STORE || sel_LOAD)};
// psl ERROR_proxy_in3_size: assert never {proxy_in3&gt;2*BRAM_BITSIZE &amp;&amp; (proxy_sel_STORE || proxy_sel_LOAD)};
// psl ERROR_requested_size: assert never {BITSIZE_out1&lt;in3 &amp;&amp; (sel_LOAD)};
// psl ERROR_proxy_requested_size: assert never {BITSIZE_proxy_out1&lt;proxy_in3 &amp;&amp; (proxy_sel_LOAD)};
// psl ERROR_STORE_LOAD: assert never {sel_STORE &amp;&amp; sel_LOAD};
// psl ERROR_proxy_STORE_proxy_LOAD: assert never {proxy_sel_STORE &amp;&amp; proxy_sel_LOAD};"
            VHDL_PROVIDED="function integer_ternary_operator(cond : boolean; op1 : integer; op2 : integer) return integer is
   begin
      if cond then
         return op1;
      else
         return op2;
      end if;
   end integer_ternary_operator;

function CONV(po2 : std_logic_vector(2*n_byte_on_databus-1 downto 0)) return std_logic_vector is
  variable int_po2 : integer;
  begin
      int_po2 := to_integer(unsigned(po2));
      case int_po2 is
         when 1 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,2*n_byte_on_databus),1) -1);
         when 2 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,2*n_byte_on_databus),2) -1);
         when 4 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,2*n_byte_on_databus),4) -1);
         when 8 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,2*n_byte_on_databus),8) -1);
         when 16 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,2*n_byte_on_databus),16) -1);
         when 32 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,2*n_byte_on_databus),32) -1);
         when others =&gt;
            return std_logic_vector(to_signed(-1,2*n_byte_on_databus));
      end case;
   end CONV;

   constant nbit_addr                     : integer := BITSIZE_S_addr_ram;
   constant nbits_address_space_rangesize : integer := integer(ceil(log2(real(address_space_rangesize))));
   constant nbits_byte_offset             : integer := integer_ternary_operator(n_byte_on_databus = 1, 1, integer(ceil(log2(real(n_byte_on_databus)))));
   constant memory_bitsize                : integer := 2 * BRAM_BITSIZE;
   constant address_space_begin_u         : unsigned(nbit_addr-1 downto 0) := to_unsigned(address_space_begin, nbit_addr);

   signal tmp_addr                       : std_logic_vector(BITSIZE_in2-1 downto 0);
   signal conv_in                        : std_logic_vector(n_byte_on_databus*2-1 downto 0);
   signal conv_out                       : std_logic_vector(n_byte_on_databus*2-1 downto 0);
   signal cs                             : std_logic;
   signal oe_ram_cs                      : std_logic;
   signal we_ram_cs                      : std_logic;
   signal relative_addr                  : std_logic_vector(nbit_addr-1 downto 0);
   signal S_Wdata_ram_int                : std_logic_vector(2*BRAM_BITSIZE-1 downto 0);
   signal out1_shifted                   : std_logic_vector(2*BRAM_BITSIZE-1 downto 0);
   signal dout                           : std_logic_vector(2*BRAM_BITSIZE-1 downto 0);
   signal byte_offset                    : std_logic_vector(nbits_byte_offset-1 downto 0);

   signal we_ram_cs_delayed              : std_logic;
   signal oe_ram_cs_delayed              : std_logic;
   signal oe_ram_cs_delayed_registered   : std_logic;
   signal oe_ram_cs_delayed_registered1  : std_logic;
   signal delayed_byte_offset            : std_logic_vector(nbits_byte_offset-1 downto 0);
   signal delayed_byte_offset_registered : std_logic_vector(nbits_byte_offset-1 downto 0);
   signal delayed_byte_offset_registered1 : std_logic_vector(nbits_byte_offset-1 downto 0);
begin
   tmp_addr &lt;= std_logic_vector(resize(unsigned(proxy_in2), BITSIZE_in2)) when ((proxy_sel_LOAD or proxy_sel_STORE) = &apos;1&apos;) else in2;

   dout(BRAM_BITSIZE-1 downto 0) &lt;= dout_a;
   dout(2*BRAM_BITSIZE-1 downto BRAM_BITSIZE) &lt;= dout_b;

   L3 : process(S_addr_ram)
   begin
      if(PRIVATE_MEMORY = 0 and USE_SPARSE_MEMORY = 0) then
         if(to_integer(unsigned(S_addr_ram)) &gt;= (address_space_begin)) and (to_integer(unsigned(S_addr_ram)) &lt; (address_space_begin+address_space_rangesize)) then
            cs &lt;= &apos;1&apos;;
         else
            cs &lt;= &apos;0&apos;;
         end if;
      else
         if(PRIVATE_MEMORY=0) then
            if S_addr_ram(nbit_addr-1 downto nbits_address_space_rangesize) = std_logic_vector(address_space_begin_u(nbit_addr-1 downto nbits_address_space_rangesize)) then
               cs &lt;= &apos;1&apos;;
            else
               cs &lt;= &apos;0&apos;;
            end if;
         else
            cs &lt;= &apos;0&apos;;
         end if;
      end if;
   end process;

   oe_ram_cs &lt;= S_oe_ram and cs;
   we_ram_cs &lt;= S_we_ram and cs;

   L6 : process(sel_STORE, proxy_sel_STORE, sel_LOAD, proxy_sel_LOAD, tmp_addr, S_addr_ram)
   begin
      if(PRIVATE_MEMORY=0 and USE_SPARSE_MEMORY=0) then
         if(sel_STORE = &apos;1&apos; or sel_LOAD = &apos;1&apos; or proxy_sel_STORE = &apos;1&apos; or proxy_sel_LOAD = &apos;1&apos;) then
            relative_addr &lt;= std_logic_vector(unsigned(tmp_addr)-(to_unsigned(address_space_begin, nbit_addr)));
         else
            relative_addr &lt;= std_logic_vector(unsigned(S_addr_ram) - (to_unsigned(address_space_begin, nbit_addr)));
         end if;
      else
         if(PRIVATE_MEMORY=0) then
            if(sel_STORE = &apos;1&apos; or sel_LOAD = &apos;1&apos; or proxy_sel_STORE = &apos;1&apos; or proxy_sel_LOAD = &apos;1&apos;) then
               relative_addr &lt;= std_logic_vector(resize(unsigned(tmp_addr(nbits_address_space_rangesize-1 downto 0)), nbit_addr));
            else
               relative_addr &lt;= std_logic_vector(resize(unsigned(S_addr_ram(nbits_address_space_rangesize-1 downto 0)), nbit_addr));
            end if;
         else
            if(USE_SPARSE_MEMORY=1) then
               relative_addr &lt;= std_logic_vector(resize(unsigned(tmp_addr(nbits_address_space_rangesize-1 downto 0)), nbit_addr));
            else
               relative_addr &lt;= std_logic_vector(unsigned(tmp_addr) - to_unsigned(address_space_begin, nbit_addr));
            end if;
         end if;
      end if;
   end process;

   L7_A : process(relative_addr)
   begin
      if (n_mem_elements=1) then
         memory_addr_a &lt;= (others =&gt; &apos;0&apos;);
      elsif (n_byte_on_databus=1) then
         memory_addr_a &lt;= relative_addr(nbit_read_addr-1 downto 0);
      else
         memory_addr_a &lt;= relative_addr(nbit_read_addr+nbits_byte_offset-1 downto nbits_byte_offset);
      end if;
   end process;

   L7_B : process(relative_addr)
   begin
      if (n_bytes &lt;= BRAM_BITSIZE/8) then
         memory_addr_b &lt;= (others =&gt; &apos;0&apos;);
      elsif (n_byte_on_databus=1) then
         memory_addr_b &lt;= std_logic_vector(unsigned(relative_addr(nbit_read_addr-1 downto 0)) + to_unsigned(1,nbit_read_addr));
      else
         memory_addr_b &lt;= std_logic_vector(unsigned(relative_addr(nbit_read_addr+nbits_byte_offset-1 downto nbits_byte_offset)) + to_unsigned(1,nbit_read_addr));
      end if;
   end process;

   L8 : process(relative_addr)
   begin
      if (n_byte_on_databus=1) then
         byte_offset &lt;= (others =&gt; &apos;0&apos;);
      else
         byte_offset &lt;= relative_addr(nbits_byte_offset-1 downto 0);
      end if;
   end process;

   be_conv_in : process(proxy_sel_STORE, proxy_in3, sel_STORE, in3, S_data_ram_size)
   begin
      if(PRIVATE_MEMORY=0) then
         if(proxy_sel_STORE /= &apos;0&apos;) then
            conv_in &lt;= std_logic_vector(resize(unsigned(proxy_in3(BITSIZE_proxy_in3-1 downto 3)), 2*n_byte_on_databus));
         else
            if(sel_STORE /= &apos;0&apos;) then
               conv_in &lt;= std_logic_vector(resize(unsigned(in3(BITSIZE_in3-1 downto 3)), 2*n_byte_on_databus));
            else
               conv_in &lt;= std_logic_vector(resize(unsigned(S_data_ram_size(BITSIZE_S_data_ram_size-1 downto 3)), 2*n_byte_on_databus));
            end if;
         end if;
      else
         if(proxy_sel_STORE /= &apos;0&apos;) then
            conv_in &lt;= std_logic_vector(resize(unsigned(proxy_in3(BITSIZE_proxy_in3-1 downto 3)), 2*n_byte_on_databus));
         else
            conv_in &lt;= std_logic_vector(resize(unsigned(in3(BITSIZE_in3-1 downto 3)), 2*n_byte_on_databus));
         end if;
      end  if;
   end process;

   conv_out &lt;= CONV(conv_in);
   be &lt;= std_logic_vector(shift_left(unsigned(conv_out), to_integer(unsigned(byte_offset))));


   L13 : process(S_Wdata_ram)
   begin
      if (BITSIZE_S_Wdata_ram &lt; 2*BRAM_BITSIZE) then
         S_Wdata_ram_int(2*BRAM_BITSIZE-1 downto BITSIZE_S_Wdata_ram) &lt;= (others =&gt; &apos;0&apos;);
         S_Wdata_ram_int(BITSIZE_S_Wdata_ram-1 downto 0) &lt;= S_Wdata_ram(BITSIZE_S_Wdata_ram-1 downto 0);
      else
         S_Wdata_ram_int &lt;= S_Wdata_ram(2*BRAM_BITSIZE-1 downto 0);
      end if;
   end process;

   L14 : process(proxy_sel_STORE, proxy_in1, byte_offset, sel_STORE, in1, S_Wdata_ram_int)
   begin
      if(PRIVATE_MEMORY=0) then
         if(proxy_sel_STORE /= &apos;0&apos;) then
            din_value_aggregated &lt;= std_logic_vector(shift_left(resize(unsigned(proxy_in1(BITSIZE_proxy_in1-1 downto 0)), 2*BRAM_BITSIZE), to_integer(unsigned(byte_offset(nbits_byte_offset-1 downto 0)))*8));
         else
            if(sel_STORE /= &apos;0&apos;) then
               din_value_aggregated &lt;= std_logic_vector(shift_left(resize(unsigned((in1(BITSIZE_in1-1 downto 0))), 2*BRAM_BITSIZE), to_integer(unsigned(byte_offset(nbits_byte_offset-1 downto 0)))*8));
            else
               din_value_aggregated &lt;= std_logic_vector(shift_left(resize(unsigned(S_Wdata_ram_int), 2*BRAM_BITSIZE), to_integer(unsigned(byte_offset(nbits_byte_offset-1 downto 0)))*8));
            end if;
         end if;
      else
         if(proxy_sel_STORE /= &apos;0&apos;) then
            din_value_aggregated &lt;= std_logic_vector(shift_left(resize(unsigned(proxy_in1(BITSIZE_proxy_in1-1 downto 0)), 2*BRAM_BITSIZE), to_integer(unsigned(byte_offset(nbits_byte_offset-1 downto 0)))*8));
         else
            din_value_aggregated &lt;= std_logic_vector(shift_left(resize(unsigned(in1(BITSIZE_in1-1 downto 0)), 2*BRAM_BITSIZE), to_integer(unsigned(byte_offset(nbits_byte_offset-1 downto 0)))*8));
         end if;
      end if;
   end process;


   out1_shifted &lt;= std_logic_vector(shift_right(unsigned(dout), to_integer(unsigned(delayed_byte_offset(nbits_byte_offset-1 downto 0)))*8));

   out1 &lt;= std_logic_vector(resize(unsigned(out1_shifted(2*BRAM_BITSIZE-1 downto 0)), BITSIZE_out1));
   proxy_out1 &lt;= std_logic_vector(resize(unsigned(out1_shifted(2*BRAM_BITSIZE-1 downto 0)), BITSIZE_proxy_out1));

   L16 : process(reset, clock)
   begin
      if(1RESET_VALUE) then
         oe_ram_cs_delayed &lt;= &apos;0&apos;;
         if(HIGH_LATENCY /= 0) then
            oe_ram_cs_delayed_registered &lt;= &apos;0&apos;;
         end if;
         if(HIGH_LATENCY = 2) then
            oe_ram_cs_delayed_registered1 &lt;= &apos;0&apos;;
         end if;
      else
         if (clock&apos;event and clock = &apos;1&apos;) then
            if(HIGH_LATENCY = 0) then
               if(BUS_PIPELINED /= 0) then
                  oe_ram_cs_delayed &lt;= oe_ram_cs;
               else
                  oe_ram_cs_delayed &lt;= oe_ram_cs and (not oe_ram_cs_delayed);
               end if;
            elsif(HIGH_LATENCY = 1) then
               if(BUS_PIPELINED /= 0) then
                  oe_ram_cs_delayed_registered &lt;= oe_ram_cs;
               else
                  oe_ram_cs_delayed_registered &lt;= oe_ram_cs and ((not oe_ram_cs_delayed_registered and not oe_ram_cs_delayed));
               end if;
               oe_ram_cs_delayed &lt;= oe_ram_cs_delayed_registered;
            else
               if(BUS_PIPELINED /= 0) then
                  oe_ram_cs_delayed_registered1 &lt;= oe_ram_cs;
               else
                  oe_ram_cs_delayed_registered1 &lt;= oe_ram_cs and ((not oe_ram_cs_delayed_registered1 and not oe_ram_cs_delayed_registered and not oe_ram_cs_delayed));
               end if;
               oe_ram_cs_delayed_registered &lt;= oe_ram_cs_delayed_registered1;
               oe_ram_cs_delayed &lt;= oe_ram_cs_delayed_registered;
            end if;
         end if;
      end if;
   end process;

   process(clock)
   begin
      if (clock&apos;event and clock=&apos;1&apos;) then
         if(HIGH_LATENCY = 0) then
            delayed_byte_offset &lt;= byte_offset;
         elsif(HIGH_LATENCY = 1) then
            delayed_byte_offset_registered &lt;= byte_offset;
            delayed_byte_offset &lt;= delayed_byte_offset_registered;
         else
            delayed_byte_offset_registered1 &lt;= byte_offset;
            delayed_byte_offset_registered &lt;= delayed_byte_offset_registered1;
            delayed_byte_offset &lt;= delayed_byte_offset_registered;
         end if;
      end if;
   end process;

   process(clock, reset)
   begin
      if(1RESET_VALUE) then
         we_ram_cs_delayed &lt;= &apos;0&apos;;
      else
         if (clock&apos;event and clock = &apos;1&apos;) then
            we_ram_cs_delayed &lt;= we_ram_cs and not we_ram_cs_delayed;
         end if;
      end if;
   end process;

   L18 : process(Sin_Rdata_ram, out1_shifted, oe_ram_cs_delayed)
   begin
      if(PRIVATE_MEMORY=1) then
         Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram-1 downto 0) &lt;= Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram-1 downto 0);
      else
         if (BITSIZE_Sout_Rdata_ram &lt;= 2*BRAM_BITSIZE) then
            if(oe_ram_cs_delayed /= &apos;0&apos;) then
               Sout_Rdata_ram &lt;= out1_shifted(BITSIZE_Sout_Rdata_ram-1 downto 0);
            else
               Sout_Rdata_ram &lt;= Sin_Rdata_ram;
            end if;
         else
            if(oe_ram_cs_delayed /= &apos;0&apos;) then
               Sout_Rdata_ram &lt;= std_logic_vector(resize(unsigned(out1_shifted), BITSIZE_Sout_Rdata_ram));
            else
               Sout_Rdata_ram &lt;= Sin_Rdata_ram;
            end if;
         end if;
      end if;
   end process;

   L19 : process(oe_ram_cs_delayed, Sin_DataRdy, we_ram_cs_delayed)
   begin
      if(PRIVATE_MEMORY=0) then
         Sout_DataRdy &lt;= oe_ram_cs_delayed or Sin_DataRdy or we_ram_cs_delayed;
      else
         Sout_DataRdy &lt;= Sin_DataRdy;
      end if;
   end process;
   
   bram_write &lt;= sel_STORE or proxy_sel_STORE or we_ram_cs;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ADDRESS_DECODING_LOGIC_NN</name>
      <circuit>
        <component_o id="ADDRESS_DECODING_LOGIC_NN">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ADDRESS_DECODING_LOGIC_NN"/>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="max_n_reads">2</parameter>
          <parameter name="max_n_writes">2</parameter>
          <parameter name="max_n_rw">2</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="memory_addr_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="memory_addr_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value_aggregated_swapped" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="be_swapped" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="bram_write" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ADDRESS_DECODING_LOGIC_NN in1 in2 in3 sel_LOAD sel_STORE out1 S_oe_ram S_we_ram Sin_DataRdy Sout_DataRdy S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1 dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated_swapped be_swapped bram_write nbit_read_addr n_byte_on_databus n_mem_elements max_n_reads max_n_writes max_n_rw" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_addr = BITSIZE_S_addr_ram/*n_bytes ==  1 ? 1 : $clog2(n_bytes)*/;
  localparam nbits_byte_offset = n_byte_on_databus==1 ? 1 : $clog2(n_byte_on_databus);
  localparam nbits_address_space_rangesize = $clog2(address_space_rangesize);
`else
  localparam nbit_addr = BITSIZE_S_addr_ram/*n_bytes ==  1 ? 1 : log2(n_bytes)*/;
  localparam nbits_address_space_rangesize = log2(address_space_rangesize);
  localparam nbits_byte_offset = n_byte_on_databus==1 ? 1 : log2(n_byte_on_databus);
`endif
 localparam memory_bitsize = 2*BRAM_BITSIZE;

function [n_byte_on_databus*max_n_writes-1:0] CONV;
  input [n_byte_on_databus*max_n_writes-1:0] po2;
begin
  case (po2)
    1:CONV=(1&lt;&lt;1)-1;
    2:CONV=(1&lt;&lt;2)-1;
    4:CONV=(1&lt;&lt;4)-1;
    8:CONV=(1&lt;&lt;8)-1;
    16:CONV=(1&lt;&lt;16)-1;
    32:CONV=(1&lt;&lt;32)-1;
    default:CONV=-1;
  endcase
end
endfunction

wire [(PORTSIZE_in2*BITSIZE_in2)+(-1):0] tmp_addr;
wire [n_byte_on_databus*max_n_writes-1:0] conv_in;
wire [n_byte_on_databus*max_n_writes-1:0] conv_out;
wire [PORTSIZE_S_addr_ram-1:0] cs;
wire [PORTSIZE_S_oe_ram-1:0] oe_ram_cs;
wire [PORTSIZE_S_we_ram-1:0] we_ram_cs;
wire [nbit_addr*max_n_rw-1:0] relative_addr;
wire [memory_bitsize*max_n_writes-1:0] din_value_aggregated;
wire [memory_bitsize*PORTSIZE_S_Wdata_ram-1:0] S_Wdata_ram_int;
wire [memory_bitsize*max_n_reads-1:0] out1_shifted;
wire [memory_bitsize*max_n_reads-1:0] dout;
wire [nbits_byte_offset*max_n_rw-1:0] byte_offset;
wire [n_byte_on_databus*max_n_writes-1:0] be;

reg [PORTSIZE_S_we_ram-1:0] we_ram_cs_delayed;
reg [PORTSIZE_S_oe_ram-1:0] oe_ram_cs_delayed;
reg [PORTSIZE_S_oe_ram-1:0] oe_ram_cs_delayed_registered;
reg [PORTSIZE_S_oe_ram-1:0] oe_ram_cs_delayed_registered1;
reg [max_n_reads-1:0] delayed_swapped_bit;
reg [max_n_reads-1:0] delayed_swapped_bit_registered;
reg [max_n_reads-1:0] delayed_swapped_bit_registered1;
reg [nbits_byte_offset*max_n_reads-1:0] delayed_byte_offset;
reg [nbits_byte_offset*max_n_reads-1:0] delayed_byte_offset_registered;
reg [nbits_byte_offset*max_n_reads-1:0] delayed_byte_offset_registered1;

generate
genvar ind2;
for (ind2=0; ind2&lt;PORTSIZE_in2; ind2=ind2+1)
  begin : Lind2
    assign tmp_addr[(ind2+1)*BITSIZE_in2-1:ind2*BITSIZE_in2] = (proxy_sel_LOAD[ind2]||proxy_sel_STORE[ind2]) ? proxy_in2[(ind2+1)*BITSIZE_proxy_in2-1:ind2*BITSIZE_proxy_in2] : in2[(ind2+1)*BITSIZE_in2-1:ind2*BITSIZE_in2];
  end
endgenerate

generate
genvar i2;
  for (i2=0;i2&lt;max_n_reads;i2=i2+1)
  begin : L_copy
      assign dout[(memory_bitsize/2)+memory_bitsize*i2-1:memory_bitsize*i2] = delayed_swapped_bit[i2] ? dout_a[(memory_bitsize/2)*(i2+1)-1:(memory_bitsize/2)*i2] : dout_b[(memory_bitsize/2)*(i2+1)-1:(memory_bitsize/2)*i2];
      assign dout[memory_bitsize*(i2+1)-1:memory_bitsize*i2+(memory_bitsize/2)] = delayed_swapped_bit[i2] ? dout_b[(memory_bitsize/2)*(i2+1)-1:(memory_bitsize/2)*i2] : dout_a[(memory_bitsize/2)*(i2+1)-1:(memory_bitsize/2)*i2];
      always @(posedge clock)
      begin
        if(HIGH_LATENCY == 0)
          delayed_swapped_bit[i2] &lt;= !relative_addr[nbits_byte_offset+i2*nbit_addr-1];
        else if(HIGH_LATENCY == 1)
        begin
          delayed_swapped_bit_registered[i2] &lt;= !relative_addr[nbits_byte_offset+i2*nbit_addr-1];
          delayed_swapped_bit[i2] &lt;= delayed_swapped_bit_registered[i2];
        end
        else
        begin
          delayed_swapped_bit_registered1[i2] &lt;= !relative_addr[nbits_byte_offset+i2*nbit_addr-1];
          delayed_swapped_bit_registered[i2] &lt;= delayed_swapped_bit_registered1[i2];
          delayed_swapped_bit[i2] &lt;= delayed_swapped_bit_registered[i2];
        end
      end
  end
endgenerate

generate
genvar i3;
  for (i3=0; i3&lt;PORTSIZE_S_addr_ram; i3=i3+1)
  begin : L3
    if(PRIVATE_MEMORY==0 &amp;&amp; USE_SPARSE_MEMORY==0)
      assign cs[i3] = (S_addr_ram[(i3+1)*BITSIZE_S_addr_ram-1:i3*BITSIZE_S_addr_ram] &gt;= (address_space_begin)) &amp;&amp; (S_addr_ram[(i3+1)*BITSIZE_S_addr_ram-1:i3*BITSIZE_S_addr_ram] &lt; (address_space_begin+address_space_rangesize));
    else if(PRIVATE_MEMORY==0 &amp;&amp; nbits_address_space_rangesize &lt; 32)
      assign cs[i3] = S_addr_ram[(i3+1)*BITSIZE_S_addr_ram-1:i3*BITSIZE_S_addr_ram+nbits_address_space_rangesize] == address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):nbits_address_space_rangesize];
    else
      assign cs[i3] = 1&apos;b0;
  end
endgenerate

generate
genvar i4;
  for (i4=0; i4&lt;PORTSIZE_S_oe_ram; i4=i4+1)
  begin : L4
    assign oe_ram_cs[i4] = S_oe_ram[i4] &amp; cs[i4];
  end
endgenerate

generate
genvar i5;
  for (i5=0; i5&lt;PORTSIZE_S_we_ram; i5=i5+1)
  begin : L5
    assign we_ram_cs[i5] = S_we_ram[i5] &amp; cs[i5];
  end
endgenerate

generate
genvar i6;
  for (i6=0; i6&lt;max_n_rw; i6=i6+1)
  begin : L6
    if(PRIVATE_MEMORY==0 &amp;&amp; USE_SPARSE_MEMORY==0 &amp;&amp; i6&lt; PORTSIZE_S_addr_ram)
      assign relative_addr[(i6+1)*nbit_addr-1:i6*nbit_addr] = ((i6 &lt; max_n_writes &amp;&amp; (sel_STORE[i6]==1&apos;b1 || proxy_sel_STORE[i6]==1&apos;b1)) || (i6 &lt; max_n_reads &amp;&amp; (sel_LOAD[i6]==1&apos;b1 || proxy_sel_LOAD[i6]==1&apos;b1))) ? tmp_addr[(i6+1)*BITSIZE_in2-1:i6*BITSIZE_in2]-address_space_begin: S_addr_ram[(i6+1)*BITSIZE_S_addr_ram-1:i6*BITSIZE_S_addr_ram]-address_space_begin;
    else if(PRIVATE_MEMORY==0 &amp;&amp; i6&lt; PORTSIZE_S_addr_ram)
      assign relative_addr[(i6)*nbit_addr+nbits_address_space_rangesize-1:i6*nbit_addr] = ((i6 &lt; max_n_writes &amp;&amp; (sel_STORE[i6]==1&apos;b1 || proxy_sel_STORE[i6]==1&apos;b1)) || (i6 &lt; max_n_reads &amp;&amp; (sel_LOAD[i6]==1&apos;b1 || proxy_sel_LOAD[i6]==1&apos;b1))) ? tmp_addr[(i6)*BITSIZE_in2+nbits_address_space_rangesize-1:i6*BITSIZE_in2] : S_addr_ram[(i6)*BITSIZE_S_addr_ram+nbits_address_space_rangesize-1:i6*BITSIZE_S_addr_ram];
    else if(USE_SPARSE_MEMORY==1)
      assign relative_addr[(i6)*nbit_addr+nbits_address_space_rangesize-1:i6*nbit_addr] = tmp_addr[(i6)*BITSIZE_in2+nbits_address_space_rangesize-1:i6*BITSIZE_in2];
    else
      assign relative_addr[(i6+1)*nbit_addr-1:i6*nbit_addr] = tmp_addr[(i6+1)*BITSIZE_in2-1:i6*BITSIZE_in2]-address_space_begin;
  end
endgenerate

generate
genvar i7;
  for (i7=0; i7&lt;max_n_rw; i7=i7+1)
  begin : L7_A
    if (n_mem_elements==1)
      assign memory_addr_a[(i7+1)*nbit_read_addr-1:i7*nbit_read_addr] = {nbit_read_addr{1&apos;b0}};
    else
      assign memory_addr_a[(i7+1)*nbit_read_addr-1:i7*nbit_read_addr] = !relative_addr[nbits_byte_offset+i7*nbit_addr-1] ? relative_addr[nbit_read_addr+nbits_byte_offset-1+i7*nbit_addr:nbits_byte_offset+i7*nbit_addr] : (relative_addr[nbit_read_addr+nbits_byte_offset-1+i7*nbit_addr:nbits_byte_offset+i7*nbit_addr-1]+ 1&apos;b1) &gt;&gt; 1;
  end
endgenerate

generate
  for (i7=0; i7&lt;max_n_rw; i7=i7+1)
  begin : L7_B
    if (n_mem_elements==1)
      assign memory_addr_b[(i7+1)*nbit_read_addr-1:i7*nbit_read_addr] = {nbit_read_addr{1&apos;b0}};
    else
      assign memory_addr_b[(i7+1)*nbit_read_addr-1:i7*nbit_read_addr] = !relative_addr[nbits_byte_offset+i7*nbit_addr-1] ? (relative_addr[nbit_read_addr+nbits_byte_offset-1+i7*nbit_addr:nbits_byte_offset+i7*nbit_addr-1] + 1&apos;b1) &gt;&gt; 1 : relative_addr[nbit_read_addr+nbits_byte_offset-1+i7*nbit_addr:nbits_byte_offset+i7*nbit_addr];
  end
endgenerate

generate
genvar i8;
  for (i8=0; i8&lt;max_n_rw; i8=i8+1)
  begin : L8
    if (n_byte_on_databus==2)
      assign byte_offset[(i8+1)*nbits_byte_offset-1:i8*nbits_byte_offset] = {nbits_byte_offset{1&apos;b0}};
    else
      assign byte_offset[(i8+1)*nbits_byte_offset-1:i8*nbits_byte_offset] = {1&apos;b0, relative_addr[nbits_byte_offset+i8*nbit_addr-2:i8*nbit_addr]};
  end
endgenerate

generate
genvar i9, i10;
  for (i9=0; i9&lt;max_n_writes; i9=i9+1)
  begin : byte_enable
    if(PRIVATE_MEMORY==0 &amp;&amp; i9 &lt; PORTSIZE_S_data_ram_size)
    begin
      assign conv_in[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus] = proxy_sel_STORE[i9] ? proxy_in3[BITSIZE_proxy_in3+BITSIZE_proxy_in3*i9-1:3+BITSIZE_proxy_in3*i9] : (sel_STORE[i9] ? in3[BITSIZE_in3+BITSIZE_in3*i9-1:3+BITSIZE_in3*i9] : S_data_ram_size[BITSIZE_S_data_ram_size+BITSIZE_S_data_ram_size*i9-1:3+BITSIZE_S_data_ram_size*i9]);
      assign conv_out[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus] = CONV(conv_in[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus]);
      assign be[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus] = conv_out[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus] &lt;&lt; byte_offset[(i9+1)*nbits_byte_offset-1:i9*nbits_byte_offset];
    end
    else
    begin
      assign conv_in[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus] = proxy_sel_STORE[i9] ? proxy_in3[BITSIZE_proxy_in3+BITSIZE_proxy_in3*i9-1:3+BITSIZE_proxy_in3*i9] : in3[BITSIZE_in3+BITSIZE_in3*i9-1:3+BITSIZE_in3*i9];
      assign conv_out[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus] = CONV(conv_in[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus]);
      assign be[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus] = conv_out[(i9+1)*n_byte_on_databus-1:i9*n_byte_on_databus] &lt;&lt; byte_offset[(i9+1)*nbits_byte_offset-1:i9*nbits_byte_offset];
    end
  end
endgenerate

generate
  for (i9=0; i9&lt;max_n_writes; i9=i9+1)
  begin : L9_swapped
    for (i10=0; i10&lt;n_byte_on_databus/2; i10=i10+1)
    begin  : byte_enable_swapped
      assign be_swapped[i10+i9*n_byte_on_databus] = !relative_addr[nbits_byte_offset+i9*nbit_addr-1] ? be[i10+i9*n_byte_on_databus] : be[i10+i9*n_byte_on_databus+n_byte_on_databus/2];
      assign be_swapped[i10+i9*n_byte_on_databus+n_byte_on_databus/2] =  !relative_addr[nbits_byte_offset+i9*nbit_addr-1] ? be[i10+i9*n_byte_on_databus+n_byte_on_databus/2] : be[i10+i9*n_byte_on_databus];
    end
  end
endgenerate
  
generate
genvar i13;
  for (i13=0; i13&lt;PORTSIZE_S_Wdata_ram; i13=i13+1)
  begin : L13
    if (BITSIZE_S_Wdata_ram &lt; memory_bitsize)
      assign S_Wdata_ram_int[memory_bitsize*(i13+1)-1:memory_bitsize*i13] = {{memory_bitsize-BITSIZE_S_Wdata_ram{1&apos;b0}}, S_Wdata_ram[(i13+1)*BITSIZE_S_Wdata_ram-1:BITSIZE_S_Wdata_ram*i13]};
    else
      assign S_Wdata_ram_int[memory_bitsize*(i13+1)-1:memory_bitsize*i13] = S_Wdata_ram[memory_bitsize+BITSIZE_S_Wdata_ram*i13-1:BITSIZE_S_Wdata_ram*i13];
  end
endgenerate

generate
genvar i14;
  for (i14=0; i14&lt;max_n_writes; i14=i14+1)
  begin : L14
    if(PRIVATE_MEMORY==0 &amp;&amp; i14 &lt; PORTSIZE_S_Wdata_ram)
      assign din_value_aggregated[(i14+1)*memory_bitsize-1:i14*memory_bitsize] = proxy_sel_STORE[i14] ? proxy_in1[(i14+1)*BITSIZE_proxy_in1-1:i14*BITSIZE_proxy_in1] &lt;&lt; byte_offset[(i14+1)*nbits_byte_offset-1:i14*nbits_byte_offset]*8 : (sel_STORE[i14] ? in1[(i14+1)*BITSIZE_in1-1:i14*BITSIZE_in1] &lt;&lt; byte_offset[(i14+1)*nbits_byte_offset-1:i14*nbits_byte_offset]*8 : S_Wdata_ram_int[memory_bitsize*(i14+1)-1:memory_bitsize*i14] &lt;&lt; byte_offset[(i14+1)*nbits_byte_offset-1:i14*nbits_byte_offset]*8);
    else
      assign din_value_aggregated[(i14+1)*memory_bitsize-1:i14*memory_bitsize] = proxy_sel_STORE[i14] ? proxy_in1[(i14+1)*BITSIZE_proxy_in1-1:i14*BITSIZE_proxy_in1] &lt;&lt; byte_offset[(i14+1)*nbits_byte_offset-1:i14*nbits_byte_offset]*8 : in1[(i14+1)*BITSIZE_in1-1:i14*BITSIZE_in1] &lt;&lt; byte_offset[(i14+1)*nbits_byte_offset-1:i14*nbits_byte_offset]*8;
  end
endgenerate

generate
  for (i14=0; i14&lt;max_n_writes; i14=i14+1)
  begin : L14_swapped
    assign din_value_aggregated_swapped[(i14)*memory_bitsize+memory_bitsize/2-1:i14*memory_bitsize] = !relative_addr[nbits_byte_offset+i14*nbit_addr-1] ? din_value_aggregated[(i14)*memory_bitsize+memory_bitsize/2-1:i14*memory_bitsize] : din_value_aggregated[(i14+1)*memory_bitsize-1:i14*memory_bitsize+memory_bitsize/2];
    assign din_value_aggregated_swapped[(i14+1)*memory_bitsize-1:i14*memory_bitsize+memory_bitsize/2] = !relative_addr[nbits_byte_offset+i14*nbit_addr-1] ?  din_value_aggregated[(i14+1)*memory_bitsize-1:i14*memory_bitsize+memory_bitsize/2] : din_value_aggregated[(i14)*memory_bitsize+memory_bitsize/2-1:i14*memory_bitsize];
  end
endgenerate

generate
genvar i15;
  for (i15=0; i15&lt;max_n_reads; i15=i15+1)
  begin : L15
    assign out1_shifted[(i15+1)*memory_bitsize-1:i15*memory_bitsize] = dout[(i15+1)*memory_bitsize-1:i15*memory_bitsize] &gt;&gt; delayed_byte_offset[(i15+1)*nbits_byte_offset-1:i15*nbits_byte_offset]*8;
  end
endgenerate

generate
genvar i20;
  for (i20=0; i20&lt;max_n_reads; i20=i20+1)
  begin : L20
    assign out1[(i20+1)*BITSIZE_out1-1:i20*BITSIZE_out1] = out1_shifted[i20*memory_bitsize+BITSIZE_out1-1:i20*memory_bitsize];
    assign proxy_out1[(i20+1)*BITSIZE_proxy_out1-1:i20*BITSIZE_proxy_out1] = out1_shifted[i20*memory_bitsize+BITSIZE_proxy_out1-1:i20*memory_bitsize];
  end
endgenerate

generate
genvar i16;
  for (i16=0; i16&lt;PORTSIZE_S_oe_ram; i16=i16+1)
  begin : L16
    always @(posedge clock 1RESET_EDGE)
    begin
      if(1RESET_VALUE)
        begin
          oe_ram_cs_delayed[i16] &lt;= 1&apos;b0;
          if(HIGH_LATENCY != 0) oe_ram_cs_delayed_registered[i16] &lt;= 1&apos;b0;
          if(HIGH_LATENCY == 2) oe_ram_cs_delayed_registered1[i16] &lt;= 1&apos;b0;
        end
      else
        if(HIGH_LATENCY == 0)
        begin
          oe_ram_cs_delayed[i16] &lt;= oe_ram_cs[i16] &amp; (!oe_ram_cs_delayed[i16] | BUS_PIPELINED);
        end
        else if(HIGH_LATENCY == 1)
        begin
          oe_ram_cs_delayed_registered[i16] &lt;= oe_ram_cs[i16] &amp; ((!oe_ram_cs_delayed_registered[i16] &amp; !oe_ram_cs_delayed[i16]) | BUS_PIPELINED);
          oe_ram_cs_delayed[i16] &lt;= oe_ram_cs_delayed_registered[i16];
        end
        else
        begin
          oe_ram_cs_delayed_registered1[i16] &lt;= oe_ram_cs[i16] &amp; ((!oe_ram_cs_delayed_registered1[i16] &amp; !oe_ram_cs_delayed_registered[i16] &amp; !oe_ram_cs_delayed[i16]) | BUS_PIPELINED);
          oe_ram_cs_delayed_registered[i16] &lt;= oe_ram_cs_delayed_registered1[i16];
          oe_ram_cs_delayed[i16] &lt;= oe_ram_cs_delayed_registered[i16];
        end
      end
    end
endgenerate

always @(posedge clock)
begin
  if(HIGH_LATENCY == 0)
    delayed_byte_offset &lt;= byte_offset[nbits_byte_offset*max_n_reads-1:0];
  else if(HIGH_LATENCY == 1)
  begin
    delayed_byte_offset_registered &lt;= byte_offset[nbits_byte_offset*max_n_reads-1:0];
    delayed_byte_offset &lt;= delayed_byte_offset_registered;
  end
  else
  begin
    delayed_byte_offset_registered1 &lt;= byte_offset[nbits_byte_offset*max_n_reads-1:0];
    delayed_byte_offset_registered &lt;= delayed_byte_offset_registered1;
    delayed_byte_offset &lt;= delayed_byte_offset_registered;
  end
end


generate
genvar i17;
  for (i17=0; i17&lt;PORTSIZE_S_we_ram; i17=i17+1)
  begin : L17
    always @(posedge clock 1RESET_EDGE)
    begin
      if(1RESET_VALUE)
        we_ram_cs_delayed[i17] &lt;= 1&apos;b0;
      else
        we_ram_cs_delayed[i17] &lt;= we_ram_cs[i17] &amp; !we_ram_cs_delayed[i17];
    end
  end
endgenerate

generate
genvar i18;
  for (i18=0; i18&lt;PORTSIZE_Sout_Rdata_ram; i18=i18+1)
  begin : L18
    if(PRIVATE_MEMORY==1)
      assign Sout_Rdata_ram[(i18+1)*BITSIZE_Sout_Rdata_ram-1:i18*BITSIZE_Sout_Rdata_ram] = Sin_Rdata_ram[(i18+1)*BITSIZE_Sin_Rdata_ram-1:i18*BITSIZE_Sin_Rdata_ram];
    else if (BITSIZE_Sout_Rdata_ram &lt;= memory_bitsize)
      assign Sout_Rdata_ram[(i18+1)*BITSIZE_Sout_Rdata_ram-1:i18*BITSIZE_Sout_Rdata_ram] = oe_ram_cs_delayed[i18] ? out1_shifted[BITSIZE_Sout_Rdata_ram+i18*memory_bitsize-1:i18*memory_bitsize] : Sin_Rdata_ram[(i18+1)*BITSIZE_Sin_Rdata_ram-1:i18*BITSIZE_Sin_Rdata_ram];
    else
      assign Sout_Rdata_ram[(i18+1)*BITSIZE_Sout_Rdata_ram-1:i18*BITSIZE_Sout_Rdata_ram] = oe_ram_cs_delayed[i18] ? {{BITSIZE_S_Wdata_ram-memory_bitsize{1&apos;b0}}, out1_shifted[(i18+1)*memory_bitsize-1:i18*memory_bitsize]} : Sin_Rdata_ram[(i18+1)*BITSIZE_Sin_Rdata_ram-1:i18*BITSIZE_Sin_Rdata_ram];
  end
endgenerate

generate
genvar i19;
  for (i19=0; i19&lt;PORTSIZE_Sout_DataRdy; i19=i19+1)
  begin : L19
    if(PRIVATE_MEMORY==0)
      assign Sout_DataRdy[i19] = (i19 &lt; PORTSIZE_S_oe_ram &amp;&amp; oe_ram_cs_delayed[i19]) | Sin_DataRdy[i19] | (i19 &lt; PORTSIZE_S_we_ram &amp;&amp; we_ram_cs_delayed[i19]);
    else
      assign Sout_DataRdy[i19] = Sin_DataRdy[i19];
  end
endgenerate

generate
genvar i21;
  for (i21=0; i21&lt;PORTSIZE_bram_write; i21=i21+1)
  begin : L21
    if(i21 &lt; PORTSIZE_S_we_ram)
      assign bram_write[i21] = (sel_STORE[i21] || proxy_sel_STORE[i21] || we_ram_cs[i21]);
    else
      assign bram_write[i21] = (sel_STORE[i21] || proxy_sel_STORE[i21]);
  end
  endgenerate
" VHDL_PROVIDED="function integer_ternary_operator(cond : boolean; op1 : integer; op2 : integer) return integer is
   begin
      if cond then
         return op1;
      else
         return op2;
      end if;
   end integer_ternary_operator;

function CONV(po2 : std_logic_vector(n_byte_on_databus-1 downto 0)) return std_logic_vector is
  variable int_po2 : integer;
  begin
      int_po2 := to_integer(unsigned(po2));
      case int_po2 is
         when 1 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,n_byte_on_databus),1) -1);
         when 2 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,n_byte_on_databus),2) -1);
         when 4 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,n_byte_on_databus),4) -1);
         when 8 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,n_byte_on_databus),8) -1);
         when 16 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,n_byte_on_databus),16) -1);
         when 32 =&gt;
            return std_logic_vector(shift_left(to_unsigned(1,n_byte_on_databus),32) -1);
         when others =&gt;
            return std_logic_vector(to_signed(-1,n_byte_on_databus));
      end case;
   end CONV;

   constant nbit_addr                     : integer := BITSIZE_S_addr_ram;
   constant nbits_address_space_rangesize : integer := integer(ceil(log2(real(address_space_rangesize))));
   constant nbits_byte_offset             : integer := integer_ternary_operator(n_byte_on_databus = 1, 1, integer(ceil(log2(real(n_byte_on_databus)))));
   constant memory_bitsize                : integer := 2 * BRAM_BITSIZE;
   constant address_space_begin_u         : unsigned(nbit_addr-1 downto 0) := to_unsigned(address_space_begin, nbit_addr);

   signal tmp_addr                       : std_logic_vector((PORTSIZE_in2*BITSIZE_in2)+(-1) downto 0);
   signal conv_in                        : std_logic_vector(n_byte_on_databus*max_n_writes-1 downto 0);
   signal conv_out                       : std_logic_vector(n_byte_on_databus*max_n_writes-1 downto 0);
   signal cs                             : std_logic_vector(PORTSIZE_S_addr_ram-1 downto 0);
   signal oe_ram_cs                      : std_logic_vector(PORTSIZE_S_oe_ram-1 downto 0);
   signal we_ram_cs                      : std_logic_vector(PORTSIZE_S_we_ram-1 downto 0);
   signal relative_addr                  : std_logic_vector(nbit_addr*max_n_rw-1 downto 0);
   signal din_value_aggregated           : std_logic_vector(memory_bitsize*max_n_writes-1 downto 0);
   signal S_Wdata_ram_int                : std_logic_vector(memory_bitsize*PORTSIZE_S_Wdata_ram-1 downto 0);
   signal out1_shifted                   : std_logic_vector(memory_bitsize*max_n_reads-1 downto 0);
   signal dout                           : std_logic_vector(memory_bitsize*max_n_reads-1 downto 0);
   signal byte_offset                    : std_logic_vector(nbits_byte_offset*max_n_rw-1 downto 0);
   signal be                             : std_logic_vector(n_byte_on_databus*max_n_writes-1 downto 0);

   signal we_ram_cs_delayed              : std_logic_vector(PORTSIZE_S_we_ram-1 downto 0);
   signal oe_ram_cs_delayed              : std_logic_vector(PORTSIZE_S_oe_ram-1 downto 0);
   signal oe_ram_cs_delayed_registered   : std_logic_vector(PORTSIZE_S_oe_ram-1 downto 0);
   signal oe_ram_cs_delayed_registered1   : std_logic_vector(PORTSIZE_S_oe_ram-1 downto 0);
   signal delayed_swapped_bit            : std_logic_vector(max_n_reads-1 downto 0);
   signal delayed_swapped_bit_registered : std_logic_vector(max_n_reads-1 downto 0);
   signal delayed_swapped_bit_registered1 : std_logic_vector(max_n_reads-1 downto 0);
   signal delayed_byte_offset            : std_logic_vector(nbits_byte_offset*max_n_reads-1 downto 0);
   signal delayed_byte_offset_registered : std_logic_vector(nbits_byte_offset*max_n_reads-1 downto 0);
   signal delayed_byte_offset_registered1 : std_logic_vector(nbits_byte_offset*max_n_reads-1 downto 0);
begin
   process(proxy_sel_LOAD, proxy_sel_STORE, proxy_in2, in2)
   begin
      for ind2 in 0 to PORTSIZE_in2-1 loop
         if(proxy_sel_LOAD(ind2) = &apos;1&apos; or proxy_sel_STORE(ind2) = &apos;1&apos;) then
            tmp_addr((ind2+1)*BITSIZE_in2-1 downto ind2*BITSIZE_in2) &lt;= proxy_in2((ind2+1)*BITSIZE_proxy_in2-1  downto ind2*BITSIZE_proxy_in2);
         else
            tmp_addr((ind2+1)*BITSIZE_in2-1 downto ind2*BITSIZE_in2) &lt;= in2((ind2+1)*BITSIZE_in2-1 downto ind2*BITSIZE_in2);
         end if;
      end loop;
   end process;

   L_delayed_swapped_bit : process(clock)
   begin
      if (clock&apos;event and clock=&apos;1&apos;) then
         for i2 in 0 to max_n_reads-1 loop
            if(HIGH_LATENCY = 0) then
               delayed_swapped_bit(i2) &lt;= not relative_addr(nbits_byte_offset+i2*nbit_addr-1);
            elsif(HIGH_LATENCY = 1) then
               delayed_swapped_bit_registered(i2) &lt;= not relative_addr(nbits_byte_offset+i2*nbit_addr-1);
               delayed_swapped_bit(i2) &lt;= delayed_swapped_bit_registered(i2);
            else
               delayed_swapped_bit_registered1(i2) &lt;= not relative_addr(nbits_byte_offset+i2*nbit_addr-1);
               delayed_swapped_bit_registered(i2) &lt;= delayed_swapped_bit_registered1(i2);
               delayed_swapped_bit(i2) &lt;= delayed_swapped_bit_registered(i2);
            end if;
         end loop;
      end if;
   end process;

   L_dout : process(dout_a, dout_b, delayed_swapped_bit)
   begin
      for i2 in 0 to max_n_reads-1 loop
         if(delayed_swapped_bit(i2) /= &apos;0&apos;) then
            dout((memory_bitsize/2)+memory_bitsize*i2-1 downto memory_bitsize*i2) &lt;= dout_a((memory_bitsize/2)*(i2+1)-1 downto (memory_bitsize/2)*i2);
         else
            dout((memory_bitsize/2)+memory_bitsize*i2-1 downto memory_bitsize*i2) &lt;= dout_b((memory_bitsize/2)*(i2+1)-1 downto (memory_bitsize/2)*i2);
         end if;
         if(delayed_swapped_bit(i2) /= &apos;0&apos;) then
            dout(memory_bitsize*(i2+1)-1 downto memory_bitsize*i2+(memory_bitsize/2)) &lt;= dout_b((memory_bitsize/2)*(i2+1)-1 downto (memory_bitsize/2)*i2);
         else
            dout(memory_bitsize*(i2+1)-1 downto memory_bitsize*i2+(memory_bitsize/2)) &lt;= dout_a((memory_bitsize/2)*(i2+1)-1 downto (memory_bitsize/2)*i2);
         end if;
      end loop;
   end process;

   L3 : process(S_addr_ram)
   begin
      for i3 in 0 to PORTSIZE_S_addr_ram-1 loop
         if(PRIVATE_MEMORY = 0 and USE_SPARSE_MEMORY = 0) then
            if(to_integer(unsigned(S_addr_ram((i3+1)*BITSIZE_S_addr_ram-1 downto i3*BITSIZE_S_addr_ram))) &gt;= (address_space_begin)) and (to_integer(unsigned(S_addr_ram((i3+1)*BITSIZE_S_addr_ram-1 downto i3*BITSIZE_S_addr_ram))) &lt; (address_space_begin+address_space_rangesize)) then
               cs(i3) &lt;= &apos;1&apos;;
            else
               cs(i3) &lt;= &apos;0&apos;;
            end if;
         else
            if(PRIVATE_MEMORY=0) then
               if S_addr_ram((i3+1)*BITSIZE_S_addr_ram-1 downto i3*BITSIZE_S_addr_ram+nbits_address_space_rangesize) = std_logic_vector(address_space_begin_u(nbit_addr-1 downto nbits_address_space_rangesize)) then
                  cs(i3) &lt;= &apos;1&apos;;
               else
                  cs(i3) &lt;= &apos;0&apos;;
               end if;
            else
               cs(i3) &lt;= &apos;0&apos;;
            end if;
         end if;
      end loop;
   end process;

   L4 : process(S_oe_ram, cs)
   begin
      for i4 in 0 to PORTSIZE_S_oe_ram-1 loop
         oe_ram_cs(i4) &lt;= S_oe_ram(i4) and cs(i4);
      end loop;
   end process;

   L5 : process(S_we_ram, cs)
   begin
      for i5 in 0 to PORTSIZE_S_we_ram-1 loop
         we_ram_cs(i5) &lt;= S_we_ram(i5) and cs(i5);
      end loop;
   end process;

   L6 : process(sel_STORE, proxy_sel_STORE, sel_LOAD, proxy_sel_LOAD, tmp_addr, S_addr_ram)
   begin
      for i6 in 0 to max_n_rw-1 loop
         if(PRIVATE_MEMORY=0 and USE_SPARSE_MEMORY=0 and i6&lt; PORTSIZE_S_addr_ram) then
            if((i6 &lt; max_n_writes and (sel_STORE(i6) = &apos;1&apos;  or proxy_sel_STORE(i6) = &apos;1&apos;)) or (i6 &lt; max_n_reads and (sel_LOAD(i6) = &apos;1&apos; or proxy_sel_LOAD(i6) = &apos;1&apos;))) then
               relative_addr((i6+1)*nbit_addr-1 downto i6*nbit_addr) &lt;= std_logic_vector(unsigned(tmp_addr((i6+1)*BITSIZE_in2-1 downto i6*BITSIZE_in2))-(to_unsigned(address_space_begin, nbit_addr)));
            else
               relative_addr((i6+1)*nbit_addr-1 downto i6*nbit_addr) &lt;= std_logic_vector(unsigned(S_addr_ram((i6+1)*BITSIZE_S_addr_ram-1 downto i6*BITSIZE_S_addr_ram)) - (to_unsigned(address_space_begin, nbit_addr)));
            end if;
         else
            if(PRIVATE_MEMORY=0 and i6&lt; PORTSIZE_S_addr_ram) then
               if((i6 &lt; max_n_writes and (sel_STORE(i6) = &apos;1&apos; or proxy_sel_STORE(i6) =&apos;1&apos; )) or (i6 &lt; max_n_reads and (sel_LOAD(i6)=&apos;1&apos; or proxy_sel_LOAD(i6)=&apos;1&apos;))) then
                  relative_addr((i6)*nbit_addr+nbits_address_space_rangesize-1 downto i6*nbit_addr) &lt;= tmp_addr((i6)*BITSIZE_in2+nbits_address_space_rangesize-1 downto i6*BITSIZE_in2);
                  relative_addr((i6+1)*nbit_addr-1 downto (i6)*nbit_addr+nbits_address_space_rangesize) &lt;= (others =&gt; &apos;0&apos;);
               else
                  relative_addr((i6)*nbit_addr+nbits_address_space_rangesize-1 downto i6*nbit_addr) &lt;= S_addr_ram((i6)*BITSIZE_S_addr_ram+nbits_address_space_rangesize-1 downto i6*BITSIZE_S_addr_ram);
                  relative_addr((i6+1)*nbit_addr-1 downto (i6)*nbit_addr+nbits_address_space_rangesize) &lt;= (others =&gt; &apos;0&apos;);
               end if;
            else
               if(USE_SPARSE_MEMORY=1) then
                  relative_addr((i6)*nbit_addr+nbits_address_space_rangesize-1 downto i6*nbit_addr) &lt;= tmp_addr((i6)*BITSIZE_in2+nbits_address_space_rangesize-1 downto i6*BITSIZE_in2);
                  relative_addr((i6+1)*nbit_addr-1 downto (i6)*nbit_addr+nbits_address_space_rangesize) &lt;= (others =&gt; &apos;0&apos;);
               else
                  relative_addr((i6+1)*nbit_addr-1 downto i6*nbit_addr) &lt;= std_logic_vector(unsigned(tmp_addr((i6+1)*BITSIZE_in2-1 downto i6*BITSIZE_in2)) - to_unsigned(address_space_begin, nbit_addr));
               end if;
            end if;
         end if;
      end loop;
   end process;

   L7_A : process(relative_addr)
   begin
      for i7 in 0 to max_n_rw-1 loop
         if (n_mem_elements=1) then
             memory_addr_a((i7+1)*nbit_read_addr-1 downto i7*nbit_read_addr) &lt;= (others =&gt; &apos;0&apos;);
         else
            if(relative_addr(nbits_byte_offset+i7*nbit_addr-1) = &apos;0&apos;) then
               memory_addr_a((i7+1)*nbit_read_addr-1 downto i7*nbit_read_addr) &lt;= relative_addr(nbit_read_addr+nbits_byte_offset-1+i7*nbit_addr downto nbits_byte_offset+i7*nbit_addr);
            else
               memory_addr_a((i7+1)*nbit_read_addr-1 downto i7*nbit_read_addr) &lt;= std_logic_vector(resize(shift_right(unsigned(relative_addr(nbit_read_addr+nbits_byte_offset-1+i7*nbit_addr downto nbits_byte_offset+i7*nbit_addr-1)) + 1, 1), nbit_read_addr));
               end if;
         end if;
      end loop;
   end process;

   L7_B : process(relative_addr)
   begin
      for i7 in 0 to max_n_rw-1 loop
         if (n_mem_elements=1) then
            memory_addr_b((i7+1)*nbit_read_addr-1 downto i7*nbit_read_addr) &lt;= (others =&gt; &apos;0&apos;);
         else
            if(relative_addr(nbits_byte_offset+i7*nbit_addr-1) = &apos;0&apos;) then
               memory_addr_b((i7+1)*nbit_read_addr-1 downto i7*nbit_read_addr) &lt;= std_logic_vector(resize(shift_right(unsigned(relative_addr(nbit_read_addr+nbits_byte_offset-1+i7*nbit_addr downto nbits_byte_offset+i7*nbit_addr-1)) + 1, 1), nbit_read_addr));
            else
               memory_addr_b((i7+1)*nbit_read_addr-1 downto i7*nbit_read_addr) &lt;= relative_addr(nbit_read_addr+nbits_byte_offset-1+i7*nbit_addr downto nbits_byte_offset+i7*nbit_addr);
            end if;
         end if;
      end loop;
   end process;

   L8 : process(relative_addr)
   begin
      for i8 in 0 to max_n_rw-1 loop
         if (n_byte_on_databus=2) then
            byte_offset((i8+1)*nbits_byte_offset-1 downto i8*nbits_byte_offset) &lt;= (others =&gt; &apos;0&apos;);
         else
            byte_offset((i8+1)*nbits_byte_offset-1 downto i8*nbits_byte_offset) &lt;= &apos;0&apos; &amp; relative_addr(nbits_byte_offset+i8*nbit_addr-2 downto i8*nbit_addr);
         end if;
      end loop;
   end process;

   be_conv_in : process(proxy_sel_STORE, proxy_in3, sel_STORE, in3, S_data_ram_size)
   begin
      for i9 in 0 to max_n_writes-1 loop
         if(PRIVATE_MEMORY=0 and i9 &lt; PORTSIZE_S_data_ram_size) then
            if(proxy_sel_STORE(i9) /= &apos;0&apos;) then
               conv_in((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus) &lt;= std_logic_vector(resize(unsigned(proxy_in3(BITSIZE_proxy_in3+BITSIZE_proxy_in3*i9-1 downto 3+BITSIZE_proxy_in3*i9)), n_byte_on_databus));
            else
               if(sel_STORE(i9) /= &apos;0&apos;) then
                  conv_in((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus) &lt;= std_logic_vector(resize(unsigned(in3(BITSIZE_in3+BITSIZE_in3*i9-1 downto 3+BITSIZE_in3*i9)), n_byte_on_databus));
               else
                  conv_in((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus) &lt;= std_logic_vector(resize(unsigned(S_data_ram_size(BITSIZE_S_data_ram_size+BITSIZE_S_data_ram_size*i9-1 downto 3+BITSIZE_S_data_ram_size*i9)), n_byte_on_databus));
               end if;
            end if;
         else
            if(proxy_sel_STORE(i9) /= &apos;0&apos;) then
               conv_in((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus) &lt;= std_logic_vector(resize(unsigned(proxy_in3(BITSIZE_proxy_in3+BITSIZE_proxy_in3*i9-1 downto 3+BITSIZE_proxy_in3*i9)), n_byte_on_databus));
            else
               conv_in((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus) &lt;= std_logic_vector(resize(unsigned(in3(BITSIZE_in3+BITSIZE_in3*i9-1 downto 3+BITSIZE_in3*i9)), n_byte_on_databus));
            end if;
         end  if;
      end loop;
   end process;

   be_conv_out : process(conv_in)
   begin
      for i9 in 0 to max_n_writes-1 loop
         if(PRIVATE_MEMORY=0 and i9 &lt; PORTSIZE_S_data_ram_size) then
            conv_out((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus) &lt;= std_logic_vector(
               resize(
                  unsigned(
                     CONV(
                        conv_in((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus)
                     )
                  ),
                  n_byte_on_databus
               )
            );
         else
            conv_out((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus) &lt;= std_logic_vector(
               resize(
                  unsigned(
                     CONV(
                        conv_in((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus)
                     )
                  ),
                  n_byte_on_databus
               )
            );
         end  if;
      end loop;
   end process;

   byte_enable : process(conv_out, byte_offset)
   begin
      for i9 in 0 to max_n_writes-1 loop
         if(PRIVATE_MEMORY=0 and i9 &lt; PORTSIZE_S_data_ram_size) then
            be((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus) &lt;= std_logic_vector(shift_left(unsigned(conv_out((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus)), to_integer(unsigned(byte_offset((i9+1)*nbits_byte_offset-1 downto i9*nbits_byte_offset)))));
         else
            be((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus) &lt;= std_logic_vector(shift_left(unsigned(conv_out((i9+1)*n_byte_on_databus-1 downto i9*n_byte_on_databus)), to_integer(unsigned(byte_offset((i9+1)*nbits_byte_offset-1 downto i9*nbits_byte_offset)))));
         end  if;
      end loop;
   end process;

   byte_enable_swapped : process(relative_addr, be)
   begin
      for i9 in 0 to max_n_writes-1 loop
         for i10 in 0 to n_byte_on_databus/2 - 1 loop
            if(relative_addr(nbits_byte_offset+i9*nbit_addr-1) = &apos;0&apos;) then
               be_swapped(i10+i9*n_byte_on_databus) &lt;= be(i10+i9*n_byte_on_databus);
               be_swapped(i10+i9*n_byte_on_databus+n_byte_on_databus/2) &lt;= be(i10+i9*n_byte_on_databus+n_byte_on_databus/2);
            else
               be_swapped(i10+i9*n_byte_on_databus) &lt;= be(i10+i9*n_byte_on_databus+n_byte_on_databus/2);
               be_swapped(i10+i9*n_byte_on_databus+n_byte_on_databus/2) &lt;= be(i10+i9*n_byte_on_databus);
            end if;
         end loop;
      end loop;
   end process;

   L13 : process(S_Wdata_ram)
   begin
      for i13 in 0 to PORTSIZE_S_Wdata_ram-1 loop
         if (BITSIZE_S_Wdata_ram &lt; memory_bitsize) then
            S_Wdata_ram_int(memory_bitsize*(i13+1)-1 downto memory_bitsize*i13 + BITSIZE_S_Wdata_ram) &lt;= (others =&gt; &apos;0&apos;);
            S_Wdata_ram_int(memory_bitsize*i13 + BITSIZE_S_Wdata_ram - 1 downto memory_bitsize*i13) &lt;= S_Wdata_ram((i13+1)*BITSIZE_S_Wdata_ram-1 downto BITSIZE_S_Wdata_ram*i13);
         else
            S_Wdata_ram_int(memory_bitsize*(i13+1)-1 downto memory_bitsize*i13) &lt;= S_Wdata_ram(memory_bitsize+BITSIZE_S_Wdata_ram*i13-1 downto BITSIZE_S_Wdata_ram*i13);
         end if;
      end loop;
   end process;

   L14 : process(proxy_sel_STORE, proxy_in1, byte_offset, sel_STORE, in1, S_Wdata_ram_int)
   begin
      for i14 in 0 to max_n_writes-1 loop
         if(PRIVATE_MEMORY=0 and i14 &lt; PORTSIZE_S_Wdata_ram) then
            if(proxy_sel_STORE(i14) /= &apos;0&apos;) then
               din_value_aggregated((i14+1)*memory_bitsize-1 downto i14*memory_bitsize) &lt;= std_logic_vector(shift_left(resize(unsigned(proxy_in1((i14+1)*BITSIZE_proxy_in1-1 downto i14*BITSIZE_proxy_in1)), memory_bitsize), to_integer(unsigned(byte_offset((i14+1)*nbits_byte_offset-1 downto i14*nbits_byte_offset)))*8));
            else
               if(sel_STORE(i14) /= &apos;0&apos;) then
                  din_value_aggregated((i14+1)*memory_bitsize-1 downto i14*memory_bitsize) &lt;= std_logic_vector(shift_left(resize(unsigned((in1((i14+1)*BITSIZE_in1-1 downto i14*BITSIZE_in1))), memory_bitsize), to_integer(unsigned(byte_offset((i14+1)*nbits_byte_offset-1 downto i14*nbits_byte_offset)))*8));
               else
                  din_value_aggregated((i14+1)*memory_bitsize-1 downto i14*memory_bitsize) &lt;= std_logic_vector(shift_left(resize(unsigned(S_Wdata_ram_int(memory_bitsize*(i14+1)-1 downto memory_bitsize*i14)), memory_bitsize), to_integer(unsigned(byte_offset((i14+1)*nbits_byte_offset-1 downto i14*nbits_byte_offset)))*8));
               end if;
             end if;
         else
            if(proxy_sel_STORE(i14) /= &apos;0&apos;) then
               din_value_aggregated((i14+1)*memory_bitsize-1 downto i14*memory_bitsize) &lt;= std_logic_vector(shift_left(resize(unsigned(proxy_in1((i14+1)*BITSIZE_proxy_in1-1 downto i14*BITSIZE_proxy_in1)), memory_bitsize), to_integer(unsigned(byte_offset((i14+1)*nbits_byte_offset-1 downto i14*nbits_byte_offset)))*8));
            else
               din_value_aggregated((i14+1)*memory_bitsize-1 downto i14*memory_bitsize) &lt;= std_logic_vector(shift_left(resize(unsigned(in1((i14+1)*BITSIZE_in1-1 downto i14*BITSIZE_in1)), memory_bitsize), to_integer(unsigned(byte_offset((i14+1)*nbits_byte_offset-1 downto i14*nbits_byte_offset)))*8));
            end if;
         end if;
      end loop;
   end process;

   L14_swapped : process(relative_addr, din_value_aggregated)
   begin
      for i14 in 0 to max_n_writes-1 loop
         if(relative_addr(nbits_byte_offset+i14*nbit_addr-1) = &apos;0&apos;) then
            din_value_aggregated_swapped((i14)*memory_bitsize+memory_bitsize/2-1 downto i14*memory_bitsize) &lt;= din_value_aggregated((i14)*memory_bitsize+memory_bitsize/2-1 downto i14*memory_bitsize);
         else
            din_value_aggregated_swapped((i14)*memory_bitsize+memory_bitsize/2-1 downto i14*memory_bitsize) &lt;= din_value_aggregated((i14+1)*memory_bitsize-1 downto i14*memory_bitsize+memory_bitsize/2);
         end if;
         if(relative_addr(nbits_byte_offset+i14*nbit_addr-1) = &apos;0&apos;) then
            din_value_aggregated_swapped((i14+1)*memory_bitsize-1 downto i14*memory_bitsize+memory_bitsize/2) &lt;= din_value_aggregated((i14+1)*memory_bitsize-1 downto i14*memory_bitsize+memory_bitsize/2);
         else
            din_value_aggregated_swapped((i14+1)*memory_bitsize-1 downto i14*memory_bitsize+memory_bitsize/2) &lt;= din_value_aggregated((i14)*memory_bitsize+memory_bitsize/2-1 downto i14*memory_bitsize);
         end if;
      end loop;
   end process;

   L15 : process(dout, delayed_byte_offset)
   begin
      for i15 in 0 to max_n_reads-1 loop
         out1_shifted((i15+1)*memory_bitsize-1 downto i15*memory_bitsize) &lt;= std_logic_vector(shift_right(resize(unsigned(dout((i15+1)*memory_bitsize-1 downto i15*memory_bitsize)), memory_bitsize), to_integer(unsigned(delayed_byte_offset((i15+1)*nbits_byte_offset-1 downto i15*nbits_byte_offset)))*8));
      end loop;
   end process;

   L20 : process(out1_shifted)
   begin
      for i20 in 0 to max_n_reads-1 loop
         out1((i20+1)*BITSIZE_out1-1 downto i20*BITSIZE_out1) &lt;= out1_shifted(i20*memory_bitsize+BITSIZE_out1-1 downto i20*memory_bitsize);
         proxy_out1((i20+1)*BITSIZE_proxy_out1-1 downto i20*BITSIZE_proxy_out1) &lt;= out1_shifted(i20*memory_bitsize+BITSIZE_proxy_out1-1 downto i20*memory_bitsize);
      end loop;
   end process;

   L16 : process(reset, clock)
   begin
      if(1RESET_VALUE) then
         for i16 in 0 to PORTSIZE_S_oe_ram - 1 loop
            oe_ram_cs_delayed(i16) &lt;= &apos;0&apos;;
            if(HIGH_LATENCY /= 0) then
               oe_ram_cs_delayed_registered(i16) &lt;= &apos;0&apos;;
            end if;
            if(HIGH_LATENCY = 2) then
               oe_ram_cs_delayed_registered1(i16) &lt;= &apos;0&apos;;
            end if;
         end loop;
      elsif (clock&apos;event and clock = &apos;1&apos;) then
         for i16 in 0 to PORTSIZE_S_oe_ram - 1 loop
            if(HIGH_LATENCY = 0) then
               if(BUS_PIPELINED /= 0) then
                  oe_ram_cs_delayed(i16) &lt;= oe_ram_cs(i16);
               else
                  oe_ram_cs_delayed(i16) &lt;= oe_ram_cs(i16) and (not oe_ram_cs_delayed(i16));
               end if;
            elsif(HIGH_LATENCY = 1) then
               if(BUS_PIPELINED /= 0) then
                  oe_ram_cs_delayed_registered(i16) &lt;= oe_ram_cs(i16);
               else
                  oe_ram_cs_delayed_registered(i16) &lt;= oe_ram_cs(i16) and ((not oe_ram_cs_delayed_registered(i16) and not oe_ram_cs_delayed(i16)));
                end if;
                oe_ram_cs_delayed(i16) &lt;= oe_ram_cs_delayed_registered(i16);
            else
               if(BUS_PIPELINED /= 0) then
                  oe_ram_cs_delayed_registered1(i16) &lt;= oe_ram_cs(i16);
               else
                  oe_ram_cs_delayed_registered1(i16) &lt;= oe_ram_cs(i16) and ((not oe_ram_cs_delayed_registered1(i16) and not oe_ram_cs_delayed_registered(i16) and not oe_ram_cs_delayed(i16)));
               end if;
               oe_ram_cs_delayed_registered(i16) &lt;= oe_ram_cs_delayed_registered1(i16);
               oe_ram_cs_delayed(i16) &lt;= oe_ram_cs_delayed_registered(i16);
            end if;
         end loop;
      end if;
   end process;

   process(clock)
   begin
      if (clock&apos;event and clock=&apos;1&apos;) then
         if(HIGH_LATENCY = 0) then
            delayed_byte_offset &lt;= byte_offset(nbits_byte_offset*max_n_reads-1 downto 0);
         elsif(HIGH_LATENCY = 1) then
            delayed_byte_offset_registered &lt;= byte_offset(nbits_byte_offset*max_n_reads-1 downto 0);
            delayed_byte_offset &lt;= delayed_byte_offset_registered;
         else
            delayed_byte_offset_registered1 &lt;= byte_offset(nbits_byte_offset*max_n_reads-1 downto 0);
            delayed_byte_offset_registered &lt;= delayed_byte_offset_registered1;
            delayed_byte_offset &lt;= delayed_byte_offset_registered;
         end if;
      end if;
   end process;

   process(clock, reset)
   begin
      if(1RESET_VALUE) then
         for i17 in 0 to PORTSIZE_S_we_ram-1 loop
            we_ram_cs_delayed(i17) &lt;= &apos;0&apos;;
         end loop;
      elsif (clock&apos;event and clock = &apos;1&apos;) then
         for i17 in 0 to PORTSIZE_S_we_ram-1 loop
               we_ram_cs_delayed(i17) &lt;= we_ram_cs(i17) and not we_ram_cs_delayed(i17);
         end loop;
      end if;
   end process;

   L18 : process(Sin_Rdata_ram, out1_shifted, oe_ram_cs_delayed)
   begin
      for i18 in 0 to PORTSIZE_Sout_Rdata_ram-1 loop
         if(PRIVATE_MEMORY=1) then
             Sout_Rdata_ram((i18+1)*BITSIZE_Sout_Rdata_ram-1 downto i18*BITSIZE_Sout_Rdata_ram) &lt;= Sin_Rdata_ram((i18+1)*BITSIZE_Sin_Rdata_ram-1 downto i18*BITSIZE_Sin_Rdata_ram);
         else
            if (BITSIZE_Sout_Rdata_ram &lt;= memory_bitsize) then
               if(oe_ram_cs_delayed(i18) /= &apos;0&apos;) then
                  Sout_Rdata_ram((i18+1)*BITSIZE_Sout_Rdata_ram-1 downto i18*BITSIZE_Sout_Rdata_ram) &lt;= out1_shifted(BITSIZE_Sout_Rdata_ram+i18*memory_bitsize-1 downto i18*memory_bitsize);
               else
                  Sout_Rdata_ram((i18+1)*BITSIZE_Sout_Rdata_ram-1 downto i18*BITSIZE_Sout_Rdata_ram) &lt;= Sin_Rdata_ram((i18+1)*BITSIZE_Sin_Rdata_ram-1 downto i18*BITSIZE_Sin_Rdata_ram);
               end if;
            else
               if(oe_ram_cs_delayed(i18) /= &apos;0&apos;) then
                  Sout_Rdata_ram((i18+1)*BITSIZE_Sout_Rdata_ram-1 downto i18*BITSIZE_Sout_Rdata_ram) &lt;= std_logic_vector(resize(unsigned(out1_shifted((i18+1)*memory_bitsize-1 downto i18*memory_bitsize)), BITSIZE_Sout_Rdata_ram));
               else
                  Sout_Rdata_ram((i18+1)*BITSIZE_Sout_Rdata_ram-1 downto i18*BITSIZE_Sout_Rdata_ram) &lt;= Sin_Rdata_ram((i18+1)*BITSIZE_Sin_Rdata_ram-1 downto i18*BITSIZE_Sin_Rdata_ram);
               end if;
            end if;
         end if;
      end loop;
   end process;

   L19 : process(oe_ram_cs_delayed, Sin_DataRdy, we_ram_cs_delayed)
   begin
      for i19 in 0 to PORTSIZE_Sout_DataRdy-1 loop
         if(PRIVATE_MEMORY=0) then
            if((i19 &lt; PORTSIZE_S_oe_ram and oe_ram_cs_delayed(i19) /= &apos;0&apos;) or (Sin_DataRdy(i19) /= &apos;0&apos;) or (i19 &lt; PORTSIZE_S_we_ram and we_ram_cs_delayed(i19) /= &apos;0&apos;)) then
               Sout_DataRdy(i19) &lt;= &apos;1&apos;;
            else
               Sout_DataRdy(i19) &lt;= &apos;0&apos;;
            end if;
         else
            Sout_DataRdy(i19) &lt;= Sin_DataRdy(i19);
         end if;
      end loop;
   end process;

   L21 : process(sel_STORE, proxy_sel_STORE, we_ram_cs)
   begin
      for i21 in 0 to PORTSIZE_bram_write-1 loop
         if(i21 &lt; PORTSIZE_S_we_ram) then
            bram_write(i21) &lt;= (sel_STORE(i21) or proxy_sel_STORE(i21) or we_ram_cs(i21));
         else
            bram_write(i21) &lt;= (sel_STORE(i21) or proxy_sel_STORE(i21));
         end if;
      end loop;
   end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_TP</name>
      <circuit>
        <component_o id="BRAM_MEMORY_TP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_TP"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="n_bytes">4</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_TP dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated be MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements n_bytes READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="
wire [n_byte_on_databus-1:0] we_a;
wire [n_byte_on_databus-1:0] we_b;

wire [n_byte_on_databus-1:0] we_a_temp;
wire [n_byte_on_databus-1:0] we_b_temp;
wire bram_write_temp;
wire [BITSIZE_din_value_aggregated-1:0] din_value_aggregated_temp;
wire [BITSIZE_memory_addr_a-1:0] memory_addr_a_temp;
wire [BITSIZE_memory_addr_b-1:0] memory_addr_b_temp;


wire [BRAM_BITSIZE-1:0] din_a_temp;
wire [BRAM_BITSIZE-1:0] din_b_temp;
reg [BITSIZE_dout_a-1:0] dout_a;
reg [BITSIZE_dout_a-1:0] dout_a_registered;
reg [BITSIZE_dout_b-1:0] dout_b;
reg [BITSIZE_dout_b-1:0] dout_b_registered;
reg [BRAM_BITSIZE-1:0] memory [0:n_mem_elements-1] /* synthesis syn_ramstyle = &quot;no_rw_check&quot; */;

initial
begin
  $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
end

generate
  if(HIGH_LATENCY==2)
  begin
    reg [n_byte_on_databus-1:0] we_a_reg;
    reg [n_byte_on_databus-1:0] we_b_reg;
    reg bram_write_reg;
    reg [BITSIZE_din_value_aggregated-1:0] din_value_aggregated_reg;
    reg [BITSIZE_memory_addr_a-1:0] memory_addr_a_reg;
    reg [BITSIZE_memory_addr_b-1:0] memory_addr_b_reg;
    always @ (posedge clock)
    begin
       memory_addr_a_reg &lt;= memory_addr_a;
       memory_addr_b_reg &lt;= memory_addr_b;
       we_a_reg &lt;= we_a;
       we_b_reg &lt;= we_b;
       bram_write_reg &lt;= bram_write;
       din_value_aggregated_reg &lt;= din_value_aggregated;
    end
    assign we_a_temp = we_a_reg;
    assign we_b_temp = we_b_reg;
    assign memory_addr_a_temp = memory_addr_a_reg;
    assign memory_addr_b_temp = memory_addr_b_reg;
    assign bram_write_temp = bram_write_reg;
    assign din_value_aggregated_temp = din_value_aggregated_reg;
  end
  else
  begin
    assign we_a_temp = we_a;
    assign we_b_temp = we_b;
    assign memory_addr_a_temp = memory_addr_a;
    assign memory_addr_b_temp = memory_addr_b;
    assign bram_write_temp = bram_write;
    assign din_value_aggregated_temp = din_value_aggregated;
  end
endgenerate


generate
genvar i0_a;
  for (i0_a=0; i0_a&lt;n_byte_on_databus; i0_a=i0_a+1)
  begin  : din_a_computation1
    assign din_a_temp[(i0_a+1)*8-1:i0_a*8] = we_a_temp[i0_a] ? din_value_aggregated_temp[(i0_a+1)*8-1:i0_a*8] : memory[memory_addr_a_temp][(i0_a+1)*8-1:i0_a*8];
  end
endgenerate

generate
genvar i0_b;
  for (i0_b=0; i0_b&lt;n_byte_on_databus &amp;&amp; n_bytes &gt; BRAM_BITSIZE/8; i0_b=i0_b+1)
  begin  : din_b_computation1
    assign din_b_temp[(i0_b+1)*8-1:i0_b*8] = we_b_temp[i0_b] ? din_value_aggregated_temp[(i0_b+n_byte_on_databus+1)*8-1:(i0_b+n_byte_on_databus)*8] : memory[memory_addr_b_temp][(i0_b+1)*8-1:i0_b*8];
  end
endgenerate

always @(posedge clock)
begin
  if(READ_ONLY_MEMORY==0)
  begin
    if (bram_write_temp)
    begin
      memory[memory_addr_a_temp] &lt;= din_a_temp;
    end
  end
  if(HIGH_LATENCY==0)
  begin
    dout_a &lt;= memory[memory_addr_a_temp];
  end
  else
  begin
    dout_a_registered &lt;= memory[memory_addr_a_temp];
    dout_a &lt;= dout_a_registered;
  end
end

generate
  if (n_bytes &gt; BRAM_BITSIZE/8)
  begin
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if (bram_write_temp)
        begin
          memory[memory_addr_b_temp] &lt;= din_b_temp;
        end
      end
      if(HIGH_LATENCY==0)
      begin
        dout_b &lt;= memory[memory_addr_b_temp];
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_b_temp];
        dout_b &lt;= dout_b_registered;
      end
    end
  end
endgenerate

generate
genvar i2_a;
  for (i2_a=0; i2_a&lt;n_byte_on_databus; i2_a=i2_a+1)
  begin  : write_enable_a
    assign we_a[i2_a] = (bram_write) &amp;&amp; be[i2_a];
  end
endgenerate

generate
genvar i2_b;
  for (i2_b=0; i2_b&lt;n_byte_on_databus; i2_b=i2_b+1)
  begin  : write_enable_b
    assign we_b[i2_b] = (bram_write) &amp;&amp; be[i2_b+n_byte_on_databus];
  end
  endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_NN_TP</name>
      <circuit>
        <component_o id="BRAM_MEMORY_NN_TP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_NN_TP"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="max_n_reads">2</parameter>
          <parameter name="max_n_writes">2</parameter>
          <parameter name="memory_offset">16</parameter>
          <parameter name="n_byte_on_databus_offset">2</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_vector_o>
          <port_vector_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value_aggregated_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="be_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_NN_TP bram_write dout_a memory_addr_a din_value_aggregated_swapped be_swapped MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements max_n_reads max_n_writes memory_offset n_byte_on_databus_offset READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="
wire [nbit_read_addr-1:0] memory_addr_a_0;
wire [nbit_read_addr-1:0] memory_addr_a_1;
wire [(n_byte_on_databus/2)*max_n_writes-1:0] we_a;
wire [(n_byte_on_databus/2)*max_n_writes-1:0] we_a_temp;
wire [(PORTSIZE_memory_addr_a*BITSIZE_memory_addr_a)+(-1):0] memory_addr_a_temp;
wire [PORTSIZE_bram_write-1:0] bram_write_temp;
wire [(PORTSIZE_din_value_aggregated_swapped*BITSIZE_din_value_aggregated_swapped)+(-1):0] din_value_aggregated_swapped_temp;

wire [BRAM_BITSIZE-1:0] din_a_0_temp;
wire [BRAM_BITSIZE-1:0] din_a_1_temp;
reg [BRAM_BITSIZE-1:0] dout_a_0;
reg [BRAM_BITSIZE-1:0] dout_a_1;
reg [BRAM_BITSIZE-1:0] dout_a_0_registered;
reg [BRAM_BITSIZE-1:0] dout_a_1_registered;

integer index1, index2;
reg [BRAM_BITSIZE-1:0] memory [0:n_mem_elements-1] /* synthesis syn_ramstyle = &quot;no_rw_check&quot; */;

initial
begin
  $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
end

generate
  if(HIGH_LATENCY==2)
  begin
    reg [(n_byte_on_databus/2)*max_n_writes-1:0] we_a_reg;
    reg [PORTSIZE_bram_write-1:0] bram_write_reg;
    reg [(PORTSIZE_din_value_aggregated_swapped*BITSIZE_din_value_aggregated_swapped)+(-1):0] din_value_aggregated_swapped_reg;
    reg [(PORTSIZE_memory_addr_a*BITSIZE_memory_addr_a)+(-1):0] memory_addr_a_reg;
    always @ (posedge clock)
    begin
       we_a_reg &lt;= we_a;
       memory_addr_a_reg &lt;= memory_addr_a;
       bram_write_reg &lt;= bram_write;
       din_value_aggregated_swapped_reg &lt;= din_value_aggregated_swapped;
    end
    assign we_a_temp = we_a_reg;
    assign memory_addr_a_temp = memory_addr_a_reg;
    assign bram_write_temp = bram_write_reg;
    assign din_value_aggregated_swapped_temp = din_value_aggregated_swapped_reg;
  end
  else
  begin
    assign we_a_temp = we_a;
    assign memory_addr_a_temp = memory_addr_a;
    assign bram_write_temp = bram_write;
    assign din_value_aggregated_swapped_temp = din_value_aggregated_swapped;
  end
endgenerate


assign memory_addr_a_0 = memory_addr_a_temp[nbit_read_addr-1:0];
assign memory_addr_a_1 = memory_addr_a_temp[nbit_read_addr*2-1:nbit_read_addr];
assign dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] = dout_a_0;
assign dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] = dout_a_1;
generate
genvar i0_0;
  for (i0_0=0; i0_0&lt;n_byte_on_databus/2; i0_0=i0_0+1)
  begin  : din_0_computation1
    assign din_a_0_temp[(i0_0+1)*8-1:i0_0*8] = we_a_temp[i0_0] ? din_value_aggregated_swapped_temp[(i0_0+1)*8+memory_offset-1:i0_0*8+memory_offset] : memory[memory_addr_a_0][(i0_0+1)*8-1:i0_0*8];
  end
endgenerate

generate
genvar i0_1;
  for (i0_1=0; i0_1&lt;n_byte_on_databus/2; i0_1=i0_1+1)
  begin  : din_1_computation1
    assign din_a_1_temp[(i0_1+1)*8-1:i0_1*8] = we_a_temp[i0_1+n_byte_on_databus/2] ? din_value_aggregated_swapped_temp[2*BRAM_BITSIZE+(i0_1+1)*8+memory_offset-1:2*BRAM_BITSIZE+i0_1*8+memory_offset] : memory[memory_addr_a_1][(i0_1+1)*8-1:i0_1*8];
  end
endgenerate
  
generate
  if (n_mem_elements==1)
  begin : single_element
    always @(posedge clock)
    begin
      if(HIGH_LATENCY == 0)
        dout_a_0  &lt;= memory[memory_addr_a_temp[nbit_read_addr*0+:nbit_read_addr]];
      else
      begin
        dout_a_0_registered  &lt;= memory[memory_addr_a_temp[nbit_read_addr*0+:nbit_read_addr]];
        dout_a_0  &lt;= dout_a_0_registered;
      end
      if(HIGH_LATENCY == 0)
        dout_a_1  &lt;= memory[memory_addr_a_temp[nbit_read_addr*1+:nbit_read_addr]];
      else
      begin
        dout_a_1_registered  &lt;= memory[memory_addr_a_temp[nbit_read_addr*1+:nbit_read_addr]];
        dout_a_1  &lt;= dout_a_1_registered;
      end
      if(READ_ONLY_MEMORY==0)
      begin
      for (index2=0; index2&lt;max_n_writes; index2=index2+1)
      begin : L12_single_write
          for (index1=0; index1&lt;n_byte_on_databus/2; index1=index1+1)
          begin : L11_single_write
            if(we_a_temp[index1+n_byte_on_databus/2*index2])
              memory[memory_addr_a_temp[nbit_read_addr*index2+:nbit_read_addr]][index1*8+:8] &lt;= din_value_aggregated_swapped_temp[2*BRAM_BITSIZE*index2+index1*8+memory_offset+:8];
          end
        end
      end
    end
  end
  else
  begin
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if (bram_write_temp[0])
        begin
          memory[memory_addr_a_0] &lt;= din_a_0_temp;
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_0 &lt;= memory[memory_addr_a_0];
      else
      begin
        dout_a_0_registered &lt;= memory[memory_addr_a_0];
        dout_a_0 &lt;= dout_a_0_registered;
      end
    end
  
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if (bram_write_temp[1])
        begin
          memory[memory_addr_a_1] &lt;= din_a_1_temp;
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_1 &lt;= memory[memory_addr_a_1];
      else
      begin
        dout_a_1_registered &lt;= memory[memory_addr_a_1];
        dout_a_1 &lt;= dout_a_1_registered;
      end
    end
  end
endgenerate

generate
genvar i11, i12;
  for (i12=0; i12&lt;max_n_writes; i12=i12+1)
  begin : L12
    for (i11=0; i11&lt;n_byte_on_databus/2; i11=i11+1)
    begin  : write_enable_a
      assign we_a[i11+(n_byte_on_databus/2)*i12] = bram_write[i12] &amp;&amp; be_swapped[i11+n_byte_on_databus*i12+n_byte_on_databus_offset];
    end
  end
endgenerate
// Add assertion here
// psl default clock = (posedge clock);
// psl ERROR_conflicting_writes: assert never {bram_write[0] &amp;&amp; bram_write[1] &amp;&amp; memory_addr_a[nbit_read_addr*0+:nbit_read_addr] == memory_addr_a[nbit_read_addr*1+:nbit_read_addr] &amp;&amp; (we_a[n_byte_on_databus/2-1:0]&amp;we_a[n_byte_on_databus/2+n_byte_on_databus/2-1:n_byte_on_databus/2]) != 0};"
            VHDL_PROVIDED="signal memory_addr_a_0 : std_logic_vector(nbit_read_addr-1 downto 0);
signal memory_addr_a_1  :  std_logic_vector(nbit_read_addr-1 downto 0);
signal we_a  :  std_logic_vector((n_byte_on_databus/2)*max_n_writes-1 downto 0);
signal din_a_0  :  std_logic_vector(BRAM_BITSIZE-1 downto 0);
signal din_a_1  :  std_logic_vector(BRAM_BITSIZE-1 downto 0);
signal dout_a_0  :  std_logic_vector(BRAM_BITSIZE-1 downto 0);
signal dout_a_1  :  std_logic_vector(BRAM_BITSIZE-1 downto 0);
signal dout_a_0_registered  :  std_logic_vector(BRAM_BITSIZE-1 downto 0);
signal dout_a_1_registered  :  std_logic_vector(BRAM_BITSIZE-1 downto 0);
signal we_a_temp : std_logic_vector((n_byte_on_databus/2)*max_n_writes-1 downto 0);
signal memory_addr_a_temp : std_logic_vector((PORTSIZE_memory_addr_a*BITSIZE_memory_addr_a)+(-1) downto 0);
signal bram_write_temp : std_logic_vector(PORTSIZE_bram_write-1 downto 0);
signal din_value_aggregated_swapped_temp : std_logic_vector((PORTSIZE_din_value_aggregated_swapped*BITSIZE_din_value_aggregated_swapped)+(-1) downto 0);

type mem_type is array (n_mem_elements-1 downto 0) of std_logic_vector(BRAM_BITSIZE-1 downto 0);

impure function InitMemFromFile (MemFileName : in string) return mem_type is
  FILE memfile  :  text open READ_MODE is MemFileName;
  variable MemFileLine  :  line;
  variable mem  :  mem_type;
  begin
     for i in 0 to n_mem_elements-1 loop
      readline(memfile, MemFileLine);
      read(MemFileLine, mem(i));
    end loop;
    return mem;
end function;

signal memory : mem_type := InitMemFromFile(MEMORY_INIT_file);
begin
memory_addr_a_0 &lt;= memory_addr_a_temp(nbit_read_addr-1 downto 0);
memory_addr_a_1 &lt;= memory_addr_a_temp(nbit_read_addr*2-1 downto nbit_read_addr);
dout_a(BRAM_BITSIZE*(0+1)-1 downto BRAM_BITSIZE*0) &lt;= dout_a_0;
dout_a(BRAM_BITSIZE*(1+1)-1 downto BRAM_BITSIZE*1) &lt;= dout_a_1;
input_registration_2 : if HIGH_LATENCY=2 generate
  signal we_a_reg : std_logic_vector((n_byte_on_databus/2)*max_n_writes-1 downto 0);
  signal memory_addr_a_reg : std_logic_vector((PORTSIZE_memory_addr_a*BITSIZE_memory_addr_a)+(-1) downto 0);
  signal bram_write_reg : std_logic_vector(PORTSIZE_bram_write-1 downto 0);
  signal din_value_aggregated_swapped_reg : std_logic_vector((PORTSIZE_din_value_aggregated_swapped*BITSIZE_din_value_aggregated_swapped)+(-1) downto 0);
begin
  in_reg : process(clock)
  begin
    if(clock&apos;event and clock = &apos;1&apos;) then
      we_a_reg &lt;= we_a;
      memory_addr_a_reg &lt;= memory_addr_a;
      bram_write_reg &lt;= bram_write;
      din_value_aggregated_swapped_reg &lt;= din_value_aggregated_swapped;
    end if;
  end process;
  we_a_temp &lt;= we_a_reg;
  memory_addr_a_temp &lt;= memory_addr_a_reg;
  bram_write_temp &lt;= bram_write_reg;
  din_value_aggregated_swapped_temp &lt;= din_value_aggregated_swapped_reg;
end generate input_registration_2 ;
input_registration_01 : if HIGH_LATENCY &lt; 2 generate
begin
  we_a_temp &lt;= we_a;
  memory_addr_a_temp &lt;= memory_addr_a;
  bram_write_temp &lt;= bram_write;
  din_value_aggregated_swapped_temp &lt;= din_value_aggregated_swapped;
end generate input_registration_01 ;

din_0_computation : process(we_a_temp, din_value_aggregated_swapped_temp, memory, memory_addr_a_0)
begin
   for i0_0 in 0 to n_byte_on_databus/2-1 loop
      if(we_a_temp(i0_0) = &apos;1&apos;) then
         din_a_0((i0_0+1)*8-1 downto i0_0*8) &lt;= din_value_aggregated_swapped_temp((i0_0+1)*8+memory_offset-1 downto i0_0*8+memory_offset);
      else
-- synthesis translate_off
         if (to_integer(unsigned(memory_addr_a_0)) &gt;= n_mem_elements) then
            din_a_0((i0_0+1)*8-1 downto i0_0*8) &lt;= (others =&gt; &apos;X&apos;);
         else
-- synthesis translate_on
            din_a_0((i0_0+1)*8-1 downto i0_0*8) &lt;= memory(to_integer(unsigned(memory_addr_a_0)))((i0_0+1)*8-1 downto i0_0*8);
-- synthesis translate_off
         end if;
-- synthesis translate_on
     end if;
   end loop;
end process;
  
din_1_computation : process(we_a_temp, din_value_aggregated_swapped_temp, memory, memory_addr_a_1)
begin
   for i0_1 in 0 to n_byte_on_databus/2-1 loop
      if(we_a_temp(i0_1+n_byte_on_databus/2) = &apos;1&apos;) then
         din_a_1((i0_1+1)*8-1 downto i0_1*8) &lt;= din_value_aggregated_swapped_temp(2*BRAM_BITSIZE+(i0_1+1)*8+memory_offset-1 downto 2*BRAM_BITSIZE+i0_1*8+memory_offset);
      else
-- synthesis translate_off
         if (to_integer(unsigned(memory_addr_a_1)) &gt;= n_mem_elements) then
            din_a_1((i0_1+1)*8-1 downto i0_1*8) &lt;= (others =&gt; &apos;X&apos;);
         else
-- synthesis translate_on
            din_a_1((i0_1+1)*8-1 downto i0_1*8) &lt;= memory(to_integer(unsigned(memory_addr_a_1)))((i0_1+1)*8-1 downto i0_1*8);
-- synthesis translate_off
         end if;
-- synthesis translate_on
      end if;
   end loop;
end process;

single_element : process(clock)
begin
   if(n_mem_elements = 1) then
      if(clock&apos;event and clock = &apos;1&apos;) then
         if(HIGH_LATENCY = 0) then
            dout_a_0  &lt;= memory(to_integer(unsigned(memory_addr_a_temp(nbit_read_addr-1 downto 0))));
         else
            dout_a_0_registered  &lt;= memory(to_integer(unsigned(memory_addr_a_temp(nbit_read_addr-1 downto 0))));
            dout_a_0  &lt;= dout_a_0_registered;
         end if;
         if(HIGH_LATENCY = 0) then
            dout_a_1  &lt;= memory(to_integer(unsigned(memory_addr_a_temp(2*nbit_read_addr-1 downto nbit_read_addr))));
         else
            dout_a_1_registered  &lt;= memory(to_integer(unsigned(memory_addr_a_temp(2*nbit_read_addr-1 downto nbit_read_addr))));
            dout_a_1  &lt;= dout_a_1_registered;
         end if;
         if(READ_ONLY_MEMORY = 0) then
           for index2 in 0 to max_n_writes-1 loop
              for index1 in 0 to n_byte_on_databus/2-1 loop
                 if(we_a_temp(index1+n_byte_on_databus/2*index2)= &apos;1&apos;) then
                    memory(to_integer(unsigned(memory_addr_a_temp(nbit_read_addr*(index2+1)-1 downto nbit_read_addr*index2))))((index1+1)*8-1 downto index1*8) &lt;= din_value_aggregated_swapped_temp(2*BRAM_BITSIZE*index2+index1*8+memory_offset+7 downto 2*BRAM_BITSIZE*index2+index1*8+memory_offset);
                 end if;
              end loop;
           end loop;
         end if;
      end if;
   else
      if(clock&apos;event and clock = &apos;1&apos;) then
         if(READ_ONLY_MEMORY = 0) then
           if (bram_write_temp(0) = &apos;1&apos;) then
-- synthesis translate_off
              if (to_integer(unsigned(memory_addr_a_0)) &lt; n_mem_elements) then
-- synthesis translate_on
                 memory(to_integer(unsigned(memory_addr_a_0))) &lt;= din_a_0;
-- synthesis translate_off
              end if;
-- synthesis translate_on
           end if;
         end if;
         if(HIGH_LATENCY = 0) then
-- synthesis translate_off
            if (to_integer(unsigned(memory_addr_a_0)) &gt;= n_mem_elements) then
               dout_a_0 &lt;= (others =&gt; &apos;X&apos;);
            else
-- synthesis translate_on
               dout_a_0 &lt;= memory(to_integer(unsigned(memory_addr_a_0)));
-- synthesis translate_off
            end if;
-- synthesis translate_on
         else
-- synthesis translate_off
            if (to_integer(unsigned(memory_addr_a_0)) &gt;= n_mem_elements) then
               dout_a_0_registered &lt;= (others =&gt; &apos;X&apos;);
            else
-- synthesis translate_on
               dout_a_0_registered &lt;= memory(to_integer(unsigned(memory_addr_a_0)));
-- synthesis translate_off
            end if;
-- synthesis translate_on
            dout_a_0 &lt;= dout_a_0_registered;
         end if;
         if(READ_ONLY_MEMORY = 0) then
           if (bram_write_temp(1) = &apos;1&apos;) then
-- synthesis translate_off
             if (to_integer(unsigned(memory_addr_a_1)) &lt; n_mem_elements) then
-- synthesis translate_on
               memory(to_integer(unsigned(memory_addr_a_1))) &lt;= din_a_1;
-- synthesis translate_off
             end if;
-- synthesis translate_on
           end if;
         end if;
         if(HIGH_LATENCY = 0) then
-- synthesis translate_off
            if (to_integer(unsigned(memory_addr_a_1)) &gt;= n_mem_elements) then
               dout_a_1 &lt;= (others =&gt; &apos;X&apos;);
            else
-- synthesis translate_on
               dout_a_1 &lt;= memory(to_integer(unsigned(memory_addr_a_1)));
-- synthesis translate_off
            end if;
-- synthesis translate_on
         else
-- synthesis translate_off
            if (to_integer(unsigned(memory_addr_a_1)) &gt;= n_mem_elements) then
               dout_a_1_registered &lt;= (others =&gt; &apos;X&apos;);
            else
-- synthesis translate_on
               dout_a_1_registered &lt;= memory(to_integer(unsigned(memory_addr_a_1)));
-- synthesis translate_off
            end if;
-- synthesis translate_on
            dout_a_1 &lt;= dout_a_1_registered;
         end if;
      end if;
   end if;
end process;

L12 : process(bram_write, be_swapped)
begin
   for i12 in 0 to max_n_writes-1 loop
      for i11 in 0 to (n_byte_on_databus/2)-1 loop
         we_a(i11+(n_byte_on_databus/2)*i12) &lt;= bram_write(i12) and be_swapped(i11+n_byte_on_databus*i12+n_byte_on_databus_offset);
      end loop;
   end loop;
end process;
-- Add assertion here
-- psl default clock is (rising_edge(clock));
-- psl ERROR_conflicting_writes : assert never {bram_write(0) /= &apos;0&apos; and bram_write(1) /= &apos;0&apos; and (memory_addr_a(nbit_read_addr-1 downto 0) = memory_addr_a(2*nbit_read_addr-1 downto nbit_read_addr)) and to_integer(unsigned(we_a(n_byte_on_databus/2-1 downto 0))) /= 0 and to_integer(unsigned(we_a(n_byte_on_databus/2+n_byte_on_databus/2-1 downto n_byte_on_databus/2))) /= 0};
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_SV</name>
      <circuit>
        <component_o id="BRAM_MEMORY_SV">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_SV"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="n_bytes">4</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_SV dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated be MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements n_bytes READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="BRAM_MEMORY_SV_CORE" 
          VERILOG_PROVIDED="
reg bram_write1;
reg [BITSIZE_memory_addr_a-1:0] memory_addr_a1;
reg [BITSIZE_memory_addr_b-1:0] memory_addr_b1;
reg [BITSIZE_be-1:0] be1;
reg [BITSIZE_din_value_aggregated-1:0] din_value_aggregated1;

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       memory_addr_a1 &lt;= memory_addr_a;
       memory_addr_b1 &lt;= memory_addr_b;
       bram_write1 &lt;= bram_write;
       be1 &lt;= be;
       din_value_aggregated1 &lt;= din_value_aggregated;
    end
  end
endgenerate

generate
if(BRAM_BITSIZE == 8)
begin
  reg [(n_byte_on_databus)*8-1:0] dout_a_tmp;
  reg [(n_byte_on_databus)*8-1:0] dout_b_tmp;
  reg [(n_byte_on_databus)*8-1:0] dout_a_registered;
  reg [(n_byte_on_databus)*8-1:0] dout_b_registered;
  reg [(n_byte_on_databus)*8-1:0] memory [0:n_mem_elements-1]/* synthesis syn_ramstyle = &quot;no_rw_check&quot; */ ;
  assign dout_a = dout_a_tmp;
  assign dout_b = dout_b_tmp;
  initial
  begin
    $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
  end


  if(n_mem_elements == 1)
  begin
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write &amp;&amp; be[0])
            memory[memory_addr_a] &lt;= din_value_aggregated[BRAM_BITSIZE-1:0];
        end
        else
        begin
          if (bram_write1 &amp;&amp; be1[0])
            memory[memory_addr_a1] &lt;= din_value_aggregated1[BRAM_BITSIZE-1:0];
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a_tmp &lt;= dout_a_registered;
      end
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write &amp;&amp; be[1])
            memory[memory_addr_b] &lt;= din_value_aggregated[2*BRAM_BITSIZE-1:BRAM_BITSIZE];
        end
        else
        begin
          if (bram_write1 &amp;&amp; be1[1])
            memory[memory_addr_b1] &lt;= din_value_aggregated1[2*BRAM_BITSIZE-1:BRAM_BITSIZE];
        end
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_b];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_b];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_b1];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
  else
  begin
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write &amp;&amp; be[0])
            memory[memory_addr_a] &lt;= din_value_aggregated[BRAM_BITSIZE-1:0];
        end
        else
        begin
          if (bram_write1 &amp;&amp; be1[0])
            memory[memory_addr_a1] &lt;= din_value_aggregated1[BRAM_BITSIZE-1:0];
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a_tmp &lt;= dout_a_registered;
      end
    end
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write &amp;&amp; be[1])
            memory[memory_addr_b] &lt;= din_value_aggregated[2*BRAM_BITSIZE-1:BRAM_BITSIZE];
        end
        else
        begin
          if (bram_write1 &amp;&amp; be1[1])
            memory[memory_addr_b1] &lt;= din_value_aggregated1[2*BRAM_BITSIZE-1:BRAM_BITSIZE];
        end
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_b];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_b];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_b1];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
end
else
begin
  if(n_mem_elements == 1)
  begin
    reg [(n_byte_on_databus)*8-1:0] dout_a_tmp;
    reg [(n_byte_on_databus)*8-1:0] dout_b_tmp;
    reg [(n_byte_on_databus)*8-1:0] dout_a_registered;
    reg [(n_byte_on_databus)*8-1:0] dout_b_registered;
    reg [(n_byte_on_databus)*8-1:0] memory [0:n_mem_elements-1]/* synthesis syn_ramstyle = &quot;no_rw_check&quot; */ ;
    assign dout_a = dout_a_tmp;
    assign dout_b = dout_b_tmp;
    initial
    begin
      $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
    end
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write)
          begin : L11_write
            integer i11;
            for (i11=0; i11&lt;n_byte_on_databus; i11=i11+1)
            begin
              if(be[i11])
                memory[memory_addr_a][i11*8+:8] &lt;= din_value_aggregated[i11*8+:8];
            end
          end
        end
        else
        begin
          if (bram_write1)
          begin : L11_write1
            integer i11;
            for (i11=0; i11&lt;n_byte_on_databus; i11=i11+1)
            begin
              if(be1[i11])
                memory[memory_addr_a1][i11*8+:8] &lt;= din_value_aggregated1[i11*8+:8];
            end
          end
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a_tmp &lt;= dout_a_registered;
      end
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write &amp;&amp; n_bytes &gt; BRAM_BITSIZE/8)
          begin : L22_write
            integer i22;
            for (i22=0; i22&lt;n_byte_on_databus; i22=i22+1)
            begin
              if(be[i22+n_byte_on_databus])
                memory[memory_addr_b][i22*8+:8] &lt;= din_value_aggregated[(i22+n_byte_on_databus)*8+:8];
            end
          end
        end
        else
        begin
          if (bram_write1 &amp;&amp; n_bytes &gt; BRAM_BITSIZE/8)
          begin : L22_write1
            integer i22;
            for (i22=0; i22&lt;n_byte_on_databus; i22=i22+1)
            begin
              if(be1[i22+n_byte_on_databus])
                memory[memory_addr_b1][i22*8+:8] &lt;= din_value_aggregated1[(i22+n_byte_on_databus)*8+:8];
            end
          end
        end
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_b];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_b];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_b1];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
  else
  begin
    BRAM_MEMORY_SV_CORE #(.BITSIZE_memory_addr_a(BITSIZE_memory_addr_a),
  .BITSIZE_memory_addr_b(BITSIZE_memory_addr_b),
  .BITSIZE_din_value_aggregated(BITSIZE_din_value_aggregated),
  .BITSIZE_be(BITSIZE_be),
  .BITSIZE_dout_a(BITSIZE_dout_a),
  .BITSIZE_dout_b(BITSIZE_dout_b),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_CORE_instance (.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));
  end
end
endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_SV_CORE</name>
      <circuit>
        <component_o id="BRAM_MEMORY_SV_CORE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_SV_CORE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="n_bytes">4</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_SV_CORE dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated be MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements n_bytes READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="" SYSTEM_VERILOG_PROVIDED="
reg [BITSIZE_dout_a-1:0] dout_a;
reg [BITSIZE_dout_a-1:0] dout_a_registered;
reg [BITSIZE_dout_b-1:0] dout_b;
reg [BITSIZE_dout_b-1:0] dout_b_registered;
reg [BITSIZE_memory_addr_a-1:0] memory_addr_a1;
reg [BITSIZE_memory_addr_b-1:0] memory_addr_b1;
reg bram_write1;
reg [BITSIZE_be-1:0] be1;
reg [BITSIZE_din_value_aggregated-1:0] din_value_aggregated1;
(* syn_ramstyle = &quot;no_rw_check&quot; *) reg [(BRAM_BITSIZE/8)-1:0][7:0] memory [0:n_mem_elements-1];

initial
begin
  //dout_a=0;  dout_b=0;
  $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
end

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       memory_addr_a1 &lt;= memory_addr_a;
       memory_addr_b1 &lt;= memory_addr_b;
       bram_write1 &lt;= bram_write;
       be1 &lt;= be;
       din_value_aggregated1 &lt;= din_value_aggregated;
    end
  end
endgenerate

generate
  if(n_byte_on_databus==1)
  begin
    always @ (posedge clock)
    begin // Port A
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
        begin
          if (bram_write)
          begin
            if(be[0])
              memory[memory_addr_a][0] &lt;= din_value_aggregated[(0+1)*8-1:0*8];
          end
        end
        else
        begin
          if (bram_write1)
          begin
            if(be1[0])
              memory[memory_addr_a1][0] &lt;= din_value_aggregated1[(0+1)*8-1:0*8];
          end
        end
      end
      if(HIGH_LATENCY==0)
      begin
        dout_a &lt;= memory[memory_addr_a];
      end
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a &lt;= dout_a_registered;
      end
    end
  end
  else if(n_byte_on_databus==2)
  begin
    always @ (posedge clock)
    begin // Port A
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
        begin
          if (bram_write)
          begin
            if(be[0])
              memory[memory_addr_a][0] &lt;= din_value_aggregated[(0+1)*8-1:0*8];
            if(be[1])
              memory[memory_addr_a][1] &lt;= din_value_aggregated[(1+1)*8-1:1*8];
          end
        end
        else
        begin
          if (bram_write1)
          begin
            if(be1[0])
              memory[memory_addr_a1][0] &lt;= din_value_aggregated1[(0+1)*8-1:0*8];
            if(be1[1])
              memory[memory_addr_a1][1] &lt;= din_value_aggregated1[(1+1)*8-1:1*8];
          end
        end
      end
      if(HIGH_LATENCY==0)
      begin
        dout_a &lt;= memory[memory_addr_a];
      end
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a &lt;= dout_a_registered;
      end
    end
  end
  else if(n_byte_on_databus==4)
  begin
    always @ (posedge clock)
    begin // Port A
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
        begin
          if (bram_write)
          begin
            if(be[0])
              memory[memory_addr_a][0] &lt;= din_value_aggregated[(0+1)*8-1:0*8];
            if(be[1])
              memory[memory_addr_a][1] &lt;= din_value_aggregated[(1+1)*8-1:1*8];
            if(be[2])
              memory[memory_addr_a][2] &lt;= din_value_aggregated[(2+1)*8-1:2*8];
            if(be[3])
              memory[memory_addr_a][3] &lt;= din_value_aggregated[(3+1)*8-1:3*8];
          end
        end
        else
        begin
          if (bram_write1)
          begin
            if(be1[0])
              memory[memory_addr_a1][0] &lt;= din_value_aggregated1[(0+1)*8-1:0*8];
            if(be1[1])
              memory[memory_addr_a1][1] &lt;= din_value_aggregated1[(1+1)*8-1:1*8];
            if(be1[2])
              memory[memory_addr_a1][2] &lt;= din_value_aggregated1[(2+1)*8-1:2*8];
            if(be1[3])
              memory[memory_addr_a1][3] &lt;= din_value_aggregated1[(3+1)*8-1:3*8];
          end
        end
      end
      if(HIGH_LATENCY==0)
      begin
        dout_a &lt;= memory[memory_addr_a];
      end
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a &lt;= dout_a_registered;
      end
    end
  end
  else if(n_byte_on_databus==8)
  begin
    always @ (posedge clock)
    begin // Port A
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
        begin
          if (bram_write)
          begin
            if(be[0])
              memory[memory_addr_a][0] &lt;= din_value_aggregated[(0+1)*8-1:0*8];
            if(be[1])
              memory[memory_addr_a][1] &lt;= din_value_aggregated[(1+1)*8-1:1*8];
            if(be[2])
              memory[memory_addr_a][2] &lt;= din_value_aggregated[(2+1)*8-1:2*8];
            if(be[3])
              memory[memory_addr_a][3] &lt;= din_value_aggregated[(3+1)*8-1:3*8];
            if(be[4])
              memory[memory_addr_a][4] &lt;= din_value_aggregated[(4+1)*8-1:4*8];
            if(be[5])
              memory[memory_addr_a][5] &lt;= din_value_aggregated[(5+1)*8-1:5*8];
            if(be[6])
              memory[memory_addr_a][6] &lt;= din_value_aggregated[(6+1)*8-1:6*8];
            if(be[7])
              memory[memory_addr_a][7] &lt;= din_value_aggregated[(7+1)*8-1:7*8];
          end
        end
        else
        begin
          if (bram_write1)
          begin
            if(be1[0])
              memory[memory_addr_a1][0] &lt;= din_value_aggregated1[(0+1)*8-1:0*8];
            if(be1[1])
              memory[memory_addr_a1][1] &lt;= din_value_aggregated1[(1+1)*8-1:1*8];
            if(be1[2])
              memory[memory_addr_a1][2] &lt;= din_value_aggregated1[(2+1)*8-1:2*8];
            if(be1[3])
              memory[memory_addr_a1][3] &lt;= din_value_aggregated1[(3+1)*8-1:3*8];
            if(be1[4])
              memory[memory_addr_a1][4] &lt;= din_value_aggregated1[(4+1)*8-1:4*8];
            if(be1[5])
              memory[memory_addr_a1][5] &lt;= din_value_aggregated1[(5+1)*8-1:5*8];
            if(be1[6])
              memory[memory_addr_a1][6] &lt;= din_value_aggregated1[(6+1)*8-1:6*8];
            if(be1[7])
              memory[memory_addr_a1][7] &lt;= din_value_aggregated1[(7+1)*8-1:7*8];
          end
        end
      end
      if(HIGH_LATENCY==0)
      begin
        dout_a &lt;= memory[memory_addr_a];
      end
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a &lt;= dout_a_registered;
      end
    end
  end
  else if(n_byte_on_databus==16)
  begin
    always @ (posedge clock)
    begin // Port A
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
        begin
          if (bram_write)
          begin
            if(be[0])
              memory[memory_addr_a][0] &lt;= din_value_aggregated[(0+1)*8-1:0*8];
            if(be[1])
              memory[memory_addr_a][1] &lt;= din_value_aggregated[(1+1)*8-1:1*8];
            if(be[2])
              memory[memory_addr_a][2] &lt;= din_value_aggregated[(2+1)*8-1:2*8];
            if(be[3])
              memory[memory_addr_a][3] &lt;= din_value_aggregated[(3+1)*8-1:3*8];
            if(be[4])
              memory[memory_addr_a][4] &lt;= din_value_aggregated[(4+1)*8-1:4*8];
            if(be[5])
              memory[memory_addr_a][5] &lt;= din_value_aggregated[(5+1)*8-1:5*8];
            if(be[6])
              memory[memory_addr_a][6] &lt;= din_value_aggregated[(6+1)*8-1:6*8];
            if(be[7])
              memory[memory_addr_a][7] &lt;= din_value_aggregated[(7+1)*8-1:7*8];
            if(be[8])
              memory[memory_addr_a][8] &lt;= din_value_aggregated[(8+1)*8-1:8*8];
            if(be[9])
              memory[memory_addr_a][9] &lt;= din_value_aggregated[(9+1)*8-1:9*8];
            if(be[10])
              memory[memory_addr_a][10] &lt;= din_value_aggregated[(10+1)*8-1:10*8];
            if(be[11])
              memory[memory_addr_a][11] &lt;= din_value_aggregated[(11+1)*8-1:11*8];
            if(be[12])
              memory[memory_addr_a][12] &lt;= din_value_aggregated[(12+1)*8-1:12*8];
            if(be[13])
              memory[memory_addr_a][13] &lt;= din_value_aggregated[(13+1)*8-1:13*8];
            if(be[14])
              memory[memory_addr_a][14] &lt;= din_value_aggregated[(14+1)*8-1:14*8];
            if(be[15])
              memory[memory_addr_a][15] &lt;= din_value_aggregated[(15+1)*8-1:15*8];
          end
        end
        else
        begin
          if (bram_write1)
          begin
            if(be1[0])
              memory[memory_addr_a1][0] &lt;= din_value_aggregated1[(0+1)*8-1:0*8];
            if(be1[1])
              memory[memory_addr_a1][1] &lt;= din_value_aggregated1[(1+1)*8-1:1*8];
            if(be1[2])
              memory[memory_addr_a1][2] &lt;= din_value_aggregated1[(2+1)*8-1:2*8];
            if(be1[3])
              memory[memory_addr_a1][3] &lt;= din_value_aggregated1[(3+1)*8-1:3*8];
            if(be1[4])
              memory[memory_addr_a1][4] &lt;= din_value_aggregated1[(4+1)*8-1:4*8];
            if(be1[5])
              memory[memory_addr_a1][5] &lt;= din_value_aggregated1[(5+1)*8-1:5*8];
            if(be1[6])
              memory[memory_addr_a1][6] &lt;= din_value_aggregated1[(6+1)*8-1:6*8];
            if(be1[7])
              memory[memory_addr_a1][7] &lt;= din_value_aggregated1[(7+1)*8-1:7*8];
            if(be1[8])
              memory[memory_addr_a1][8] &lt;= din_value_aggregated1[(8+1)*8-1:8*8];
            if(be1[9])
              memory[memory_addr_a1][9] &lt;= din_value_aggregated1[(9+1)*8-1:9*8];
            if(be1[10])
              memory[memory_addr_a1][10] &lt;= din_value_aggregated1[(10+1)*8-1:10*8];
            if(be1[11])
              memory[memory_addr_a1][11] &lt;= din_value_aggregated1[(11+1)*8-1:11*8];
            if(be1[12])
              memory[memory_addr_a1][12] &lt;= din_value_aggregated1[(12+1)*8-1:12*8];
            if(be1[13])
              memory[memory_addr_a1][13] &lt;= din_value_aggregated1[(13+1)*8-1:13*8];
            if(be1[14])
              memory[memory_addr_a1][14] &lt;= din_value_aggregated1[(14+1)*8-1:14*8];
            if(be1[15])
              memory[memory_addr_a1][15] &lt;= din_value_aggregated1[(15+1)*8-1:15*8];
          end
        end
      end
      if(HIGH_LATENCY==0)
      begin
        dout_a &lt;= memory[memory_addr_a];
      end
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a &lt;= dout_a_registered;
      end
    end
  end
endgenerate

generate
  if (n_bytes &gt; BRAM_BITSIZE/8 &amp;&amp; n_byte_on_databus==1)
    begin
      always @ (posedge clock)
      begin // Port B
        if(READ_ONLY_MEMORY==0)
        begin
          if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
          begin
            if (bram_write)
            begin
              if(be[0+n_byte_on_databus])
                memory[memory_addr_b][0] &lt;= din_value_aggregated[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
            end
          end
          else
          begin
            if (bram_write1)
            begin
              if(be1[0+n_byte_on_databus])
                memory[memory_addr_b1][0] &lt;= din_value_aggregated1[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
            end
          end
        end
        if(HIGH_LATENCY==0)
        begin
          dout_b &lt;= memory[memory_addr_b];
        end
        else if(HIGH_LATENCY==1)
        begin
          dout_b_registered &lt;= memory[memory_addr_b];
          dout_b &lt;= dout_b_registered;
        end
        else
        begin
          dout_b_registered &lt;= memory[memory_addr_b1];
          dout_b &lt;= dout_b_registered;
        end
      end
    end
  else if (n_bytes &gt; BRAM_BITSIZE/8 &amp;&amp; n_byte_on_databus==2)
    begin
      always @ (posedge clock)
      begin // Port B
        if(READ_ONLY_MEMORY==0)
        begin
          if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
          begin
            if (bram_write)
            begin
              if(be[0+n_byte_on_databus])
                memory[memory_addr_b][0] &lt;= din_value_aggregated[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
              if(be[1+n_byte_on_databus])
                memory[memory_addr_b][1] &lt;= din_value_aggregated[(1+1+n_byte_on_databus)*8-1:(1+n_byte_on_databus)*8];
            end
          end
          else
          begin
            if (bram_write1)
            begin
              if(be1[0+n_byte_on_databus])
                memory[memory_addr_b1][0] &lt;= din_value_aggregated1[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
              if(be1[1+n_byte_on_databus])
                memory[memory_addr_b1][1] &lt;= din_value_aggregated1[(1+1+n_byte_on_databus)*8-1:(1+n_byte_on_databus)*8];
            end
          end
        end
        if(HIGH_LATENCY==0)
        begin
          dout_b &lt;= memory[memory_addr_b];
        end
        else if(HIGH_LATENCY==1)
        begin
          dout_b_registered &lt;= memory[memory_addr_b];
          dout_b &lt;= dout_b_registered;
        end
        else
        begin
          dout_b_registered &lt;= memory[memory_addr_b1];
          dout_b &lt;= dout_b_registered;
        end
      end
    end
  else if (n_bytes &gt; BRAM_BITSIZE/8 &amp;&amp; n_byte_on_databus==4)
    begin
      always @ (posedge clock)
      begin // Port B
        if(READ_ONLY_MEMORY==0)
        begin
          if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
          begin
            if (bram_write)
            begin
              if(be[0+n_byte_on_databus])
                memory[memory_addr_b][0] &lt;= din_value_aggregated[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
              if(be[1+n_byte_on_databus])
                memory[memory_addr_b][1] &lt;= din_value_aggregated[(1+1+n_byte_on_databus)*8-1:(1+n_byte_on_databus)*8];
              if(be[2+n_byte_on_databus])
                memory[memory_addr_b][2] &lt;= din_value_aggregated[(2+1+n_byte_on_databus)*8-1:(2+n_byte_on_databus)*8];
              if(be[3+n_byte_on_databus])
                memory[memory_addr_b][3] &lt;= din_value_aggregated[(3+1+n_byte_on_databus)*8-1:(3+n_byte_on_databus)*8];
            end
          end
          else
          begin
            if (bram_write1)
            begin
              if(be1[0+n_byte_on_databus])
                memory[memory_addr_b1][0] &lt;= din_value_aggregated1[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
              if(be1[1+n_byte_on_databus])
                memory[memory_addr_b1][1] &lt;= din_value_aggregated1[(1+1+n_byte_on_databus)*8-1:(1+n_byte_on_databus)*8];
              if(be1[2+n_byte_on_databus])
                memory[memory_addr_b1][2] &lt;= din_value_aggregated1[(2+1+n_byte_on_databus)*8-1:(2+n_byte_on_databus)*8];
              if(be1[3+n_byte_on_databus])
                memory[memory_addr_b1][3] &lt;= din_value_aggregated1[(3+1+n_byte_on_databus)*8-1:(3+n_byte_on_databus)*8];
            end
          end
        end
        if(HIGH_LATENCY==0)
        begin
          dout_b &lt;= memory[memory_addr_b];
        end
        else if(HIGH_LATENCY==1)
        begin
          dout_b_registered &lt;= memory[memory_addr_b];
          dout_b &lt;= dout_b_registered;
        end
        else
        begin
          dout_b_registered &lt;= memory[memory_addr_b1];
          dout_b &lt;= dout_b_registered;
        end
      end
    end
  else if (n_bytes &gt; BRAM_BITSIZE/8 &amp;&amp; n_byte_on_databus==8)
    begin
      always @ (posedge clock)
      begin // Port B
        if(READ_ONLY_MEMORY==0)
        begin
          if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
          begin
            if (bram_write)
            begin
              if(be[0+n_byte_on_databus])
                memory[memory_addr_b][0] &lt;= din_value_aggregated[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
              if(be[1+n_byte_on_databus])
                memory[memory_addr_b][1] &lt;= din_value_aggregated[(1+1+n_byte_on_databus)*8-1:(1+n_byte_on_databus)*8];
              if(be[2+n_byte_on_databus])
                memory[memory_addr_b][2] &lt;= din_value_aggregated[(2+1+n_byte_on_databus)*8-1:(2+n_byte_on_databus)*8];
              if(be[3+n_byte_on_databus])
                memory[memory_addr_b][3] &lt;= din_value_aggregated[(3+1+n_byte_on_databus)*8-1:(3+n_byte_on_databus)*8];
              if(be[4+n_byte_on_databus])
                memory[memory_addr_b][4] &lt;= din_value_aggregated[(4+1+n_byte_on_databus)*8-1:(4+n_byte_on_databus)*8];
              if(be[5+n_byte_on_databus])
                memory[memory_addr_b][5] &lt;= din_value_aggregated[(5+1+n_byte_on_databus)*8-1:(5+n_byte_on_databus)*8];
              if(be[6+n_byte_on_databus])
                memory[memory_addr_b][6] &lt;= din_value_aggregated[(6+1+n_byte_on_databus)*8-1:(6+n_byte_on_databus)*8];
              if(be[7+n_byte_on_databus])
                memory[memory_addr_b][7] &lt;= din_value_aggregated[(7+1+n_byte_on_databus)*8-1:(7+n_byte_on_databus)*8];
            end
          end
          else
          begin
            if (bram_write1)
            begin
              if(be1[0+n_byte_on_databus])
                memory[memory_addr_b1][0] &lt;= din_value_aggregated1[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
              if(be1[1+n_byte_on_databus])
                memory[memory_addr_b1][1] &lt;= din_value_aggregated1[(1+1+n_byte_on_databus)*8-1:(1+n_byte_on_databus)*8];
              if(be1[2+n_byte_on_databus])
                memory[memory_addr_b1][2] &lt;= din_value_aggregated1[(2+1+n_byte_on_databus)*8-1:(2+n_byte_on_databus)*8];
              if(be1[3+n_byte_on_databus])
                memory[memory_addr_b1][3] &lt;= din_value_aggregated1[(3+1+n_byte_on_databus)*8-1:(3+n_byte_on_databus)*8];
              if(be1[4+n_byte_on_databus])
                memory[memory_addr_b1][4] &lt;= din_value_aggregated1[(4+1+n_byte_on_databus)*8-1:(4+n_byte_on_databus)*8];
              if(be1[5+n_byte_on_databus])
                memory[memory_addr_b1][5] &lt;= din_value_aggregated1[(5+1+n_byte_on_databus)*8-1:(5+n_byte_on_databus)*8];
              if(be1[6+n_byte_on_databus])
                memory[memory_addr_b1][6] &lt;= din_value_aggregated1[(6+1+n_byte_on_databus)*8-1:(6+n_byte_on_databus)*8];
              if(be1[7+n_byte_on_databus])
                memory[memory_addr_b1][7] &lt;= din_value_aggregated1[(7+1+n_byte_on_databus)*8-1:(7+n_byte_on_databus)*8];
            end
          end
        end
        if(HIGH_LATENCY==0)
        begin
          dout_b &lt;= memory[memory_addr_b];
        end
        else if(HIGH_LATENCY==1)
        begin
          dout_b_registered &lt;= memory[memory_addr_b];
          dout_b &lt;= dout_b_registered;
        end
        else
        begin
          dout_b_registered &lt;= memory[memory_addr_b1];
          dout_b &lt;= dout_b_registered;
        end
      end
    end
  else if (n_bytes &gt; BRAM_BITSIZE/8 &amp;&amp; n_byte_on_databus==16)
    begin
      always @ (posedge clock)
      begin // Port B
        if(READ_ONLY_MEMORY==0)
        begin
          if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
          begin
            if (bram_write)
            begin
              if(be[0+n_byte_on_databus])
                memory[memory_addr_b][0] &lt;= din_value_aggregated[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
              if(be[1+n_byte_on_databus])
                memory[memory_addr_b][1] &lt;= din_value_aggregated[(1+1+n_byte_on_databus)*8-1:(1+n_byte_on_databus)*8];
              if(be[2+n_byte_on_databus])
                memory[memory_addr_b][2] &lt;= din_value_aggregated[(2+1+n_byte_on_databus)*8-1:(2+n_byte_on_databus)*8];
              if(be[3+n_byte_on_databus])
                memory[memory_addr_b][3] &lt;= din_value_aggregated[(3+1+n_byte_on_databus)*8-1:(3+n_byte_on_databus)*8];
              if(be[4+n_byte_on_databus])
                memory[memory_addr_b][4] &lt;= din_value_aggregated[(4+1+n_byte_on_databus)*8-1:(4+n_byte_on_databus)*8];
              if(be[5+n_byte_on_databus])
                memory[memory_addr_b][5] &lt;= din_value_aggregated[(5+1+n_byte_on_databus)*8-1:(5+n_byte_on_databus)*8];
              if(be[6+n_byte_on_databus])
                memory[memory_addr_b][6] &lt;= din_value_aggregated[(6+1+n_byte_on_databus)*8-1:(6+n_byte_on_databus)*8];
              if(be[7+n_byte_on_databus])
                memory[memory_addr_b][7] &lt;= din_value_aggregated[(7+1+n_byte_on_databus)*8-1:(7+n_byte_on_databus)*8];
              if(be[8+n_byte_on_databus])
                memory[memory_addr_b][8] &lt;= din_value_aggregated[(8+1+n_byte_on_databus)*8-1:(8+n_byte_on_databus)*8];
              if(be[9+n_byte_on_databus])
                memory[memory_addr_b][9] &lt;= din_value_aggregated[(9+1+n_byte_on_databus)*8-1:(9+n_byte_on_databus)*8];
              if(be[10+n_byte_on_databus])
                memory[memory_addr_b][10] &lt;= din_value_aggregated[(10+1+n_byte_on_databus)*8-1:(10+n_byte_on_databus)*8];
              if(be[11+n_byte_on_databus])
                memory[memory_addr_b][11] &lt;= din_value_aggregated[(11+1+n_byte_on_databus)*8-1:(11+n_byte_on_databus)*8];
              if(be[12+n_byte_on_databus])
                memory[memory_addr_b][12] &lt;= din_value_aggregated[(12+1+n_byte_on_databus)*8-1:(12+n_byte_on_databus)*8];
              if(be[13+n_byte_on_databus])
                memory[memory_addr_b][13] &lt;= din_value_aggregated[(13+1+n_byte_on_databus)*8-1:(13+n_byte_on_databus)*8];
              if(be[14+n_byte_on_databus])
                memory[memory_addr_b][14] &lt;= din_value_aggregated[(14+1+n_byte_on_databus)*8-1:(14+n_byte_on_databus)*8];
              if(be[15+n_byte_on_databus])
                memory[memory_addr_b][15] &lt;= din_value_aggregated[(15+1+n_byte_on_databus)*8-1:(15+n_byte_on_databus)*8];
            end
          end
          else
          begin
            if (bram_write1)
            begin
              if(be1[0+n_byte_on_databus])
                memory[memory_addr_b1][0] &lt;= din_value_aggregated1[(0+1+n_byte_on_databus)*8-1:(0+n_byte_on_databus)*8];
              if(be1[1+n_byte_on_databus])
                memory[memory_addr_b1][1] &lt;= din_value_aggregated1[(1+1+n_byte_on_databus)*8-1:(1+n_byte_on_databus)*8];
              if(be1[2+n_byte_on_databus])
                memory[memory_addr_b1][2] &lt;= din_value_aggregated1[(2+1+n_byte_on_databus)*8-1:(2+n_byte_on_databus)*8];
              if(be1[3+n_byte_on_databus])
                memory[memory_addr_b1][3] &lt;= din_value_aggregated1[(3+1+n_byte_on_databus)*8-1:(3+n_byte_on_databus)*8];
              if(be1[4+n_byte_on_databus])
                memory[memory_addr_b1][4] &lt;= din_value_aggregated1[(4+1+n_byte_on_databus)*8-1:(4+n_byte_on_databus)*8];
              if(be1[5+n_byte_on_databus])
                memory[memory_addr_b1][5] &lt;= din_value_aggregated1[(5+1+n_byte_on_databus)*8-1:(5+n_byte_on_databus)*8];
              if(be1[6+n_byte_on_databus])
                memory[memory_addr_b1][6] &lt;= din_value_aggregated1[(6+1+n_byte_on_databus)*8-1:(6+n_byte_on_databus)*8];
              if(be1[7+n_byte_on_databus])
                memory[memory_addr_b1][7] &lt;= din_value_aggregated1[(7+1+n_byte_on_databus)*8-1:(7+n_byte_on_databus)*8];
              if(be1[8+n_byte_on_databus])
                memory[memory_addr_b1][8] &lt;= din_value_aggregated1[(8+1+n_byte_on_databus)*8-1:(8+n_byte_on_databus)*8];
              if(be1[9+n_byte_on_databus])
                memory[memory_addr_b1][9] &lt;= din_value_aggregated1[(9+1+n_byte_on_databus)*8-1:(9+n_byte_on_databus)*8];
              if(be1[10+n_byte_on_databus])
                memory[memory_addr_b1][10] &lt;= din_value_aggregated1[(10+1+n_byte_on_databus)*8-1:(10+n_byte_on_databus)*8];
              if(be1[11+n_byte_on_databus])
                memory[memory_addr_b1][11] &lt;= din_value_aggregated1[(11+1+n_byte_on_databus)*8-1:(11+n_byte_on_databus)*8];
              if(be1[12+n_byte_on_databus])
                memory[memory_addr_b1][12] &lt;= din_value_aggregated1[(12+1+n_byte_on_databus)*8-1:(12+n_byte_on_databus)*8];
              if(be1[13+n_byte_on_databus])
                memory[memory_addr_b1][13] &lt;= din_value_aggregated1[(13+1+n_byte_on_databus)*8-1:(13+n_byte_on_databus)*8];
              if(be1[14+n_byte_on_databus])
                memory[memory_addr_b1][14] &lt;= din_value_aggregated1[(14+1+n_byte_on_databus)*8-1:(14+n_byte_on_databus)*8];
              if(be1[15+n_byte_on_databus])
                memory[memory_addr_b1][15] &lt;= din_value_aggregated1[(15+1+n_byte_on_databus)*8-1:(15+n_byte_on_databus)*8];
            end
          end
        end
        if(HIGH_LATENCY==0)
        begin
          dout_b &lt;= memory[memory_addr_b];
        end
        else if(HIGH_LATENCY==1)
        begin
          dout_b_registered &lt;= memory[memory_addr_b];
          dout_b &lt;= dout_b_registered;
        end
        else
        begin
          dout_b_registered &lt;= memory[memory_addr_b1];
          dout_b &lt;= dout_b_registered;
        end
      end
    end
  else
    always @(clock) dout_b = {BRAM_BITSIZE{1&apos;b0}};
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_NN_SV</name>
      <circuit>
        <component_o id="BRAM_MEMORY_NN_SV">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_NN_SV"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="max_n_reads">2</parameter>
          <parameter name="max_n_writes">2</parameter>
          <parameter name="memory_offset">16</parameter>
          <parameter name="n_byte_on_databus_offset">2</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_vector_o>
          <port_vector_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value_aggregated_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="be_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_NN_SV bram_write dout_a memory_addr_a din_value_aggregated_swapped be_swapped MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements max_n_reads max_n_writes memory_offset n_byte_on_databus_offset READ_ONLY_MEMORY HIGH_LATENCY" IP_COMPONENT="BRAM_MEMORY_NN_SV_CORE" VERILOG_PROVIDED="
reg [PORTSIZE_bram_write-1:0] bram_write1;
reg [(PORTSIZE_memory_addr_a*BITSIZE_memory_addr_a)+(-1):0] memory_addr_a1;
reg [(PORTSIZE_din_value_aggregated_swapped*BITSIZE_din_value_aggregated_swapped)+(-1):0] din_value_aggregated_swapped1;
reg [(PORTSIZE_be_swapped*BITSIZE_be_swapped)+(-1):0] be_swapped1;

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       memory_addr_a1 &lt;= memory_addr_a;
       bram_write1 &lt;= bram_write;
       be_swapped1 &lt;= be_swapped;
       din_value_aggregated_swapped1 &lt;= din_value_aggregated_swapped;
    end
  end
endgenerate


generate
if(BRAM_BITSIZE == 8)
begin
  reg [(n_byte_on_databus/2)*8-1:0] dout_a_tmp;
  reg [(n_byte_on_databus/2)*8-1:0] dout_b_tmp;
  reg [(n_byte_on_databus/2)*8-1:0] dout_a_registered;
  reg [(n_byte_on_databus/2)*8-1:0] dout_b_registered;
  reg [(n_byte_on_databus/2)*8-1:0] memory [0:n_mem_elements-1]/* synthesis syn_ramstyle = &quot;no_rw_check&quot; */ ;
  assign dout_a[BRAM_BITSIZE-1:0] = dout_a_tmp;
  assign dout_a[2*BRAM_BITSIZE-1:BRAM_BITSIZE] = dout_b_tmp;
  initial
  begin
    $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
  end
  if(n_mem_elements == 1)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write[0] &amp;&amp; be_swapped[n_byte_on_databus_offset])
          memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]] &lt;= din_value_aggregated_swapped[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset];
      end
      else
      begin
        if (bram_write1[0] &amp;&amp; be_swapped1[n_byte_on_databus_offset])
          memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]] &lt;= din_value_aggregated_swapped1[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset];
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write[1] &amp;&amp; be_swapped[n_byte_on_databus+n_byte_on_databus_offset])
          memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset];
      end
      else
      begin
        if (bram_write1[1] &amp;&amp; be_swapped1[n_byte_on_databus+n_byte_on_databus_offset])
          memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset];
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
  else
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write[0] &amp;&amp; be_swapped[n_byte_on_databus_offset])
          memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]] &lt;= din_value_aggregated_swapped[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset];
      end
      else
      begin
        if (bram_write1[0] &amp;&amp; be_swapped1[n_byte_on_databus_offset])
          memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]] &lt;= din_value_aggregated_swapped1[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset];
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
    end
    always @(posedge clock)
    begin
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write[1] &amp;&amp; be_swapped[n_byte_on_databus+n_byte_on_databus_offset])
          memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset];
      end
      else
      begin
        if (bram_write1[1] &amp;&amp; be_swapped1[n_byte_on_databus+n_byte_on_databus_offset])
          memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset];
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
end
else
begin
  if(n_mem_elements == 1)
  begin
    reg [(n_byte_on_databus/2)*8-1:0] dout_a_tmp;
    reg [(n_byte_on_databus/2)*8-1:0] dout_b_tmp;
    reg [(n_byte_on_databus/2)*8-1:0] dout_a_registered;
    reg [(n_byte_on_databus/2)*8-1:0] dout_b_registered;
    reg [(n_byte_on_databus/2)*8-1:0] memory [0:n_mem_elements-1]/* synthesis syn_ramstyle = &quot;no_rw_check&quot; */ ;
    assign dout_a[BRAM_BITSIZE-1:0] = dout_a_tmp;
    assign dout_a[2*BRAM_BITSIZE-1:BRAM_BITSIZE] = dout_b_tmp;
    initial
    begin
      $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
    end
    always @(posedge clock)
    begin
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write[0])
        begin : L11_write
          integer i11;
          for (i11=0; i11&lt;n_byte_on_databus/2; i11=i11+1)
          begin
            if(be_swapped[i11+n_byte_on_databus_offset])
              memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]][i11*8+:8] &lt;= din_value_aggregated_swapped[i11*8+memory_offset+:8];
          end
        end
      end
      else
      begin
        if (bram_write1[0])
        begin : L11_write1
          integer i11;
          for (i11=0; i11&lt;n_byte_on_databus/2; i11=i11+1)
          begin
            if(be_swapped1[i11+n_byte_on_databus_offset])
              memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]][i11*8+:8] &lt;= din_value_aggregated_swapped1[i11*8+memory_offset+:8];
          end
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write[1])
        begin : L22_write
          integer i22;
          for (i22=0; i22&lt;n_byte_on_databus/2; i22=i22+1)
          begin
            if(be_swapped[i22+n_byte_on_databus+n_byte_on_databus_offset])
              memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]][i22*8+:8] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE+memory_offset+i22*8+:8];
          end
        end
      end
      else
      begin
        if (bram_write1[1])
        begin : L22_write1
          integer i22;
          for (i22=0; i22&lt;n_byte_on_databus/2; i22=i22+1)
          begin
            if(be_swapped1[i22+n_byte_on_databus+n_byte_on_databus_offset])
              memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]][i22*8+:8] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE+memory_offset+i22*8+:8];
          end
        end
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
  else
    BRAM_MEMORY_NN_SV_CORE #(.PORTSIZE_bram_write(PORTSIZE_bram_write),
  .BITSIZE_bram_write(BITSIZE_bram_write),
  .BITSIZE_dout_a(BITSIZE_dout_a),
  .PORTSIZE_dout_a(PORTSIZE_dout_a),
  .BITSIZE_memory_addr_a(BITSIZE_memory_addr_a),
  .PORTSIZE_memory_addr_a(PORTSIZE_memory_addr_a),
  .BITSIZE_din_value_aggregated_swapped(BITSIZE_din_value_aggregated_swapped),
  .PORTSIZE_din_value_aggregated_swapped(PORTSIZE_din_value_aggregated_swapped),
  .BITSIZE_be_swapped(BITSIZE_be_swapped),
  .PORTSIZE_be_swapped(PORTSIZE_be_swapped),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(memory_offset),
  .n_byte_on_databus_offset(n_byte_on_databus_offset),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_NN_CORE_instance_a(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_a));

end
endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_NN_SV_CORE</name>
      <circuit>
        <component_o id="BRAM_MEMORY_NN_SV_CORE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_NN_SV_CORE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="max_n_reads">2</parameter>
          <parameter name="max_n_writes">2</parameter>
          <parameter name="memory_offset">16</parameter>
          <parameter name="n_byte_on_databus_offset">2</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_vector_o>
          <port_vector_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value_aggregated_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="be_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_NN_SV_CORE bram_write dout_a memory_addr_a din_value_aggregated_swapped be_swapped MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements max_n_reads max_n_writes memory_offset n_byte_on_databus_offset READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="" SYSTEM_VERILOG_PROVIDED="
wire [(n_byte_on_databus/2)*max_n_writes-1:0] we_a;
reg [PORTSIZE_dout_a*BITSIZE_dout_a-1:0] dout_a;
reg [PORTSIZE_dout_a*BITSIZE_dout_a-1:0] dout_a_registered;
reg [(PORTSIZE_memory_addr_a*BITSIZE_memory_addr_a)+(-1):0] memory_addr_a1;
reg [(PORTSIZE_din_value_aggregated_swapped*BITSIZE_din_value_aggregated_swapped)+(-1):0] din_value_aggregated_swapped1;
reg [(n_byte_on_databus/2)*max_n_writes-1:0] we_a1;

(* syn_ramstyle = &quot;no_rw_check&quot; *) reg [(BRAM_BITSIZE/8)-1:0][7:0] memory_a [0:n_mem_elements-1];
initial
begin
  $readmemb(MEMORY_INIT_file, memory_a, 0, n_mem_elements-1);
end

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       memory_addr_a1 &lt;= memory_addr_a;
       we_a1 &lt;= we_a;
       din_value_aggregated_swapped1 &lt;= din_value_aggregated_swapped;
    end
  end
endgenerate

generate
  if(n_byte_on_databus==2)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
    end
  end
  else if(n_byte_on_databus==4)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
        if(we_a[1+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][1] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+1*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
        if(we_a1[1+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][1] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+1*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
    end
  end
  else if(n_byte_on_databus==8)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
        if(we_a[1+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][1] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+1*8+memory_offset];
        if(we_a[2+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][2] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+2*8+memory_offset];
        if(we_a[3+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][3] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+3*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
        if(we_a1[1+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][1] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+1*8+memory_offset];
        if(we_a1[2+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][2] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+2*8+memory_offset];
        if(we_a1[3+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][3] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+3*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
    end
  end
  else if(n_byte_on_databus==16)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
        if(we_a[1+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][1] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+1*8+memory_offset];
        if(we_a[2+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][2] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+2*8+memory_offset];
        if(we_a[3+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][3] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+3*8+memory_offset];
        if(we_a[4+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][4] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(4+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+4*8+memory_offset];
        if(we_a[5+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][5] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(5+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+5*8+memory_offset];
        if(we_a[6+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][6] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(6+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+6*8+memory_offset];
        if(we_a[7+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][7] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(7+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+7*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
        if(we_a1[1+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][1] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+1*8+memory_offset];
        if(we_a1[2+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][2] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+2*8+memory_offset];
        if(we_a1[3+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][3] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+3*8+memory_offset];
        if(we_a1[4+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][4] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(4+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+4*8+memory_offset];
        if(we_a1[5+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][5] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(5+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+5*8+memory_offset];
        if(we_a1[6+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][6] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(6+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+6*8+memory_offset];
        if(we_a1[7+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][7] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(7+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+7*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
    end
  end
  else if(n_byte_on_databus==32)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
        if(we_a[1+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][1] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+1*8+memory_offset];
        if(we_a[2+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][2] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+2*8+memory_offset];
        if(we_a[3+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][3] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+3*8+memory_offset];
        if(we_a[4+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][4] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(4+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+4*8+memory_offset];
        if(we_a[5+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][5] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(5+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+5*8+memory_offset];
        if(we_a[6+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][6] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(6+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+6*8+memory_offset];
        if(we_a[7+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][7] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(7+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+7*8+memory_offset];
        if(we_a[8+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][8] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(8+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+8*8+memory_offset];
        if(we_a[9+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][9] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(9+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+9*8+memory_offset];
        if(we_a[10+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][10] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(10+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+10*8+memory_offset];
        if(we_a[11+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][11] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(11+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+11*8+memory_offset];
        if(we_a[12+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][12] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(12+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+12*8+memory_offset];
        if(we_a[13+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][13] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(13+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+13*8+memory_offset];
        if(we_a[14+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][14] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(14+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+14*8+memory_offset];
        if(we_a[15+n_byte_on_databus/2*0])
          memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][15] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*0+(15+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+15*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+0*8+memory_offset];
        if(we_a1[1+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][1] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+1*8+memory_offset];
        if(we_a1[2+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][2] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+2*8+memory_offset];
        if(we_a1[3+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][3] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+3*8+memory_offset];
        if(we_a1[4+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][4] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(4+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+4*8+memory_offset];
        if(we_a1[5+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][5] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(5+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+5*8+memory_offset];
        if(we_a1[6+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][6] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(6+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+6*8+memory_offset];
        if(we_a1[7+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][7] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(7+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+7*8+memory_offset];
        if(we_a1[8+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][8] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(8+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+8*8+memory_offset];
        if(we_a1[9+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][9] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(9+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+9*8+memory_offset];
        if(we_a1[10+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][10] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(10+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+10*8+memory_offset];
        if(we_a1[11+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][11] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(11+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+11*8+memory_offset];
        if(we_a1[12+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][12] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(12+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+12*8+memory_offset];
        if(we_a1[13+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][13] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(13+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+13*8+memory_offset];
        if(we_a1[14+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][14] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(14+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+14*8+memory_offset];
        if(we_a1[15+n_byte_on_databus/2*0])
          memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]][15] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*0+(15+1)*8+memory_offset-1:2*BRAM_BITSIZE*0+15*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(0+1)-1:nbit_read_addr*0]];
        dout_a[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0] &lt;= dout_a_registered[BRAM_BITSIZE*(0+1)-1:BRAM_BITSIZE*0];
      end
    end
  end
endgenerate

generate
  if(n_byte_on_databus==2)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
    end
  end
  else if(n_byte_on_databus==4)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
        if(we_a[1+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][1] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+1*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
        if(we_a1[1+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][1] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+1*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
    end
  end
  else if(n_byte_on_databus==8)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
        if(we_a[1+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][1] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+1*8+memory_offset];
        if(we_a[2+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][2] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+2*8+memory_offset];
        if(we_a[3+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][3] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+3*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
        if(we_a1[1+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][1] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+1*8+memory_offset];
        if(we_a1[2+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][2] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+2*8+memory_offset];
        if(we_a1[3+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][3] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+3*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
    end
  end
  else if(n_byte_on_databus==16)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
        if(we_a[1+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][1] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+1*8+memory_offset];
        if(we_a[2+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][2] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+2*8+memory_offset];
        if(we_a[3+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][3] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+3*8+memory_offset];
        if(we_a[4+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][4] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(4+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+4*8+memory_offset];
        if(we_a[5+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][5] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(5+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+5*8+memory_offset];
        if(we_a[6+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][6] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(6+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+6*8+memory_offset];
        if(we_a[7+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][7] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(7+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+7*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
        if(we_a1[1+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][1] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+1*8+memory_offset];
        if(we_a1[2+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][2] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+2*8+memory_offset];
        if(we_a1[3+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][3] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+3*8+memory_offset];
        if(we_a1[4+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][4] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(4+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+4*8+memory_offset];
        if(we_a1[5+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][5] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(5+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+5*8+memory_offset];
        if(we_a1[6+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][6] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(6+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+6*8+memory_offset];
        if(we_a1[7+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][7] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(7+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+7*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
    end
  end
  else if(n_byte_on_databus==32)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY==0 || HIGH_LATENCY==1)
      begin
        if(we_a[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
        if(we_a[1+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][1] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+1*8+memory_offset];
        if(we_a[2+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][2] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+2*8+memory_offset];
        if(we_a[3+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][3] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+3*8+memory_offset];
        if(we_a[4+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][4] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(4+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+4*8+memory_offset];
        if(we_a[5+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][5] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(5+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+5*8+memory_offset];
        if(we_a[6+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][6] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(6+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+6*8+memory_offset];
        if(we_a[7+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][7] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(7+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+7*8+memory_offset];
        if(we_a[8+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][8] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(8+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+8*8+memory_offset];
        if(we_a[9+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][9] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(9+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+9*8+memory_offset];
        if(we_a[10+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][10] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(10+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+10*8+memory_offset];
        if(we_a[11+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][11] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(11+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+11*8+memory_offset];
        if(we_a[12+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][12] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(12+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+12*8+memory_offset];
        if(we_a[13+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][13] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(13+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+13*8+memory_offset];
        if(we_a[14+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][14] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(14+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+14*8+memory_offset];
        if(we_a[15+n_byte_on_databus/2*1])
          memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][15] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE*1+(15+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+15*8+memory_offset];
      end
      else
      begin
        if(we_a1[0+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][0] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(0+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+0*8+memory_offset];
        if(we_a1[1+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][1] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(1+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+1*8+memory_offset];
        if(we_a1[2+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][2] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(2+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+2*8+memory_offset];
        if(we_a1[3+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][3] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(3+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+3*8+memory_offset];
        if(we_a1[4+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][4] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(4+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+4*8+memory_offset];
        if(we_a1[5+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][5] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(5+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+5*8+memory_offset];
        if(we_a1[6+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][6] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(6+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+6*8+memory_offset];
        if(we_a1[7+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][7] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(7+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+7*8+memory_offset];
        if(we_a1[8+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][8] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(8+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+8*8+memory_offset];
        if(we_a1[9+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][9] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(9+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+9*8+memory_offset];
        if(we_a1[10+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][10] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(10+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+10*8+memory_offset];
        if(we_a1[11+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][11] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(11+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+11*8+memory_offset];
        if(we_a1[12+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][12] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(12+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+12*8+memory_offset];
        if(we_a1[13+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][13] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(13+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+13*8+memory_offset];
        if(we_a1[14+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][14] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(14+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+14*8+memory_offset];
        if(we_a1[15+n_byte_on_databus/2*1])
          memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]][15] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE*1+(15+1)*8+memory_offset-1:2*BRAM_BITSIZE*1+15*8+memory_offset];
      end
      if(HIGH_LATENCY==0)
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
      else if(HIGH_LATENCY==1)
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
      else
      begin
        dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= memory_a[memory_addr_a1[nbit_read_addr*(1+1)-1:nbit_read_addr*1]];
        dout_a[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1] &lt;= dout_a_registered[BRAM_BITSIZE*(1+1)-1:BRAM_BITSIZE*1];
      end
    end
  end
endgenerate
  
generate
genvar i11, i12;
  for (i12=0; i12&lt;max_n_writes; i12=i12+1)
  begin : L12
    for (i11=0; i11&lt;n_byte_on_databus/2; i11=i11+1)
    begin  : write_enable_a
      assign we_a[i11+(n_byte_on_databus/2)*i12] = bram_write[i12] &amp;&amp; be_swapped[i11+n_byte_on_databus*i12+n_byte_on_databus_offset];
    end
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_TP</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_TP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_TP"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> arrary address </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element loaded or stored </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_TP in1 in2 in3 out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_out1" IP_COMPONENT="ADDRESS_DECODING_LOGIC,BRAM_MEMORY_TP" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8 == 0 ? 1 : (n_elements*data_size)/8;
parameter n_byte_on_databus = BRAM_BITSIZE/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
  
wire [nbit_read_addr-1:0] memory_addr_a;
wire [nbit_read_addr-1:0] memory_addr_b;
wire [n_byte_on_databus*2-1:0] be;

wire [2*BRAM_BITSIZE-1:0] din_value_aggregated;
wire bram_write;
wire [BRAM_BITSIZE-1:0] dout_a;
wire [BRAM_BITSIZE-1:0] dout_b;

BRAM_MEMORY_TP #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_instance (.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));

ADDRESS_DECODING_LOGIC #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .HIGH_LATENCY(HIGH_LATENCY)) ADDRESS_DECODING_LOGIC_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_N1_TP</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_N1_TP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_N1_TP"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_N1_TP in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1 HIGH_LATENCY" 
          IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_TP" 
          VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_NN_TP #(
  .BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(1),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(1),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(1),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(1),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(1),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(1),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(1),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(1),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(1),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1)) ARRAY_1D_STD_BRAM_NN_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size ),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_NN_TP</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_NN_TP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_NN_TP"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> arrary address </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element loaded or stored </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_NN_TP in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1" IP_COMPONENT="ADDRESS_DECODING_LOGIC_NN,BRAM_MEMORY_NN_TP" VERILOG_PROVIDED="
`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8 == 0 ? 1 : (n_elements*data_size)/8;
parameter memory_bitsize = 2*BRAM_BITSIZE;
parameter n_byte_on_databus = memory_bitsize/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
parameter max_n_writes = PORTSIZE_sel_STORE &gt; PORTSIZE_S_we_ram ? PORTSIZE_sel_STORE : PORTSIZE_S_we_ram;
parameter max_n_reads = PORTSIZE_sel_LOAD &gt; PORTSIZE_S_oe_ram ? PORTSIZE_sel_LOAD : PORTSIZE_S_oe_ram;
parameter max_n_rw = max_n_writes &gt; max_n_reads ? max_n_writes : max_n_reads;

wire [max_n_writes-1:0] bram_write;

wire [nbit_read_addr*max_n_rw-1:0] memory_addr_a;
wire [nbit_read_addr*max_n_rw-1:0] memory_addr_b;
wire [n_byte_on_databus*max_n_writes-1:0] be_swapped;

wire [memory_bitsize*max_n_writes-1:0] din_value_aggregated_swapped;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_a;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_b;


BRAM_MEMORY_NN_TP #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_a),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(0),
  .n_byte_on_databus_offset(0)) BRAM_MEMORY_NN_instance_a(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_a));

generate
  if (n_bytes &gt; BRAM_BITSIZE/8)
  begin : SECOND_MEMORY
    BRAM_MEMORY_NN_TP #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a((memory_bitsize/2)),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_b),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(memory_bitsize/2),
  .n_byte_on_databus_offset(n_byte_on_databus/2)) BRAM_MEMORY_NN_instance_b(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_b));
  end
else
  assign dout_b = {(memory_bitsize/2)*max_n_reads{1&apos;b0}};
endgenerate

ADDRESS_DECODING_LOGIC_NN #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_dout_b(memory_bitsize/2),
  .PORTSIZE_dout_b(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .PORTSIZE_memory_addr_b(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .BITSIZE_bram_write(1),
  .PORTSIZE_bram_write(max_n_writes),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .max_n_rw(max_n_rw)) ADDRESS_DECODING_LOGIC_NN_instance (.clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .out1(out1),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .proxy_out1(proxy_out1),
  .dout_a(dout_a),
  .dout_b(dout_b),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .bram_write(bram_write));"
            VHDL_PROVIDED="function integer_ternary_operator(cond : boolean; op1 : integer; op2 : integer) return integer is
   begin
      if cond then
         return op1;
      else
         return op2;
      end if;
   end integer_ternary_operator;
constant n_bytes           : integer := integer_ternary_operator((n_elements*data_size)/8 = 0, 1, (n_elements*data_size)/8);
constant memory_bitsize    : integer := 2*BRAM_BITSIZE;
constant n_byte_on_databus : integer := memory_bitsize/8;
constant n_mem_elements    : integer := n_bytes/n_byte_on_databus + integer_ternary_operator((n_bytes mod n_byte_on_databus) = 0, 0, 1);
constant nbit_read_addr    : integer := integer_ternary_operator(n_mem_elements = 1, 1, integer(ceil(log2(real(n_mem_elements)))));
constant max_n_writes      : integer := integer_ternary_operator(PORTSIZE_sel_STORE &gt; PORTSIZE_S_we_ram, PORTSIZE_sel_STORE, PORTSIZE_S_we_ram);
constant max_n_reads       : integer := integer_ternary_operator(PORTSIZE_sel_LOAD &gt; PORTSIZE_S_oe_ram, PORTSIZE_sel_LOAD, PORTSIZE_S_oe_ram);
constant max_n_rw          : integer := integer_ternary_operator(max_n_writes &gt; max_n_reads, max_n_writes, max_n_reads);

signal bram_write : std_logic_vector(max_n_writes-1 downto 0);

signal memory_addr_a : std_logic_vector(nbit_read_addr*max_n_rw-1 downto 0);
signal memory_addr_b : std_logic_vector(nbit_read_addr*max_n_rw-1 downto 0);
signal be_swapped    : std_logic_vector(n_byte_on_databus*max_n_writes-1 downto 0);

signal din_value_aggregated_swapped : std_logic_vector(memory_bitsize*max_n_writes-1 downto 0);
signal dout_a : std_logic_vector((memory_bitsize/2)*max_n_reads-1 downto 0);
signal dout_b : std_logic_vector((memory_bitsize/2)*max_n_reads-1 downto 0);

begin
BRAM_MEMORY_NN_instance_a : BRAM_MEMORY_NN_TP generic map (PORTSIZE_bram_write=&gt;max_n_writes, BITSIZE_bram_write=&gt;1, BITSIZE_dout_a=&gt;memory_bitsize/2, PORTSIZE_dout_a=&gt;max_n_reads, BITSIZE_memory_addr_a=&gt;nbit_read_addr, PORTSIZE_memory_addr_a=&gt;max_n_rw, BITSIZE_din_value_aggregated_swapped=&gt;memory_bitsize, PORTSIZE_din_value_aggregated_swapped=&gt;max_n_writes, BITSIZE_be_swapped=&gt;n_byte_on_databus, PORTSIZE_be_swapped=&gt;max_n_writes, MEMORY_INIT_file=&gt;MEMORY_INIT_file_a, BRAM_BITSIZE=&gt;BRAM_BITSIZE, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, HIGH_LATENCY=&gt;HIGH_LATENCY, nbit_read_addr=&gt;nbit_read_addr, n_byte_on_databus=&gt;n_byte_on_databus, n_mem_elements=&gt;n_mem_elements, max_n_reads=&gt;max_n_reads, max_n_writes=&gt;max_n_writes, memory_offset=&gt;0, n_byte_on_databus_offset=&gt;0) port map (clock=&gt;clock, bram_write=&gt;bram_write, memory_addr_a=&gt;memory_addr_a, din_value_aggregated_swapped=&gt;din_value_aggregated_swapped, be_swapped=&gt;be_swapped, dout_a=&gt;dout_a);

SECOND_MEMORY : if (n_bytes &gt; BRAM_BITSIZE/8) generate
  BRAM_MEMORY_NN_instance_b : BRAM_MEMORY_NN_TP generic map (PORTSIZE_bram_write=&gt;max_n_writes, BITSIZE_bram_write=&gt;1, BITSIZE_dout_a=&gt;(memory_bitsize/2), PORTSIZE_dout_a=&gt;max_n_reads, BITSIZE_memory_addr_a=&gt;nbit_read_addr, PORTSIZE_memory_addr_a=&gt;max_n_rw, BITSIZE_din_value_aggregated_swapped=&gt;memory_bitsize, PORTSIZE_din_value_aggregated_swapped=&gt;max_n_writes, BITSIZE_be_swapped=&gt;n_byte_on_databus, PORTSIZE_be_swapped=&gt;max_n_writes, MEMORY_INIT_file=&gt;MEMORY_INIT_file_b, BRAM_BITSIZE=&gt;BRAM_BITSIZE, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, HIGH_LATENCY=&gt;HIGH_LATENCY, nbit_read_addr=&gt;nbit_read_addr, n_byte_on_databus=&gt;n_byte_on_databus, n_mem_elements=&gt;n_mem_elements, max_n_reads=&gt;max_n_reads, max_n_writes=&gt;max_n_writes, memory_offset=&gt;memory_bitsize/2, n_byte_on_databus_offset=&gt;n_byte_on_databus/2) port map (clock=&gt;clock, bram_write=&gt;bram_write, memory_addr_a=&gt;memory_addr_b, din_value_aggregated_swapped=&gt;din_value_aggregated_swapped, be_swapped=&gt;be_swapped, dout_a=&gt;dout_b);
end generate;
SECOND_MEMORY_else : if(n_bytes &lt;= BRAM_BITSIZE/8) generate
  dout_b &lt;= (others =&gt; &apos;X&apos;);
end generate;

ADDRESS_DECODING_LOGIC_NN_instance : ADDRESS_DECODING_LOGIC_NN generic map (BITSIZE_in1=&gt;BITSIZE_in1, PORTSIZE_in1=&gt;PORTSIZE_in1, BITSIZE_in2=&gt;BITSIZE_in2, PORTSIZE_in2=&gt;PORTSIZE_in2, BITSIZE_in3=&gt;BITSIZE_in3, PORTSIZE_in3=&gt;PORTSIZE_in3, BITSIZE_sel_LOAD=&gt;BITSIZE_sel_LOAD, PORTSIZE_sel_LOAD=&gt;PORTSIZE_sel_LOAD, BITSIZE_sel_STORE=&gt;BITSIZE_sel_STORE, PORTSIZE_sel_STORE=&gt;PORTSIZE_sel_STORE, BITSIZE_out1=&gt;BITSIZE_out1, PORTSIZE_out1=&gt;PORTSIZE_out1, BITSIZE_S_oe_ram=&gt;BITSIZE_S_oe_ram, PORTSIZE_S_oe_ram=&gt;PORTSIZE_S_oe_ram, BITSIZE_S_we_ram=&gt;BITSIZE_S_we_ram, PORTSIZE_S_we_ram=&gt;PORTSIZE_S_we_ram, BITSIZE_Sin_DataRdy=&gt;BITSIZE_Sin_DataRdy, PORTSIZE_Sin_DataRdy=&gt;PORTSIZE_Sin_DataRdy, BITSIZE_Sout_DataRdy=&gt;BITSIZE_Sout_DataRdy, PORTSIZE_Sout_DataRdy=&gt;PORTSIZE_Sout_DataRdy, BITSIZE_S_addr_ram=&gt;BITSIZE_S_addr_ram, PORTSIZE_S_addr_ram=&gt;PORTSIZE_S_addr_ram, BITSIZE_S_Wdata_ram=&gt;BITSIZE_S_Wdata_ram, PORTSIZE_S_Wdata_ram=&gt;PORTSIZE_S_Wdata_ram, BITSIZE_Sin_Rdata_ram=&gt;BITSIZE_Sin_Rdata_ram, PORTSIZE_Sin_Rdata_ram=&gt;PORTSIZE_Sin_Rdata_ram, BITSIZE_Sout_Rdata_ram=&gt;BITSIZE_Sout_Rdata_ram, PORTSIZE_Sout_Rdata_ram=&gt;PORTSIZE_Sout_Rdata_ram, BITSIZE_S_data_ram_size=&gt;BITSIZE_S_data_ram_size, PORTSIZE_S_data_ram_size=&gt;PORTSIZE_S_data_ram_size, address_space_begin=&gt;address_space_begin, address_space_rangesize=&gt;address_space_rangesize, BUS_PIPELINED=&gt;BUS_PIPELINED, BRAM_BITSIZE=&gt;BRAM_BITSIZE, PRIVATE_MEMORY=&gt;PRIVATE_MEMORY, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, USE_SPARSE_MEMORY=&gt;USE_SPARSE_MEMORY, HIGH_LATENCY=&gt;HIGH_LATENCY, BITSIZE_proxy_in1=&gt;BITSIZE_proxy_in1, PORTSIZE_proxy_in1=&gt;PORTSIZE_proxy_in1, BITSIZE_proxy_in2=&gt;BITSIZE_proxy_in2, PORTSIZE_proxy_in2=&gt;PORTSIZE_proxy_in2, BITSIZE_proxy_in3=&gt;BITSIZE_proxy_in3, PORTSIZE_proxy_in3=&gt;PORTSIZE_proxy_in3, BITSIZE_proxy_sel_LOAD=&gt;BITSIZE_proxy_sel_LOAD, PORTSIZE_proxy_sel_LOAD=&gt;PORTSIZE_proxy_sel_LOAD, BITSIZE_proxy_sel_STORE=&gt;BITSIZE_proxy_sel_STORE, PORTSIZE_proxy_sel_STORE=&gt;PORTSIZE_proxy_sel_STORE, BITSIZE_proxy_out1=&gt;BITSIZE_proxy_out1, PORTSIZE_proxy_out1=&gt;PORTSIZE_proxy_out1, BITSIZE_dout_a=&gt;memory_bitsize/2, PORTSIZE_dout_a=&gt;max_n_reads, BITSIZE_dout_b=&gt;memory_bitsize/2, PORTSIZE_dout_b=&gt;max_n_reads, BITSIZE_memory_addr_a=&gt;nbit_read_addr, PORTSIZE_memory_addr_a=&gt;max_n_rw, BITSIZE_memory_addr_b=&gt;nbit_read_addr, PORTSIZE_memory_addr_b=&gt;max_n_rw, BITSIZE_din_value_aggregated_swapped=&gt;memory_bitsize, PORTSIZE_din_value_aggregated_swapped=&gt;max_n_writes, BITSIZE_be_swapped=&gt;n_byte_on_databus, PORTSIZE_be_swapped=&gt;max_n_writes, BITSIZE_bram_write=&gt;1, PORTSIZE_bram_write=&gt;max_n_writes, nbit_read_addr=&gt;nbit_read_addr, n_byte_on_databus=&gt;n_byte_on_databus, n_mem_elements=&gt;n_mem_elements, max_n_reads=&gt;max_n_reads, max_n_writes=&gt;max_n_writes, max_n_rw=&gt;max_n_rw) port map (clock=&gt;clock, reset=&gt;reset, in1=&gt;in1, in2=&gt;in2, in3=&gt;in3, out1=&gt;out1, sel_LOAD=&gt;sel_LOAD, sel_STORE=&gt;sel_STORE, S_oe_ram=&gt;S_oe_ram, S_we_ram=&gt;S_we_ram, S_addr_ram=&gt;S_addr_ram, S_Wdata_ram=&gt;S_Wdata_ram, Sin_Rdata_ram=&gt;Sin_Rdata_ram, Sout_Rdata_ram=&gt;Sout_Rdata_ram, S_data_ram_size=&gt;S_data_ram_size, Sin_DataRdy=&gt;Sin_DataRdy, Sout_DataRdy=&gt;Sout_DataRdy, proxy_in1=&gt;proxy_in1, proxy_in2=&gt;proxy_in2, proxy_in3=&gt;proxy_in3, proxy_sel_LOAD=&gt;proxy_sel_LOAD, proxy_sel_STORE=&gt;proxy_sel_STORE, proxy_out1=&gt;proxy_out1, dout_a=&gt;dout_a, dout_b=&gt;dout_b, memory_addr_a=&gt;memory_addr_a, memory_addr_b=&gt;memory_addr_b, din_value_aggregated_swapped=&gt;din_value_aggregated_swapped, be_swapped=&gt;be_swapped, bram_write=&gt;bram_write);"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_SP</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_SP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_SP"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> arrary address </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element loaded or stored </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_SP in1 in2 in3 out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_out1" IP_COMPONENT="ADDRESS_DECODING_LOGIC,BRAM_MEMORY_CORE" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8 == 0 ? 1 : (n_elements*data_size)/8;
parameter n_byte_on_databus = BRAM_BITSIZE/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
  
wire [nbit_read_addr-1:0] memory_addr_a;
wire [nbit_read_addr-1:0] memory_addr_b;
wire [n_byte_on_databus*2-1:0] be;

wire [2*BRAM_BITSIZE-1:0] din_value_aggregated;
wire bram_write;
wire [BRAM_BITSIZE-1:0] dout_a;
wire [BRAM_BITSIZE-1:0] dout_b;

BRAM_MEMORY_CORE #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_instance (.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));

ADDRESS_DECODING_LOGIC #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .HIGH_LATENCY(HIGH_LATENCY)) ADDRESS_DECODING_LOGIC_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));"
            VHDL_PROVIDED="function integer_ternary_operator(cond : boolean; op1 : integer; op2 : integer) return integer is
   begin
      if cond then
         return op1;
      else
         return op2;
      end if;
   end integer_ternary_operator;
constant n_bytes           : integer := integer_ternary_operator((n_elements*data_size)/8 = 0, 1, (n_elements*data_size)/8);
constant n_byte_on_databus : integer := BRAM_BITSIZE/8;
constant n_mem_elements    : integer := n_bytes/n_byte_on_databus + integer_ternary_operator((n_bytes mod n_byte_on_databus) = 0, 0, 1);
constant nbit_read_addr    : integer := integer_ternary_operator(n_mem_elements = 1, 1, integer(ceil(log2(real(n_mem_elements)))));

signal memory_addr_a : std_logic_vector(nbit_read_addr-1 downto 0);
signal memory_addr_b : std_logic_vector(nbit_read_addr-1 downto 0);
signal be    : std_logic_vector(2*n_byte_on_databus-1 downto 0);

signal din_value_aggregated : std_logic_vector(2*BRAM_BITSIZE-1 downto 0);
signal bram_write : std_logic;
signal dout_a : std_logic_vector(BRAM_BITSIZE-1 downto 0);
signal dout_b : std_logic_vector(BRAM_BITSIZE-1 downto 0);

begin
BRAM_MEMORY_instance : BRAM_MEMORY_CORE generic map (BITSIZE_memory_addr_a=&gt;nbit_read_addr, BITSIZE_memory_addr_b=&gt;nbit_read_addr, BITSIZE_din_value_aggregated=&gt;2*BRAM_BITSIZE, BITSIZE_be=&gt;n_byte_on_databus*2, BITSIZE_dout_a=&gt;BRAM_BITSIZE, BITSIZE_dout_b=&gt;BRAM_BITSIZE, MEMORY_INIT_file=&gt;MEMORY_INIT_file, BRAM_BITSIZE=&gt;BRAM_BITSIZE, nbit_read_addr=&gt;nbit_read_addr, n_byte_on_databus=&gt;n_byte_on_databus, n_mem_elements=&gt;n_mem_elements, n_bytes=&gt;n_bytes, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, HIGH_LATENCY=&gt;HIGH_LATENCY) port map (clock=&gt;clock, bram_write=&gt;bram_write, memory_addr_a=&gt;memory_addr_a, memory_addr_b=&gt;memory_addr_b, din_value_aggregated=&gt;din_value_aggregated, be=&gt;be, dout_a=&gt;dout_a, dout_b=&gt;dout_b);


ADDRESS_DECODING_LOGIC_instance : ADDRESS_DECODING_LOGIC generic map (BITSIZE_memory_addr_a=&gt;nbit_read_addr, BITSIZE_memory_addr_b=&gt;nbit_read_addr, BITSIZE_din_value_aggregated=&gt;2*BRAM_BITSIZE, BITSIZE_be=&gt;n_byte_on_databus*2, BITSIZE_dout_a=&gt;BRAM_BITSIZE, BITSIZE_dout_b=&gt;BRAM_BITSIZE, BITSIZE_in1=&gt;BITSIZE_in1, BITSIZE_in2=&gt;BITSIZE_in2, BITSIZE_in3=&gt;BITSIZE_in3, BITSIZE_out1=&gt;BITSIZE_out1, BITSIZE_S_addr_ram=&gt;BITSIZE_S_addr_ram, BITSIZE_S_Wdata_ram=&gt;BITSIZE_S_Wdata_ram, BITSIZE_Sin_Rdata_ram=&gt;BITSIZE_Sin_Rdata_ram, BITSIZE_Sout_Rdata_ram=&gt;BITSIZE_Sout_Rdata_ram, BITSIZE_S_data_ram_size=&gt;BITSIZE_S_data_ram_size, address_space_begin=&gt;address_space_begin, address_space_rangesize=&gt;address_space_rangesize, BUS_PIPELINED=&gt;BUS_PIPELINED, BRAM_BITSIZE=&gt;BRAM_BITSIZE, PRIVATE_MEMORY=&gt;PRIVATE_MEMORY, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, USE_SPARSE_MEMORY=&gt;USE_SPARSE_MEMORY, BITSIZE_proxy_in1=&gt;BITSIZE_proxy_in1, BITSIZE_proxy_in2=&gt;BITSIZE_proxy_in2, BITSIZE_proxy_in3=&gt;BITSIZE_proxy_in3, BITSIZE_proxy_out1=&gt;BITSIZE_proxy_out1, nbit_read_addr=&gt;nbit_read_addr, n_byte_on_databus=&gt;n_byte_on_databus, n_mem_elements=&gt;n_mem_elements, n_bytes=&gt;n_bytes, HIGH_LATENCY=&gt;HIGH_LATENCY) port map (clock=&gt;clock, reset=&gt;reset, in1=&gt;in1, in2=&gt;in2, in3=&gt;in3, out1=&gt;out1, sel_LOAD=&gt;sel_LOAD, sel_STORE=&gt;sel_STORE, S_oe_ram=&gt;S_oe_ram, S_we_ram=&gt;S_we_ram, S_addr_ram=&gt;S_addr_ram, S_Wdata_ram=&gt;S_Wdata_ram, Sin_Rdata_ram=&gt;Sin_Rdata_ram, Sout_Rdata_ram=&gt;Sout_Rdata_ram, S_data_ram_size=&gt;S_data_ram_size, Sin_DataRdy=&gt;Sin_DataRdy, Sout_DataRdy=&gt;Sout_DataRdy, proxy_in1=&gt;proxy_in1, proxy_in2=&gt;proxy_in2, proxy_in3=&gt;proxy_in3, proxy_sel_LOAD=&gt;proxy_sel_LOAD, proxy_sel_STORE=&gt;proxy_sel_STORE, proxy_out1=&gt;proxy_out1, dout_a=&gt;dout_a, dout_b=&gt;dout_b, memory_addr_a=&gt;memory_addr_a, memory_addr_b=&gt;memory_addr_b, din_value_aggregated=&gt;din_value_aggregated, be=&gt;be, bram_write=&gt;bram_write);"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_N1_SP</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_N1_SP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_N1_SP"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_N1_SP in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1 HIGH_LATENCY" 
          IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_SP" 
          VERILOG_PROVIDED="
ARRAY_1D_STD_BRAM_NN_SP #(
  .BITSIZE_in1(BITSIZE_in1), 
  .PORTSIZE_in1(PORTSIZE_in1), 
  .BITSIZE_in2(BITSIZE_in2), 
  .PORTSIZE_in2(PORTSIZE_in2), 
  .BITSIZE_in3(BITSIZE_in3), 
  .PORTSIZE_in3(PORTSIZE_in3), 
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD), 
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD), 
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE), 
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE), 
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram), 
  .PORTSIZE_S_oe_ram(1), 
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram), 
  .PORTSIZE_S_we_ram(1), 
  .BITSIZE_out1(BITSIZE_out1), 
  .PORTSIZE_out1(PORTSIZE_out1), 
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram), 
  .PORTSIZE_S_addr_ram(1), 
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram), 
  .PORTSIZE_S_Wdata_ram(1), 
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram), 
  .PORTSIZE_Sin_Rdata_ram(1), 
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram), 
  .PORTSIZE_Sout_Rdata_ram(1), 
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size), 
  .PORTSIZE_S_data_ram_size(1), 
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy), 
  .PORTSIZE_Sin_DataRdy(1), 
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy), 
  .PORTSIZE_Sout_DataRdy(1), 
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1)) ARRAY_1D_STD_BRAM_NN_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size ),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE));"
            VHDL_PROVIDED="
begin
ARRAY_1D_STD_BRAM_NN_instance : ARRAY_1D_STD_BRAM_NN_SP generic map (BITSIZE_in1=&gt;BITSIZE_in1, PORTSIZE_in1=&gt;PORTSIZE_in1, BITSIZE_in2=&gt;BITSIZE_in2, PORTSIZE_in2=&gt;PORTSIZE_in2, BITSIZE_in3=&gt;BITSIZE_in3, PORTSIZE_in3=&gt;PORTSIZE_in3, BITSIZE_sel_LOAD=&gt;BITSIZE_sel_LOAD, PORTSIZE_sel_LOAD=&gt;PORTSIZE_sel_LOAD, BITSIZE_sel_STORE=&gt;BITSIZE_sel_STORE, PORTSIZE_sel_STORE=&gt;PORTSIZE_sel_STORE, BITSIZE_S_oe_ram=&gt;BITSIZE_S_oe_ram, PORTSIZE_S_oe_ram=&gt;1, BITSIZE_S_we_ram=&gt;BITSIZE_S_we_ram, PORTSIZE_S_we_ram=&gt;1, BITSIZE_out1=&gt;BITSIZE_out1, PORTSIZE_out1=&gt;PORTSIZE_out1, BITSIZE_S_addr_ram=&gt;BITSIZE_S_addr_ram, PORTSIZE_S_addr_ram=&gt;1, BITSIZE_S_Wdata_ram=&gt;BITSIZE_S_Wdata_ram, PORTSIZE_S_Wdata_ram=&gt;1, BITSIZE_Sin_Rdata_ram=&gt;BITSIZE_Sin_Rdata_ram, PORTSIZE_Sin_Rdata_ram=&gt;1, BITSIZE_Sout_Rdata_ram=&gt;BITSIZE_Sout_Rdata_ram, PORTSIZE_Sout_Rdata_ram=&gt;1, BITSIZE_S_data_ram_size=&gt;BITSIZE_S_data_ram_size, PORTSIZE_S_data_ram_size=&gt;1, BITSIZE_Sin_DataRdy=&gt;BITSIZE_Sin_DataRdy, PORTSIZE_Sin_DataRdy=&gt;1, BITSIZE_Sout_DataRdy=&gt;BITSIZE_Sout_DataRdy, PORTSIZE_Sout_DataRdy=&gt;1, MEMORY_INIT_file_a=&gt;MEMORY_INIT_file_a, MEMORY_INIT_file_b=&gt;MEMORY_INIT_file_b, n_elements=&gt;n_elements, data_size=&gt;data_size, address_space_begin=&gt;address_space_begin, address_space_rangesize=&gt;address_space_rangesize, BUS_PIPELINED=&gt;BUS_PIPELINED, BRAM_BITSIZE=&gt;BRAM_BITSIZE, PRIVATE_MEMORY=&gt;PRIVATE_MEMORY, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, USE_SPARSE_MEMORY=&gt;USE_SPARSE_MEMORY, BITSIZE_proxy_in1=&gt;BITSIZE_proxy_in1, PORTSIZE_proxy_in1=&gt;PORTSIZE_proxy_in1, BITSIZE_proxy_in2=&gt;BITSIZE_proxy_in2, PORTSIZE_proxy_in2=&gt;PORTSIZE_proxy_in2, BITSIZE_proxy_in3=&gt;BITSIZE_proxy_in3, PORTSIZE_proxy_in3=&gt;PORTSIZE_proxy_in3, BITSIZE_proxy_sel_LOAD=&gt;BITSIZE_proxy_sel_LOAD, PORTSIZE_proxy_sel_LOAD=&gt;PORTSIZE_proxy_sel_LOAD, BITSIZE_proxy_sel_STORE=&gt;BITSIZE_proxy_sel_STORE, PORTSIZE_proxy_sel_STORE=&gt;PORTSIZE_proxy_sel_STORE, BITSIZE_proxy_out1=&gt;BITSIZE_proxy_out1, PORTSIZE_proxy_out1=&gt;PORTSIZE_proxy_out1, HIGH_LATENCY=&gt;HIGH_LATENCY) port map (out1=&gt;out1, Sout_Rdata_ram=&gt;Sout_Rdata_ram, Sout_DataRdy(0)=&gt;Sout_DataRdy, proxy_out1=&gt;proxy_out1, clock=&gt;clock, reset=&gt;reset, in1=&gt;in1, in2=&gt;in2, in3=&gt;in3, sel_LOAD=&gt;sel_LOAD, sel_STORE=&gt;sel_STORE, S_oe_ram(0)=&gt;S_oe_ram, S_we_ram(0)=&gt;S_we_ram, S_addr_ram=&gt;S_addr_ram, S_Wdata_ram=&gt;S_Wdata_ram, Sin_Rdata_ram=&gt;Sin_Rdata_ram, S_data_ram_size=&gt;S_data_ram_size, Sin_DataRdy(0)=&gt;Sin_DataRdy, proxy_in1=&gt;proxy_in1, proxy_in2=&gt;proxy_in2, proxy_in3=&gt;proxy_in3, proxy_sel_LOAD=&gt;proxy_sel_LOAD, proxy_sel_STORE=&gt;proxy_sel_STORE);"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_NN_SP</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_NN_SP">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_NN_SP"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> arrary address </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element loaded or stored </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_NN_SP in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1" IP_COMPONENT="ADDRESS_DECODING_LOGIC_NN,BRAM_MEMORY_NN_CORE" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8;
parameter memory_bitsize = 2*BRAM_BITSIZE;
parameter n_byte_on_databus = memory_bitsize/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
parameter max_n_writes = PORTSIZE_sel_STORE &gt; PORTSIZE_S_we_ram ? PORTSIZE_sel_STORE : PORTSIZE_S_we_ram;
parameter max_n_reads = PORTSIZE_sel_LOAD &gt; PORTSIZE_S_oe_ram ? PORTSIZE_sel_LOAD : PORTSIZE_S_oe_ram;
parameter max_n_rw = max_n_writes &gt; max_n_reads ? max_n_writes : max_n_reads;

wire [max_n_writes-1:0] bram_write;

wire [nbit_read_addr*max_n_rw-1:0] memory_addr_a;
wire [nbit_read_addr*max_n_rw-1:0] memory_addr_b;
wire [n_byte_on_databus*max_n_writes-1:0] be_swapped;

wire [memory_bitsize*max_n_writes-1:0] din_value_aggregated_swapped;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_a;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_b;


BRAM_MEMORY_NN_CORE #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_a),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .n_bytes(n_bytes),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(0),
  .n_byte_on_databus_offset(0),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_NN_instance_a(
  .clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_a));

generate
  if (n_bytes &gt; BRAM_BITSIZE/8)
  begin : SECOND_MEMORY
    BRAM_MEMORY_NN_CORE #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a((memory_bitsize/2)),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_b),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .n_bytes(n_bytes),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(memory_bitsize/2),
  .n_byte_on_databus_offset(n_byte_on_databus/2),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_NN_instance_b(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_b));
  end
else
  assign dout_b = {(memory_bitsize/2)*max_n_reads{1&apos;b0}};
endgenerate

ADDRESS_DECODING_LOGIC_NN #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_dout_b(memory_bitsize/2),
  .PORTSIZE_dout_b(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .PORTSIZE_memory_addr_b(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .BITSIZE_bram_write(1),
  .PORTSIZE_bram_write(max_n_writes),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .max_n_rw(max_n_rw)) ADDRESS_DECODING_LOGIC_NN_instance (.clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .out1(out1),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .proxy_out1(proxy_out1),
  .dout_a(dout_a),
  .dout_b(dout_b),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .bram_write(bram_write));"
            VHDL_PROVIDED="function integer_ternary_operator(cond : boolean; op1 : integer; op2 : integer) return integer is
   begin
      if cond then
         return op1;
      else
         return op2;
      end if;
   end integer_ternary_operator;
constant n_bytes           : integer := (n_elements*data_size)/8;
constant memory_bitsize    : integer := 2*BRAM_BITSIZE;
constant n_byte_on_databus : integer := memory_bitsize/8;
constant n_mem_elements    : integer := n_bytes/n_byte_on_databus + integer_ternary_operator((n_bytes mod n_byte_on_databus) = 0, 0, 1);
constant nbit_read_addr    : integer := integer_ternary_operator(n_mem_elements = 1, 1, integer(ceil(log2(real(n_mem_elements)))));
constant max_n_writes      : integer := integer_ternary_operator(PORTSIZE_sel_STORE &gt; PORTSIZE_S_we_ram, PORTSIZE_sel_STORE, PORTSIZE_S_we_ram);
constant max_n_reads       : integer := integer_ternary_operator(PORTSIZE_sel_LOAD &gt; PORTSIZE_S_oe_ram, PORTSIZE_sel_LOAD, PORTSIZE_S_oe_ram);
constant max_n_rw          : integer := integer_ternary_operator(max_n_writes &gt; max_n_reads, max_n_writes, max_n_reads);

signal bram_write : std_logic_vector(max_n_writes-1 downto 0);

signal memory_addr_a : std_logic_vector(nbit_read_addr*max_n_rw-1 downto 0);
signal memory_addr_b : std_logic_vector(nbit_read_addr*max_n_rw-1 downto 0);
signal be_swapped    : std_logic_vector(n_byte_on_databus*max_n_writes-1 downto 0);

signal din_value_aggregated_swapped : std_logic_vector(memory_bitsize*max_n_writes-1 downto 0);
signal dout_a : std_logic_vector((memory_bitsize/2)*max_n_reads-1 downto 0);
signal dout_b : std_logic_vector((memory_bitsize/2)*max_n_reads-1 downto 0);

begin
BRAM_MEMORY_NN_instance_a : BRAM_MEMORY_NN_CORE generic map (PORTSIZE_bram_write=&gt;max_n_writes, BITSIZE_bram_write=&gt;1, BITSIZE_dout_a=&gt;memory_bitsize/2, PORTSIZE_dout_a=&gt;max_n_reads, BITSIZE_memory_addr_a=&gt;nbit_read_addr, PORTSIZE_memory_addr_a=&gt;max_n_rw, BITSIZE_din_value_aggregated_swapped=&gt;memory_bitsize, PORTSIZE_din_value_aggregated_swapped=&gt;max_n_writes, BITSIZE_be_swapped=&gt;n_byte_on_databus, PORTSIZE_be_swapped=&gt;max_n_writes, MEMORY_INIT_file=&gt;MEMORY_INIT_file_a, BRAM_BITSIZE=&gt;BRAM_BITSIZE, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, HIGH_LATENCY=&gt;HIGH_LATENCY, n_bytes=&gt;n_bytes, n_byte_on_databus=&gt;n_byte_on_databus, n_mem_elements=&gt;n_mem_elements, max_n_reads=&gt;max_n_reads, max_n_writes=&gt;max_n_writes, memory_offset=&gt;0, n_byte_on_databus_offset=&gt;0) port map (clock=&gt;clock, bram_write=&gt;bram_write, memory_addr_a=&gt;memory_addr_a, din_value_aggregated_swapped=&gt;din_value_aggregated_swapped, be_swapped=&gt;be_swapped, dout_a=&gt;dout_a);

SECOND_MEMORY : if (n_bytes &gt; BRAM_BITSIZE/8) generate
  BRAM_MEMORY_NN_instance_b : BRAM_MEMORY_NN_CORE generic map (PORTSIZE_bram_write=&gt;max_n_writes, BITSIZE_bram_write=&gt;1, BITSIZE_dout_a=&gt;(memory_bitsize/2), PORTSIZE_dout_a=&gt;max_n_reads, BITSIZE_memory_addr_a=&gt;nbit_read_addr, PORTSIZE_memory_addr_a=&gt;max_n_rw, BITSIZE_din_value_aggregated_swapped=&gt;memory_bitsize, PORTSIZE_din_value_aggregated_swapped=&gt;max_n_writes, BITSIZE_be_swapped=&gt;n_byte_on_databus, PORTSIZE_be_swapped=&gt;max_n_writes, MEMORY_INIT_file=&gt;MEMORY_INIT_file_b, BRAM_BITSIZE=&gt;BRAM_BITSIZE, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, HIGH_LATENCY=&gt;HIGH_LATENCY, n_bytes=&gt;n_bytes, n_byte_on_databus=&gt;n_byte_on_databus, n_mem_elements=&gt;n_mem_elements, max_n_reads=&gt;max_n_reads, max_n_writes=&gt;max_n_writes, memory_offset=&gt;memory_bitsize/2, n_byte_on_databus_offset=&gt;n_byte_on_databus/2) port map (clock=&gt;clock, bram_write=&gt;bram_write, memory_addr_a=&gt;memory_addr_b, din_value_aggregated_swapped=&gt;din_value_aggregated_swapped, be_swapped=&gt;be_swapped, dout_a=&gt;dout_b);
end generate;
SECOND_MEMORY_else : if(n_bytes &lt;= BRAM_BITSIZE/8) generate
  dout_b &lt;= (others =&gt; &apos;X&apos;);
end generate;

ADDRESS_DECODING_LOGIC_NN_instance : ADDRESS_DECODING_LOGIC_NN generic map (BITSIZE_in1=&gt;BITSIZE_in1, PORTSIZE_in1=&gt;PORTSIZE_in1, BITSIZE_in2=&gt;BITSIZE_in2, PORTSIZE_in2=&gt;PORTSIZE_in2, BITSIZE_in3=&gt;BITSIZE_in3, PORTSIZE_in3=&gt;PORTSIZE_in3, BITSIZE_sel_LOAD=&gt;BITSIZE_sel_LOAD, PORTSIZE_sel_LOAD=&gt;PORTSIZE_sel_LOAD, BITSIZE_sel_STORE=&gt;BITSIZE_sel_STORE, PORTSIZE_sel_STORE=&gt;PORTSIZE_sel_STORE, BITSIZE_out1=&gt;BITSIZE_out1, PORTSIZE_out1=&gt;PORTSIZE_out1, BITSIZE_S_oe_ram=&gt;BITSIZE_S_oe_ram, PORTSIZE_S_oe_ram=&gt;PORTSIZE_S_oe_ram, BITSIZE_S_we_ram=&gt;BITSIZE_S_we_ram, PORTSIZE_S_we_ram=&gt;PORTSIZE_S_we_ram, BITSIZE_Sin_DataRdy=&gt;BITSIZE_Sin_DataRdy, PORTSIZE_Sin_DataRdy=&gt;PORTSIZE_Sin_DataRdy, BITSIZE_Sout_DataRdy=&gt;BITSIZE_Sout_DataRdy, PORTSIZE_Sout_DataRdy=&gt;PORTSIZE_Sout_DataRdy, BITSIZE_S_addr_ram=&gt;BITSIZE_S_addr_ram, PORTSIZE_S_addr_ram=&gt;PORTSIZE_S_addr_ram, BITSIZE_S_Wdata_ram=&gt;BITSIZE_S_Wdata_ram, PORTSIZE_S_Wdata_ram=&gt;PORTSIZE_S_Wdata_ram, BITSIZE_Sin_Rdata_ram=&gt;BITSIZE_Sin_Rdata_ram, PORTSIZE_Sin_Rdata_ram=&gt;PORTSIZE_Sin_Rdata_ram, BITSIZE_Sout_Rdata_ram=&gt;BITSIZE_Sout_Rdata_ram, PORTSIZE_Sout_Rdata_ram=&gt;PORTSIZE_Sout_Rdata_ram, BITSIZE_S_data_ram_size=&gt;BITSIZE_S_data_ram_size, PORTSIZE_S_data_ram_size=&gt;PORTSIZE_S_data_ram_size, address_space_begin=&gt;address_space_begin, address_space_rangesize=&gt;address_space_rangesize, BUS_PIPELINED=&gt;BUS_PIPELINED, BRAM_BITSIZE=&gt;BRAM_BITSIZE, PRIVATE_MEMORY=&gt;PRIVATE_MEMORY, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, USE_SPARSE_MEMORY=&gt;USE_SPARSE_MEMORY, HIGH_LATENCY=&gt;HIGH_LATENCY, BITSIZE_proxy_in1=&gt;BITSIZE_proxy_in1, PORTSIZE_proxy_in1=&gt;PORTSIZE_proxy_in1, BITSIZE_proxy_in2=&gt;BITSIZE_proxy_in2, PORTSIZE_proxy_in2=&gt;PORTSIZE_proxy_in2, BITSIZE_proxy_in3=&gt;BITSIZE_proxy_in3, PORTSIZE_proxy_in3=&gt;PORTSIZE_proxy_in3, BITSIZE_proxy_sel_LOAD=&gt;BITSIZE_proxy_sel_LOAD, PORTSIZE_proxy_sel_LOAD=&gt;PORTSIZE_proxy_sel_LOAD, BITSIZE_proxy_sel_STORE=&gt;BITSIZE_proxy_sel_STORE, PORTSIZE_proxy_sel_STORE=&gt;PORTSIZE_proxy_sel_STORE, BITSIZE_proxy_out1=&gt;BITSIZE_proxy_out1, PORTSIZE_proxy_out1=&gt;PORTSIZE_proxy_out1, BITSIZE_dout_a=&gt;memory_bitsize/2, PORTSIZE_dout_a=&gt;max_n_reads, BITSIZE_dout_b=&gt;memory_bitsize/2, PORTSIZE_dout_b=&gt;max_n_reads, BITSIZE_memory_addr_a=&gt;nbit_read_addr, PORTSIZE_memory_addr_a=&gt;max_n_rw, BITSIZE_memory_addr_b=&gt;nbit_read_addr, PORTSIZE_memory_addr_b=&gt;max_n_rw, BITSIZE_din_value_aggregated_swapped=&gt;memory_bitsize, PORTSIZE_din_value_aggregated_swapped=&gt;max_n_writes, BITSIZE_be_swapped=&gt;n_byte_on_databus, PORTSIZE_be_swapped=&gt;max_n_writes, BITSIZE_bram_write=&gt;1, PORTSIZE_bram_write=&gt;max_n_writes, nbit_read_addr=&gt;nbit_read_addr, n_byte_on_databus=&gt;n_byte_on_databus, n_mem_elements=&gt;n_mem_elements, max_n_reads=&gt;max_n_reads, max_n_writes=&gt;max_n_writes, max_n_rw=&gt;max_n_rw) port map (clock=&gt;clock, reset=&gt;reset, in1=&gt;in1, in2=&gt;in2, in3=&gt;in3, out1=&gt;out1, sel_LOAD=&gt;sel_LOAD, sel_STORE=&gt;sel_STORE, S_oe_ram=&gt;S_oe_ram, S_we_ram=&gt;S_we_ram, S_addr_ram=&gt;S_addr_ram, S_Wdata_ram=&gt;S_Wdata_ram, Sin_Rdata_ram=&gt;Sin_Rdata_ram, Sout_Rdata_ram=&gt;Sout_Rdata_ram, S_data_ram_size=&gt;S_data_ram_size, Sin_DataRdy=&gt;Sin_DataRdy, Sout_DataRdy=&gt;Sout_DataRdy, proxy_in1=&gt;proxy_in1, proxy_in2=&gt;proxy_in2, proxy_in3=&gt;proxy_in3, proxy_sel_LOAD=&gt;proxy_sel_LOAD, proxy_sel_STORE=&gt;proxy_sel_STORE, proxy_out1=&gt;proxy_out1, dout_a=&gt;dout_a, dout_b=&gt;dout_b, memory_addr_a=&gt;memory_addr_a, memory_addr_b=&gt;memory_addr_b, din_value_aggregated_swapped=&gt;din_value_aggregated_swapped, be_swapped=&gt;be_swapped, bram_write=&gt;bram_write);"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_SV</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_SV">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_SV"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> arrary address </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element loaded or stored </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_SV in1 in2 in3 out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_out1" IP_COMPONENT="ADDRESS_DECODING_LOGIC,BRAM_MEMORY_SV" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8;
parameter n_byte_on_databus = BRAM_BITSIZE/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
  
wire [nbit_read_addr-1:0] memory_addr_a;
wire [nbit_read_addr-1:0] memory_addr_b;
wire [n_byte_on_databus*2-1:0] be;

wire [2*BRAM_BITSIZE-1:0] din_value_aggregated;
wire bram_write;
wire [BRAM_BITSIZE-1:0] dout_a;
wire [BRAM_BITSIZE-1:0] dout_b;

BRAM_MEMORY_SV #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_instance (.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));

ADDRESS_DECODING_LOGIC #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .HIGH_LATENCY(HIGH_LATENCY)) ADDRESS_DECODING_LOGIC_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_NN_SV</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_NN_SV">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_NN_SV"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_NN_SV in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1" IP_COMPONENT="ADDRESS_DECODING_LOGIC_NN,BRAM_MEMORY_NN_SV" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8;
parameter memory_bitsize = 2*BRAM_BITSIZE;
parameter n_byte_on_databus = memory_bitsize/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
parameter max_n_writes = PORTSIZE_sel_STORE &gt; PORTSIZE_S_we_ram ? PORTSIZE_sel_STORE : PORTSIZE_S_we_ram;
parameter max_n_reads = PORTSIZE_sel_LOAD &gt; PORTSIZE_S_oe_ram ? PORTSIZE_sel_LOAD : PORTSIZE_S_oe_ram;
parameter max_n_rw = max_n_writes &gt; max_n_reads ? max_n_writes : max_n_reads;

wire [max_n_writes-1:0] bram_write;

wire [nbit_read_addr*max_n_rw-1:0] memory_addr_a;
wire [nbit_read_addr*max_n_rw-1:0] memory_addr_b;
wire [n_byte_on_databus*max_n_writes-1:0] be_swapped;

wire [memory_bitsize*max_n_writes-1:0] din_value_aggregated_swapped;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_a;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_b;


BRAM_MEMORY_NN_SV #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_a),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(0),
  .n_byte_on_databus_offset(0),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_NN_instance_a(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_a));

generate
  if (n_bytes &gt; BRAM_BITSIZE/8)
  begin : SECOND_MEMORY
    BRAM_MEMORY_NN_SV #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a((memory_bitsize/2)),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_b),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(memory_bitsize/2),
  .n_byte_on_databus_offset(n_byte_on_databus/2),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_NN_instance_b(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_b));
  end
else
  assign dout_b = {(memory_bitsize/2)*max_n_reads{1&apos;b0}};
endgenerate

ADDRESS_DECODING_LOGIC_NN #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_dout_b(memory_bitsize/2),
  .PORTSIZE_dout_b(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .PORTSIZE_memory_addr_b(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .BITSIZE_bram_write(1),
  .PORTSIZE_bram_write(max_n_writes),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .max_n_rw(max_n_rw)) ADDRESS_DECODING_LOGIC_NN_instance (.clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .out1(out1),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .proxy_out1(proxy_out1),
  .dout_a(dout_a),
  .dout_b(dout_b),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .bram_write(bram_write));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_N1_SV</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_N1_SV">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_N1_SV"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_N1_SV in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1 HIGH_LATENCY" 
          IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_SV" 
          VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_NN_SV #(
  .BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(1),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(1),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(1),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(1),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(1),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(1),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(1),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(1),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(1),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1)) ARRAY_1D_STD_BRAM_NN_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size ),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAM_SV</name>
      <circuit>
        <component_o id="STD_BRAM_SV">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAM_SV"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_BRAM_SV S_addr_ram S_Wdata_ram Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="ARRAY_1D_STD_BRAM_SV" 
          VERILOG_PROVIDED="
ARRAY_1D_STD_BRAM_SV #(
  .BITSIZE_in1(1),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_out1(1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .READ_ONLY_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(1),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_proxy_out1(1)) ARRAY_1D_STD_BRAM_instance (
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1(1&apos;b0),
  .in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD(1&apos;b0),
  .sel_STORE(1&apos;b0),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(1&apos;b0),
  .proxy_in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD(1&apos;b0),
  .proxy_sel_STORE(1&apos;b0));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAMN_SV</name>
      <circuit>
        <component_o id="STD_BRAMN_SV">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAMN_SV"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_BRAMN_SV S_oe_ram S_we_ram S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_SV" 
          VERILOG_PROVIDED="
ARRAY_1D_STD_BRAM_NN_SV #(
  .BITSIZE_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_sel_LOAD(1),
  .PORTSIZE_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_sel_STORE(1),
  .PORTSIZE_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_out1(1),
  .PORTSIZE_out1(PORTSIZE_S_addr_ram),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .READ_ONLY_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY),
  .BITSIZE_proxy_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_proxy_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_proxy_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_proxy_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_proxy_sel_LOAD(1),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_sel_STORE(1),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_out1(1),
  .PORTSIZE_proxy_out1(PORTSIZE_S_addr_ram)) ARRAY_1D_STD_BRAM_NN_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .proxy_in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_SP_BRAM</name>
      <circuit>
        <component_o id="STD_SP_BRAM">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2020-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_SP_BRAM"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_elements">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_enable" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="address_inr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="address_inw" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_SP_BRAM data_in address_inr address_inw data_out MEMORY_INIT_file n_elements READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="
wire [BITSIZE_address_inr-1:0] address_inr_mem;
reg [BITSIZE_address_inr-1:0] address_inr1;
wire [BITSIZE_address_inw-1:0] address_inw_mem;
reg [BITSIZE_address_inw-1:0] address_inw1;

wire write_enable_mem;
reg write_enable1;

reg [BITSIZE_data_out-1:0] data_out_mem;
reg [BITSIZE_data_out-1:0] data_out1;

wire [BITSIZE_data_in-1:0] data_in_mem;
reg [BITSIZE_data_in-1:0] data_in1;

reg [BITSIZE_data_out-1:0] memory [0:n_elements-1]/* synthesis syn_ramstyle =  &quot;no_rw_check &quot; */;
initial
begin
  if (MEMORY_INIT_file != &quot;&quot;)
    $readmemb(MEMORY_INIT_file, memory, 0, n_elements-1);
end

always @(posedge clock)
begin
  if(READ_ONLY_MEMORY==0)
  begin
    if (write_enable_mem)
      memory[address_inw_mem] &lt;= data_in_mem;
  end
  data_out_mem &lt;= memory[address_inr_mem];
end

assign data_out = HIGH_LATENCY==0 ? data_out_mem : data_out1;
always @(posedge clock)
  data_out1 &lt;= data_out_mem;


generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       address_inr1 &lt;= address_inr;
       address_inw1 &lt;= address_inw;
       write_enable1 &lt;= write_enable;
       data_in1 &lt;= data_in;
    end
    assign address_inr_mem = address_inr1;
    assign address_inw_mem = address_inw1;
    assign write_enable_mem = write_enable1;
    assign data_in_mem = data_in1;
  end
  else
  begin
    assign address_inr_mem = address_inr;
    assign address_inw_mem = address_inw;
    assign write_enable_mem = write_enable;
    assign data_in_mem = data_in;
  end
endgenerate
" VHDL_PROVIDED="
  signal address_inr_mem : std_logic_vector(BITSIZE_address_inr-1 downto 0);
  signal address_inr1 : std_logic_vector(BITSIZE_address_inr-1 downto 0);
  signal address_inw_mem : std_logic_vector(BITSIZE_address_inw-1 downto 0);
  signal address_inw1 : std_logic_vector(BITSIZE_address_inw-1 downto 0);


  signal write_enable_mem : std_logic;
  signal write_enable1 : std_logic;

  signal data_out_mem : std_logic_vector(BITSIZE_data_out-1 downto 0);
  signal data_out1 : std_logic_vector(BITSIZE_data_out-1 downto 0);

  signal data_in_mem : std_logic_vector(BITSIZE_data_in-1 downto 0);
  signal data_in1 : std_logic_vector(BITSIZE_data_in-1 downto 0);
  
  type mem_type is array (n_elements-1 downto 0) of std_logic_vector(BITSIZE_data_out-1 downto 0);

  impure function InitMemFromFile (MemFileName : in string) return mem_type is
    FILE memfile : text open READ_MODE is MemFileName;
    variable MemFileLine : line;
    variable mem : mem_type;
    begin
       for i in 0 to n_elements-1 loop
        readline(memfile, MemFileLine);
        read(MemFileLine, mem(i));
      end loop;
      return mem;
  end function;

  shared variable mem : mem_type := InitMemFromFile(MEMORY_INIT_file);

begin

  DelayProcess : process(clock)
  begin
    if (clock&apos;event and clock=&apos;1&apos;) then
       if(HIGH_LATENCY=2) then
         address_inr1 &lt;= address_inr;
         address_inw1 &lt;= address_inw;
         write_enable1 &lt;= write_enable;
         data_in1 &lt;= data_in;
       end if;
    end if;
  end process;

  address_inr_mem &lt;= address_inr1 when (HIGH_LATENCY=2) else address_inr;
  address_inw_mem &lt;= address_inw1 when (HIGH_LATENCY=2) else address_inw;
  write_enable_mem &lt;= write_enable1 when (HIGH_LATENCY=2) else write_enable;
  data_in_mem &lt;= data_in1 when (HIGH_LATENCY=2) else data_in;

  data_out &lt;= data_out_mem when (HIGH_LATENCY=0) else data_out1;

  L1_registering : process(clock)
  begin
    if (clock&apos;event and clock=&apos;1&apos;) then
      data_out1 &lt;= data_out_mem;
    end if;
  end process;

  L1_single_proc : process(clock)
  begin
    if (clock&apos;event and clock=&apos;1&apos;) then
      if(READ_ONLY_MEMORY=0) then
        if(write_enable_mem=&apos;1&apos;) then
-- synthesis translate_off
          if (to_integer(unsigned(address_inw_mem)) &lt; n_elements) then
-- synthesis translate_on
            mem(to_integer(unsigned(address_inw_mem))) := data_in_mem;
-- synthesis translate_off
          end if;
-- synthesis translate_on
        end if;
      end if;
-- synthesis translate_off
      if (to_integer(unsigned(address_inr_mem)) &lt; n_elements) then
-- synthesis translate_on
        data_out_mem &lt;= mem(to_integer(unsigned(address_inr_mem)));
-- synthesis translate_off
      else
        data_out_mem &lt;= (others =&gt; &apos;X&apos;);
      end if;
-- synthesis translate_on
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_DP_BRAM</name>
      <circuit>
        <component_o id="STD_DP_BRAM">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_DP_BRAM"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_elements">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
         </port_o>
          <port_vector_o id="write_enable" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="data_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="address_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="data_out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_DP_BRAM write_enable data_in address_in data_out MEMORY_INIT_file n_elements READ_ONLY_MEMORY HIGH_LATENCY" 
          VERILOG_PROVIDED="
wire [2*BITSIZE_address_in-1:0] address_in_mem;
reg [2*BITSIZE_address_in-1:0] address_in1;

wire [1:0] write_enable_mem;
reg [1:0] write_enable1;

reg [2*BITSIZE_data_out-1:0] data_out_mem;
reg [2*BITSIZE_data_out-1:0] data_out1;

wire [2*BITSIZE_data_in-1:0] data_in_mem;
reg [2*BITSIZE_data_in-1:0] data_in1;

reg [BITSIZE_data_out-1:0] memory [0:n_elements-1] /* synthesis syn_ramstyle = &quot;no_rw_check &quot; */;

initial
begin
  if (MEMORY_INIT_file != &quot;&quot;)
    $readmemb(MEMORY_INIT_file, memory, 0, n_elements-1);
end

assign data_out = HIGH_LATENCY==0 ? data_out_mem : data_out1;
always @(posedge clock)
  data_out1 &lt;= data_out_mem;

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       address_in1 &lt;= address_in;
       write_enable1 &lt;= write_enable;
       data_in1 &lt;= data_in;
    end
    assign address_in_mem = address_in1;
    assign write_enable_mem = write_enable1;
    assign data_in_mem = data_in1;
  end
  else
  begin
    assign address_in_mem = address_in;
    assign write_enable_mem = write_enable;
    assign data_in_mem = data_in;
  end
endgenerate

  
always @(posedge clock)
begin
  if(READ_ONLY_MEMORY==0)
  begin
    if(write_enable_mem[0])
      memory[address_in_mem[BITSIZE_address_in*0+:BITSIZE_address_in]] &lt;= data_in_mem[BITSIZE_data_in*0+:BITSIZE_data_in];
  end
  data_out_mem[BITSIZE_data_out*0+:BITSIZE_data_out] &lt;= memory[address_in_mem[BITSIZE_address_in*0+:BITSIZE_address_in]];
end
always @(posedge clock)
begin
    if(READ_ONLY_MEMORY==0)
    begin
      if(write_enable_mem[1])
        memory[address_in_mem[BITSIZE_address_in*1+:BITSIZE_address_in]] &lt;= data_in_mem[BITSIZE_data_in*1+:BITSIZE_data_in];
    end
    data_out_mem[BITSIZE_data_out*1+:BITSIZE_data_out] &lt;= memory[address_in_mem[BITSIZE_address_in*1+:BITSIZE_address_in]];
end
"
VHDL_PROVIDED="
  signal address_in_mem : std_logic_vector(2*BITSIZE_address_in-1 downto 0);
  signal address_in1 : std_logic_vector(2*BITSIZE_address_in-1 downto 0);


  signal write_enable_mem : std_logic_vector(1 downto 0);
  signal write_enable1 : std_logic_vector(1 downto 0);

  signal data_out_mem : std_logic_vector(2*BITSIZE_data_out-1 downto 0);
  signal data_out1 : std_logic_vector(2*BITSIZE_data_out-1 downto 0);

  signal data_in_mem : std_logic_vector(2*BITSIZE_data_in-1 downto 0);
  signal data_in1 : std_logic_vector(2*BITSIZE_data_in-1 downto 0);

  type mem_type is array (n_elements-1 downto 0) of std_logic_vector(BITSIZE_data_out-1 downto 0);

  impure function InitMemFromFile (MemFileName : in string) return mem_type is
    FILE memfile : text open READ_MODE is MemFileName;
    variable MemFileLine : line;
    variable mem : mem_type;
    begin
       for i in 0 to n_elements-1 loop
        readline(memfile, MemFileLine);
        read(MemFileLine, mem(i));
      end loop;
      return mem;
  end function;

  shared variable mem : mem_type := InitMemFromFile(MEMORY_INIT_file);

begin

  DelayProcess : process(clock)
  begin
    if (clock&apos;event and clock=&apos;1&apos;) then
       if(HIGH_LATENCY=2) then
         address_in1 &lt;= address_in;
         write_enable1 &lt;= write_enable;
         data_in1 &lt;= data_in;
       end if;
    end if;
  end process;

  address_in_mem &lt;= address_in1 when (HIGH_LATENCY=2) else address_in;
  write_enable_mem &lt;= write_enable1 when (HIGH_LATENCY=2) else write_enable;
  data_in_mem &lt;= data_in1 when (HIGH_LATENCY=2) else data_in;

  data_out &lt;= data_out_mem when (HIGH_LATENCY=0) else data_out1;

  L1_registering : process(clock)
  begin
    if (clock&apos;event and clock=&apos;1&apos;) then
      data_out1 &lt;= data_out_mem;
    end if;
  end process;

  L1_single_proc : process(clock)
  begin
    if (clock&apos;event and clock=&apos;1&apos;) then
        if(READ_ONLY_MEMORY=0) then
          if(write_enable_mem(0)=&apos;1&apos;) then
-- synthesis translate_off
            if (to_integer(unsigned(address_in_mem((0+1)*BITSIZE_address_in-1 downto 0*BITSIZE_address_in))) &lt; n_elements) then
-- synthesis translate_on
              mem(to_integer(unsigned(address_in_mem((0+1)*BITSIZE_address_in-1 downto 0*BITSIZE_address_in)))) := data_in_mem((0+1)*BITSIZE_data_in-1 downto 0*BITSIZE_data_in);
-- synthesis translate_off
            end if;
-- synthesis translate_on
          end if;
        end if;
-- synthesis translate_off
        if (to_integer(unsigned(address_in_mem((0+1)*BITSIZE_address_in-1 downto 0*BITSIZE_address_in))) &lt; n_elements) then
-- synthesis translate_on
          data_out_mem((0+1)*BITSIZE_data_out-1 downto 0*BITSIZE_data_out) &lt;= mem(to_integer(unsigned(address_in_mem((0+1)*BITSIZE_address_in-1 downto 0*BITSIZE_address_in))));
-- synthesis translate_off
        else
          data_out_mem((0+1)*BITSIZE_data_out-1 downto 0*BITSIZE_data_out) &lt;= (others =&gt; &apos;X&apos;);
        end if;
-- synthesis translate_on
    end if;
  end process;
  L2_single_proc : process(clock)
  begin
    if (clock&apos;event and clock=&apos;1&apos;) then
        if(READ_ONLY_MEMORY=0) then
          if(write_enable_mem(1)=&apos;1&apos;) then
-- synthesis translate_off
            if (to_integer(unsigned(address_in_mem((1+1)*BITSIZE_address_in-1 downto 1*BITSIZE_address_in))) &lt; n_elements) then
-- synthesis translate_on
              mem(to_integer(unsigned(address_in_mem((1+1)*BITSIZE_address_in-1 downto 1*BITSIZE_address_in)))) := data_in_mem((1+1)*BITSIZE_data_in-1 downto 1*BITSIZE_data_in);
-- synthesis translate_off
            end if;
-- synthesis translate_on
          end if;
        end if;
-- synthesis translate_off
        if (to_integer(unsigned(address_in_mem((1+1)*BITSIZE_address_in-1 downto 1*BITSIZE_address_in))) &lt; n_elements) then
-- synthesis translate_on
          data_out_mem((1+1)*BITSIZE_data_out-1 downto 1*BITSIZE_data_out) &lt;= mem(to_integer(unsigned(address_in_mem((1+1)*BITSIZE_address_in-1 downto 1*BITSIZE_address_in))));
-- synthesis translate_off
        else
          data_out_mem((1+1)*BITSIZE_data_out-1 downto 1*BITSIZE_data_out) &lt;= (others =&gt; &apos;X&apos;);
        end if;
-- synthesis translate_on
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_SP_BRAM_BYTE</name>
      <circuit>
        <component_o id="STD_SP_BRAM_BYTE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_SP_BRAM_BYTE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="byte_offset">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_a" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="raddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="waddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <NP_functionality LIBRARY="STD_SP_BRAM_BYTE raddr waddr MEMORY_INIT_file n_mem_elements byte_offset BRAM_BITSIZE READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="
reg [7:0] dout_a;
reg [7:0] dout_a_registered;
reg [7:0] din_value1;
reg [BITSIZE_raddr-1:0] raddr1;
reg [BITSIZE_waddr-1:0] waddr1;
reg we_a1;
(* syn_ramstyle = &quot;no_rw_check&quot; *) reg [BRAM_BITSIZE-1:0] memory_a [0:n_mem_elements-1];
initial
begin
  $readmemb(MEMORY_INIT_file, memory_a, 0, n_mem_elements-1);
end
always @(posedge clock)
begin
  if(READ_ONLY_MEMORY==0)
  begin
    if(HIGH_LATENCY==0||HIGH_LATENCY==1)
    begin
      if(we_a)
        memory_a[waddr][(byte_offset+1)*8-1:byte_offset*8] &lt;= din_value;
    end
    else
    begin
      if(we_a1)
        memory_a[waddr1][(byte_offset+1)*8-1:byte_offset*8] &lt;= din_value1;
    end
  end
  if(HIGH_LATENCY==0)
  begin
    dout_a &lt;= memory_a[raddr][(byte_offset+1)*8-1:byte_offset*8];
  end
  else if(HIGH_LATENCY==1)
  begin
    dout_a_registered &lt;= memory_a[raddr][(byte_offset+1)*8-1:byte_offset*8];
    dout_a &lt;= dout_a_registered;
  end
  else
  begin
    din_value1  &lt;= din_value;
    raddr1  &lt;= raddr;
    waddr1  &lt;= waddr;
    we_a1  &lt;= we_a;
    dout_a_registered &lt;= memory_a[raddr1][(byte_offset+1)*8-1:byte_offset*8];
    dout_a &lt;= dout_a_registered;
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_NR_BRAM_BYTE</name>
      <circuit>
        <component_o id="STD_NR_BRAM_BYTE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_NR_BRAM_BYTE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="byte_offset">0</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_a" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="raddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_o id="waddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_vector_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_NR_BRAM_BYTE raddr waddr dout_a MEMORY_INIT_file n_mem_elements byte_offset BRAM_BITSIZE READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="STD_SP_BRAM_BYTE" 
          VERILOG_PROVIDED="
generate
genvar i1;
  for (i1=0; i1&lt;PORTSIZE_raddr; i1=i1+1)
  begin : L1
    STD_SP_BRAM_BYTE #(
      .BITSIZE_raddr(BITSIZE_raddr), 
      .BITSIZE_waddr(BITSIZE_waddr), 
      .MEMORY_INIT_file(MEMORY_INIT_file), 
      .n_mem_elements(n_mem_elements), 
      .byte_offset(byte_offset), 
      .BRAM_BITSIZE(BRAM_BITSIZE),
      .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
      .HIGH_LATENCY(HIGH_LATENCY)
     ) STD_SP_BRAM_BYTE_instance (
      .clock(clock), 
      .we_a(we_a), 
      .raddr(raddr[(i1+1)*BITSIZE_raddr-1:i1*BITSIZE_raddr]), 
      .waddr(waddr), 
      .din_value(din_value), 
      .dout_a(dout_a[(i1+1)*BITSIZE_dout_a-1:i1*BITSIZE_dout_a]));
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_N21_BYTEMUX</name>
      <circuit>
        <component_o id="STD_N21_BYTEMUX">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_N21_BYTEMUX"/>
          <port_o id="ctrl" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_vector_o id="din" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_o id="dout" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_N21_BYTEMUX ctrl din dout" VERILOG_PROVIDED="
wire [BITSIZE_dout-1:0] din_array [0:PORTSIZE_din-1];
genvar i1;
generate
  for(i1=0; i1&lt;PORTSIZE_din; i1=i1+1)
  begin: L1
    assign din_array[i1] = din[(i1+1)*BITSIZE_dout-1:i1*BITSIZE_dout];
  end
endgenerate

assign dout = din_array[ctrl];"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_LIVE_VALUE_TABLE_BYTE</name>
      <circuit>
        <component_o id="STD_LIVE_VALUE_TABLE_BYTE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_LIVE_VALUE_TABLE_BYTE"/>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="we_a" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="waddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="raddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="read_selector" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_LIVE_VALUE_TABLE_BYTE we_a waddr raddr read_selector n_mem_elements READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="
parameter max_portsize = PORTSIZE_waddr &gt; PORTSIZE_raddr ? PORTSIZE_waddr : PORTSIZE_raddr;
reg [(PORTSIZE_read_selector*BITSIZE_read_selector)+(-1):0] read_selector;
reg [(PORTSIZE_read_selector*BITSIZE_read_selector)+(-1):0] read_selector_registered;
reg [PORTSIZE_we_a-1:0] we_a1;
reg [(PORTSIZE_waddr*BITSIZE_waddr)+(-1):0] waddr1;
reg [(PORTSIZE_raddr*BITSIZE_raddr)+(-1):0] raddr1;
reg [BITSIZE_read_selector-1:0] live_value_table [0:n_mem_elements-1] /* synthesis syn_ramstyle = &quot;registers,no_rw_check&quot; */;

integer index;
initial
begin
  for(index=0; index&lt;n_mem_elements; index=index+1)
  begin
    live_value_table[index] = 0;
  end
end

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       raddr1 &lt;= raddr;
       waddr1 &lt;= waddr;
       we_a1 &lt;= we_a;
    end
  end
endgenerate

genvar i1;
generate
  for (i1=0; i1&lt;max_portsize; i1=i1+1)
  begin : L1
    always @(posedge clock)
    begin
      if(i1 &lt; PORTSIZE_waddr)
      begin
        if(READ_ONLY_MEMORY==0)
        begin
          if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
          begin
            if(we_a[i1])
              live_value_table[waddr[(i1+1)*BITSIZE_waddr-1:i1*BITSIZE_waddr]] &lt;= i1[BITSIZE_read_selector-1:0];
          end
          else
          begin
            if(we_a1[i1])
              live_value_table[waddr1[(i1+1)*BITSIZE_waddr-1:i1*BITSIZE_waddr]] &lt;= i1[BITSIZE_read_selector-1:0];
          end
        end
      end
      if(i1 &lt; PORTSIZE_raddr)
      begin
        if(HIGH_LATENCY == 0)
          read_selector[(i1+1)*BITSIZE_read_selector-1:i1*BITSIZE_read_selector] &lt;= live_value_table[raddr[(i1+1)*BITSIZE_raddr-1:i1*BITSIZE_raddr]];
        else if(HIGH_LATENCY == 1)
        begin
          read_selector_registered[(i1+1)*BITSIZE_read_selector-1:i1*BITSIZE_read_selector] &lt;= live_value_table[raddr[(i1+1)*BITSIZE_raddr-1:i1*BITSIZE_raddr]];
          read_selector[(i1+1)*BITSIZE_read_selector-1:i1*BITSIZE_read_selector] &lt;= read_selector_registered[(i1+1)*BITSIZE_read_selector-1:i1*BITSIZE_read_selector];
        end
        else
        begin
          read_selector_registered[(i1+1)*BITSIZE_read_selector-1:i1*BITSIZE_read_selector] &lt;= live_value_table[raddr1[(i1+1)*BITSIZE_raddr-1:i1*BITSIZE_raddr]];
          read_selector[(i1+1)*BITSIZE_read_selector-1:i1*BITSIZE_read_selector] &lt;= read_selector_registered[(i1+1)*BITSIZE_read_selector-1:i1*BITSIZE_read_selector];
        end
      end
    end
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_NRNW_BRAM_BYTE</name>
      <circuit>
        <component_o id="STD_NRNW_BRAM_BYTE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_NRNW_BRAM_BYTE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="byte_offset">0</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="we_a" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="raddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="waddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="dout_value" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_NRNW_BRAM_BYTE we_a raddr waddr din_value dout_value MEMORY_INIT_file n_mem_elements byte_offset BRAM_BITSIZE READ_ONLY_MEMORY HIGH_LATENCY" IP_COMPONENT="STD_NR_BRAM_BYTE,STD_N21_BYTEMUX,STD_LIVE_VALUE_TABLE_BYTE" VERILOG_PROVIDED="
`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_write = PORTSIZE_waddr == 1 ? 1 : $clog2(PORTSIZE_waddr);
`else
  localparam nbit_write = PORTSIZE_waddr == 1 ? 1 : log2(PORTSIZE_waddr);
`endif
wire [PORTSIZE_raddr*PORTSIZE_waddr*BITSIZE_dout_value-1:0] dout_a;
wire [PORTSIZE_raddr*PORTSIZE_waddr*BITSIZE_dout_value-1:0]dout_a_swapped;
wire [PORTSIZE_raddr*nbit_write-1:0] read_selector;
generate
genvar i1,i2;
  for (i1=0; i1&lt;PORTSIZE_waddr; i1=i1+1)
  begin : L1
    STD_NR_BRAM_BYTE #(.PORTSIZE_raddr(PORTSIZE_raddr),
      .BITSIZE_raddr(BITSIZE_raddr),
      .BITSIZE_waddr(BITSIZE_waddr),
      .BITSIZE_dout_a(BITSIZE_dout_value), 
      .PORTSIZE_dout_a(PORTSIZE_raddr),
      .MEMORY_INIT_file(MEMORY_INIT_file),
      .n_mem_elements(n_mem_elements),
      .byte_offset(byte_offset), 
      .BRAM_BITSIZE(BRAM_BITSIZE),
      .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
      .HIGH_LATENCY(HIGH_LATENCY)) 
    STD_NR_BRAM_BYTE_instance (
      .clock(clock), 
      .we_a(we_a[i1]), 
      .raddr(raddr), 
      .waddr(waddr[(i1+1)*BITSIZE_waddr-1:i1*BITSIZE_waddr]), 
      .din_value(din_value[(i1+1)*BITSIZE_din_value-1:i1*BITSIZE_din_value]), 
      .dout_a(dout_a[(i1+1)*PORTSIZE_raddr*BITSIZE_dout_value-1:i1*PORTSIZE_raddr*BITSIZE_dout_value]));
  end
  for (i1=0; i1&lt;PORTSIZE_raddr; i1=i1+1)
  begin : L2
    STD_N21_BYTEMUX#(
      .BITSIZE_ctrl(nbit_write), 
      .BITSIZE_din(BITSIZE_dout_value), 
      .BITSIZE_dout(BITSIZE_dout_value), 
      .PORTSIZE_din(PORTSIZE_waddr)
    ) STD_N21_BYTEMUX_instance (
      .ctrl(read_selector[(i1+1)*nbit_write-1:i1*nbit_write]), 
      .din(dout_a_swapped[(i1+1)*PORTSIZE_waddr*BITSIZE_dout_value-1:i1*PORTSIZE_waddr*BITSIZE_dout_value]), 
      .dout(dout_value[(i1+1)*BITSIZE_dout_value-1:i1*BITSIZE_dout_value]));
  end
  for (i1=0; i1&lt;PORTSIZE_raddr; i1=i1+1)
  begin : swapping_i1
    for (i2=0; i2&lt;PORTSIZE_waddr; i2=i2+1)
    begin : swapping_i2
      assign dout_a_swapped[(i2+1)*BITSIZE_dout_value+i1*PORTSIZE_waddr*BITSIZE_dout_value-1:i2*BITSIZE_dout_value+i1*PORTSIZE_waddr*BITSIZE_dout_value] = dout_a[(i1+1)*BITSIZE_dout_value+i2*PORTSIZE_raddr*BITSIZE_dout_value-1:i1*BITSIZE_dout_value+i2*PORTSIZE_raddr*BITSIZE_dout_value];
    end
  end
endgenerate

STD_LIVE_VALUE_TABLE_BYTE #(.BITSIZE_we_a(BITSIZE_we_a),
  .PORTSIZE_we_a(PORTSIZE_we_a),
  .BITSIZE_waddr(BITSIZE_waddr),
  .PORTSIZE_waddr(PORTSIZE_waddr),
  .BITSIZE_raddr(BITSIZE_raddr),
  .PORTSIZE_raddr(PORTSIZE_raddr),
  .BITSIZE_read_selector(nbit_write),
  .PORTSIZE_read_selector(PORTSIZE_raddr),
  .n_mem_elements(n_mem_elements),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) STD_LIVE_VALUE_TABLE_BYTE_instance (.clock(clock),
  .we_a(we_a),
  .waddr(waddr),
  .raddr(raddr),
  .read_selector(read_selector));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_LIVE_VALUE_TABLE</name>
      <circuit>
        <component_o id="STD_LIVE_VALUE_TABLE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_LIVE_VALUE_TABLE"/>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="we_a" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="waddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="raddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="read_selector" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_LIVE_VALUE_TABLE we_a waddr raddr read_selector n_mem_elements READ_ONLY_MEMORY HIGH_LATENCY" 
          VERILOG_PROVIDED="
parameter max_portsize = PORTSIZE_waddr &gt; PORTSIZE_raddr ? PORTSIZE_waddr : PORTSIZE_raddr;

reg [(PORTSIZE_read_selector*BITSIZE_read_selector)+(-1):0] read_selector_mem;
reg [(PORTSIZE_read_selector*BITSIZE_read_selector)+(-1):0] read_selector1;
wire [PORTSIZE_we_a-1:0] we_a_mem;
reg [PORTSIZE_we_a-1:0] we_a1;
wire [(PORTSIZE_waddr*BITSIZE_waddr)+(-1):0] waddr_mem;
reg [(PORTSIZE_waddr*BITSIZE_waddr)+(-1):0] waddr1;
wire [(PORTSIZE_raddr*BITSIZE_raddr)+(-1):0] raddr_mem;
reg [(PORTSIZE_raddr*BITSIZE_raddr)+(-1):0] raddr1;

reg [BITSIZE_read_selector-1:0] live_value_table [0:n_mem_elements-1] /* synthesis syn_ramstyle = &quot;registers,no_rw_check&quot; */;
integer index, i1;

initial
begin
  for(index=0; index&lt;n_mem_elements; index=index+1)
  begin
    live_value_table[index] = 0;
  end
end

always @(posedge clock)
begin
  for (i1=0; i1&lt;max_portsize; i1=i1+1)
  begin : L1
    if(i1 &lt; PORTSIZE_waddr &amp;&amp; READ_ONLY_MEMORY==0)
    begin
      if(we_a_mem[i1])
        live_value_table[waddr_mem[i1*BITSIZE_waddr +: BITSIZE_waddr]] &lt;= i1[BITSIZE_read_selector-1:0];
    end
    if(i1 &lt; PORTSIZE_raddr)
    begin
      read_selector_mem[i1*BITSIZE_read_selector +: BITSIZE_read_selector] &lt;= live_value_table[raddr_mem[i1*BITSIZE_raddr +: BITSIZE_raddr]];
    end
  end
end

assign read_selector = HIGH_LATENCY==0 ? read_selector_mem : read_selector1;
always @(posedge clock)
  read_selector1 &lt;= read_selector_mem;

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       raddr1 &lt;= raddr;
       waddr1 &lt;= waddr;
       we_a1 &lt;= we_a;
    end
    assign raddr_mem = raddr1;
    assign waddr_mem = waddr1;
    assign we_a_mem = we_a1;
  end
  else
  begin
    assign raddr_mem = raddr;
    assign waddr_mem = waddr;
    assign we_a_mem = we_a;
  end
endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_NR_BRAM</name>
      <circuit>
        <component_o id="STD_NR_BRAM">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_NR_BRAM"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_a" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="raddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_o id="waddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_vector_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_NR_BRAM raddr waddr din_value dout_a MEMORY_INIT_file n_mem_elements READ_ONLY_MEMORY HIGH_LATENCY" IP_COMPONENT="STD_SP_BRAM" VERILOG_PROVIDED="generate
genvar i1;
  for (i1=0; i1&lt;PORTSIZE_raddr; i1=i1+1)
  begin : L1
    STD_SP_BRAM #(
      .BITSIZE_address_inr(BITSIZE_raddr), 
      .BITSIZE_address_inw(BITSIZE_waddr), 
      .BITSIZE_data_in(BITSIZE_din_value), 
      .BITSIZE_data_out(BITSIZE_dout_a), 
      .MEMORY_INIT_file(MEMORY_INIT_file), 
      .n_elements(n_mem_elements), 
      .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
      .HIGH_LATENCY(HIGH_LATENCY)
      ) 
    STD_SP_BRAM_instance (
      .clock(clock), 
      .write_enable(we_a), 
      .address_inr(raddr[(i1+1)*BITSIZE_raddr-1:i1*BITSIZE_raddr]), 
      .address_inw(waddr), 
      .data_in(din_value), 
      .data_out(dout_a[(i1+1)*BITSIZE_dout_a-1:i1*BITSIZE_dout_a]));
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_NRNW_BRAM</name>
      <circuit>
        <component_o id="STD_NRNW_BRAM">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_NRNW_BRAM"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="we_a" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="raddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="waddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_value" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_NRNW_BRAM we_a raddr waddr din_value dout_value MEMORY_INIT_file n_mem_elements READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="STD_NR_BRAM,STD_N21_BYTEMUX,STD_LIVE_VALUE_TABLE" 
          VERILOG_PROVIDED="
`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_write = PORTSIZE_waddr == 1 ? 1 : $clog2(PORTSIZE_waddr);
`else
  localparam nbit_write = PORTSIZE_waddr == 1 ? 1 : log2(PORTSIZE_waddr);
`endif
wire [PORTSIZE_raddr*PORTSIZE_waddr*BITSIZE_dout_value-1:0] dout_a;
wire [PORTSIZE_raddr*PORTSIZE_waddr*BITSIZE_dout_value-1:0] dout_a_swapped;
wire [PORTSIZE_raddr*nbit_write-1:0] read_selector;
generate
genvar i1,i2;
  for (i1=0; i1&lt;PORTSIZE_waddr; i1=i1+1)
  begin : L1
    STD_NR_BRAM #(
      .PORTSIZE_raddr(PORTSIZE_raddr), 
      .BITSIZE_raddr(BITSIZE_raddr), 
      .BITSIZE_waddr(BITSIZE_waddr), 
      .BITSIZE_din_value(BITSIZE_din_value), 
      .BITSIZE_dout_a(BITSIZE_dout_value), 
      .PORTSIZE_dout_a(PORTSIZE_raddr), 
      .MEMORY_INIT_file(MEMORY_INIT_file), 
      .n_mem_elements(n_mem_elements),
      .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
      .HIGH_LATENCY(HIGH_LATENCY)
    )
    STD_NR_BRAM_instance (
      .clock(clock), 
      .we_a(we_a[i1]), 
      .raddr(raddr), 
      .waddr(waddr[i1*BITSIZE_waddr+:BITSIZE_waddr]), 
      .din_value(din_value[i1*BITSIZE_din_value+:BITSIZE_din_value]), 
      .dout_a(dout_a[i1*PORTSIZE_raddr*BITSIZE_dout_value+:PORTSIZE_raddr*BITSIZE_dout_value]));
  end
  for (i1=0; i1&lt;PORTSIZE_raddr; i1=i1+1)
  begin : L2
    STD_N21_BYTEMUX #(
      .BITSIZE_ctrl(nbit_write), 
      .PORTSIZE_din(PORTSIZE_waddr),
      .BITSIZE_din(BITSIZE_dout_value), 
      .BITSIZE_dout(BITSIZE_dout_value)
      )
    STD_N21_BYTEMUX_instance (
      .ctrl(read_selector[i1*nbit_write+:nbit_write]), 
      .din(dout_a_swapped[i1*PORTSIZE_waddr*BITSIZE_dout_value+:PORTSIZE_waddr*BITSIZE_dout_value]), 
      .dout(dout_value[i1*BITSIZE_dout_value+:BITSIZE_dout_value]));
  end
  for (i1=0; i1&lt;PORTSIZE_raddr; i1=i1+1)
  begin : swapping_i1
    for (i2=0; i2&lt;PORTSIZE_waddr; i2=i2+1)
    begin : swapping_i2
        assign dout_a_swapped[(i2+1)*BITSIZE_dout_value+i1*PORTSIZE_waddr*BITSIZE_dout_value-1:i2*BITSIZE_dout_value+i1*PORTSIZE_waddr*BITSIZE_dout_value] = dout_a[(i1+1)*BITSIZE_dout_value+i2*PORTSIZE_raddr*BITSIZE_dout_value-1:i1*BITSIZE_dout_value+i2*PORTSIZE_raddr*BITSIZE_dout_value];
    end
  end
endgenerate

STD_LIVE_VALUE_TABLE #(
  .BITSIZE_we_a(BITSIZE_we_a), 
  .PORTSIZE_we_a(PORTSIZE_we_a), 
  .BITSIZE_waddr(BITSIZE_waddr), 
  .PORTSIZE_waddr(PORTSIZE_waddr), 
  .BITSIZE_raddr(BITSIZE_raddr), 
  .PORTSIZE_raddr(PORTSIZE_raddr), 
  .BITSIZE_read_selector(nbit_write), 
  .PORTSIZE_read_selector(PORTSIZE_raddr), 
  .n_mem_elements(n_mem_elements),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)
) 
STD_LIVE_VALUE_TABLE_instance (
  .clock(clock), 
  .we_a(we_a), 
  .waddr(waddr), 
  .raddr(raddr), 
  .read_selector(read_selector)
);
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_NRNW_BRAM_GEN</name>
      <circuit>
        <component_o id="STD_NRNW_BRAM_GEN">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_NRNW_BRAM_GEN"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="we_a" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="raddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="waddr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_value" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_NRNW_BRAM_GEN we_a raddr waddr din_value dout_value MEMORY_INIT_file n_mem_elements READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="STD_NRNW_BRAM,STD_DP_BRAM" 
          VERILOG_PROVIDED="
parameter nbit_addr = BITSIZE_raddr &gt; BITSIZE_waddr ? BITSIZE_raddr : BITSIZE_waddr;
wire [2*nbit_addr-1:0] address_in;
generate
if(PORTSIZE_raddr == 2 &amp;&amp; PORTSIZE_waddr == 2)
begin
  assign address_in[0+:nbit_addr] = we_a[0] ? waddr[0+:BITSIZE_waddr] : raddr[0+:BITSIZE_raddr];
  assign address_in[nbit_addr+:nbit_addr] = we_a[1] ? waddr[BITSIZE_waddr+:BITSIZE_waddr] : raddr[BITSIZE_raddr+:BITSIZE_raddr];
  STD_DP_BRAM #(
    .PORTSIZE_write_enable(PORTSIZE_we_a),
    .BITSIZE_write_enable(1),
    .PORTSIZE_data_in(PORTSIZE_din_value), 
    .BITSIZE_data_in(BITSIZE_din_value), 
    .PORTSIZE_data_out(PORTSIZE_dout_value), 
    .BITSIZE_data_out(BITSIZE_dout_value), 
    .PORTSIZE_address_in(2), 
    .BITSIZE_address_in(nbit_addr), 
    .n_elements(n_mem_elements), 
    .MEMORY_INIT_file(MEMORY_INIT_file), 
    .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
    .HIGH_LATENCY(HIGH_LATENCY)
  ) STD_DP_BRAM_instance (
    .clock(clock), 
    .write_enable(we_a),
    .data_in(din_value),
    .address_in(address_in),
    .data_out(dout_value)
  );
end
else
begin
  STD_NRNW_BRAM #(
    .PORTSIZE_we_a(PORTSIZE_we_a),
    .BITSIZE_we_a(BITSIZE_we_a),
    .PORTSIZE_raddr(PORTSIZE_raddr), 
    .BITSIZE_raddr(BITSIZE_raddr), 
    .PORTSIZE_waddr(PORTSIZE_waddr), 
    .BITSIZE_waddr(BITSIZE_waddr), 
    .PORTSIZE_din_value(PORTSIZE_din_value), 
    .BITSIZE_din_value(BITSIZE_din_value), 
    .PORTSIZE_dout_value(PORTSIZE_dout_value), 
    .BITSIZE_dout_value(BITSIZE_dout_value), 
    .MEMORY_INIT_file(MEMORY_INIT_file), 
    .n_mem_elements(n_mem_elements),
    .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
    .HIGH_LATENCY(HIGH_LATENCY)
  ) STD_NRNW_BRAM_inst (
    .clock(clock), 
    .we_a(we_a), 
    .din_value(din_value), 
    .raddr(raddr), 
    .waddr(waddr), 
    .dout_value(dout_value)
  );
end
endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_NRNW_BRAM_SB</name>
      <circuit>
        <component_o id="STD_NRNW_BRAM_SB">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_NRNW_BRAM_SB"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="byte_offset">0</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="we_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Addr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_value" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_NRNW_BRAM_SB we_a Addr din_value dout_value MEMORY_INIT_file n_mem_elements BRAM_BITSIZE READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="STD_NRNW_BRAM_BYTE" 
          VERILOG_PROVIDED="localparam nbytes_per_word = BRAM_BITSIZE / 8;
wire [(PORTSIZE_din_value*BITSIZE_din_value)+(-1):0] din_value_swapped;
wire [(PORTSIZE_dout_value*BITSIZE_dout_value)+(-1):0] dout_value_swapped;
wire [(PORTSIZE_we_a*BITSIZE_we_a)+(-1):0] we_swapped;

generate
genvar i1,i2;
  for (i1=0; i1&lt;nbytes_per_word; i1=i1+1)
  begin
    STD_NRNW_BRAM_BYTE #(.BITSIZE_we_a(1),
  .PORTSIZE_we_a(PORTSIZE_we_a),
  .BITSIZE_raddr(BITSIZE_Addr),
  .PORTSIZE_raddr(PORTSIZE_Addr),
  .BITSIZE_waddr(BITSIZE_Addr),
  .PORTSIZE_waddr(PORTSIZE_Addr),
  .BITSIZE_din_value(8),
  .PORTSIZE_din_value(PORTSIZE_din_value),
  .BITSIZE_dout_value(8),
  .PORTSIZE_dout_value(PORTSIZE_dout_value),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_mem_elements(n_mem_elements),
  .byte_offset(i1),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) STD_NRNW_BRAM_BYTE_instance (.clock(clock),
  .we_a(we_swapped[(i1+1)*PORTSIZE_we_a-1:i1*PORTSIZE_we_a]),
  .raddr(Addr),
  .waddr(Addr),
  .din_value(din_value_swapped[(i1+1)*PORTSIZE_din_value*8-1:i1*PORTSIZE_din_value*8]),
  .dout_value(dout_value_swapped[(i1+1)*PORTSIZE_dout_value*8-1:i1*PORTSIZE_dout_value*8]));
  end
  for (i1=0; i1&lt;PORTSIZE_we_a; i1=i1+1)
  begin : swapping_i1_we
  for (i2=0; i2&lt;nbytes_per_word; i2=i2+1)
    begin : swapping_i2_we
      assign we_swapped[i2*PORTSIZE_we_a+i1] = we_a[i1*nbytes_per_word+i2];
    end
  end
  for (i1=0; i1&lt;PORTSIZE_din_value; i1=i1+1)
  begin : swapping_i1_in
  for (i2=0; i2&lt;nbytes_per_word; i2=i2+1)
    begin : swapping_i2_in
      assign din_value_swapped[i2*PORTSIZE_din_value*8+i1*8+7:i2*PORTSIZE_din_value*8+i1*8] = din_value[i1*nbytes_per_word*8+i2*8+7:i1*nbytes_per_word*8+i2*8];
    end
  end
  for (i1=0; i1&lt;PORTSIZE_dout_value; i1=i1+1)
  begin : swapping_i1_out
  for (i2=0; i2&lt;nbytes_per_word; i2=i2+1)
    begin : swapping_i2_out
      assign dout_value[i1*nbytes_per_word*8+i2*8+7:i1*nbytes_per_word*8+i2*8] = dout_value_swapped[i2*PORTSIZE_dout_value*8+i1*8+7:i2*PORTSIZE_dout_value*8+i1*8];
    end
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TRUE_DUAL_PORT</name>
      <circuit>
        <component_o id="TRUE_DUAL_PORT">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TRUE_DUAL_PORT"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="n_mem_elements">32</parameter>
          <parameter name="byte_offset">0</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_a" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_b" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Addr_a" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Addr_b" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="din_value_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="dout_value_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="dout_value_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <NP_functionality LIBRARY="TRUE_DUAL_PORT Addr_a Addr_b MEMORY_INIT_file n_mem_elements byte_offset BRAM_BITSIZE READ_ONLY_MEMORY HIGH_LATENCY"
            VERILOG_PROVIDED="
reg [7:0] dout_value_a1;
reg [7:0] dout_value_b1;
reg [7:0] dout_a_registered;
reg [7:0] dout_b_registered;
reg [7:0] din_value_a1;
reg [7:0] din_value_b1;
reg we_a1;
reg we_b1;
reg [BITSIZE_Addr_a-1:0] Addr_a1;
reg [BITSIZE_Addr_b-1:0] Addr_b1;

reg [BRAM_BITSIZE-1:0] memory [0:n_mem_elements-1] /* synthesis syn_ramstyle = &quot;no_rw_check&quot; */;



initial
begin
  $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
end
assign dout_value_a = dout_value_a1;
assign dout_value_b = dout_value_b1;
always @(posedge clock)
begin
  if(HIGH_LATENCY==0)
  begin
    if(we_a &amp;&amp; READ_ONLY_MEMORY==0)
    begin
      memory[Addr_a][(byte_offset+1)*8-1:byte_offset*8] &lt;= din_value_a;
    end
    dout_value_a1 &lt;= memory[Addr_a][(byte_offset+1)*8-1:byte_offset*8];
    if(we_b &amp;&amp; READ_ONLY_MEMORY==0)
    begin
      memory[Addr_b][(byte_offset+1)*8-1:byte_offset*8] &lt;= din_value_b;
    end
    dout_value_b1 &lt;= memory[Addr_b][(byte_offset+1)*8-1:byte_offset*8];
  end
  else if(HIGH_LATENCY==1)
  begin
    if(we_a &amp;&amp; READ_ONLY_MEMORY==0)
    begin
      memory[Addr_a][(byte_offset+1)*8-1:byte_offset*8] &lt;= din_value_a;
    end
    dout_a_registered &lt;= memory[Addr_a][(byte_offset+1)*8-1:byte_offset*8];
    dout_value_a1 &lt;= dout_a_registered;
    if(we_b &amp;&amp; READ_ONLY_MEMORY==0)
    begin
      memory[Addr_b][(byte_offset+1)*8-1:byte_offset*8] &lt;= din_value_b;
    end
    dout_b_registered &lt;= memory[Addr_b][(byte_offset+1)*8-1:byte_offset*8];
    dout_value_b1 &lt;= dout_b_registered;
  end
  else
  begin
    if(we_a1 &amp;&amp; READ_ONLY_MEMORY==0)
    begin
      memory[Addr_a1][(byte_offset+1)*8-1:byte_offset*8] &lt;= din_value_a1;
    end
    dout_a_registered &lt;= memory[Addr_a1][(byte_offset+1)*8-1:byte_offset*8];
    dout_value_a1 &lt;= dout_a_registered;
    if(we_b1 &amp;&amp; READ_ONLY_MEMORY==0)
    begin
      memory[Addr_b1][(byte_offset+1)*8-1:byte_offset*8] &lt;= din_value_b1;
    end
    dout_b_registered &lt;= memory[Addr_b1][(byte_offset+1)*8-1:byte_offset*8];
    dout_value_b1 &lt;= dout_b_registered;
    Addr_a1 &lt;= Addr_a;
    Addr_b1 &lt;= Addr_b;
    we_a1 &lt;= we_a;
    we_b1 &lt;= we_b;
    din_value_a1 &lt;= din_value_a;
    din_value_b1 &lt;= din_value_b;
  end
end
"
            VHDL_PROVIDED="
  signal dout_value_a1 : std_logic_vector(7 downto 0);
  signal dout_value_b1 : std_logic_vector(7 downto 0);
  signal dout_a_registered : std_logic_vector(7 downto 0);
  signal dout_b_registered : std_logic_vector(7 downto 0);
  signal din_value_a1 : std_logic_vector(7 downto 0);
  signal din_value_b1 : std_logic_vector(7 downto 0);
  signal we_a1 : std_logic;
  signal we_b1 : std_logic;
  signal Addr_a1 : std_logic_vector(BITSIZE_Addr_a-1 downto 0);
  signal Addr_b1 : std_logic_vector(BITSIZE_Addr_b-1 downto 0);

  type mem_type is array(0 to n_mem_elements-1) of std_logic_vector(7 downto 0);
  impure function InitMemFromFile (MemFileName : in string) return mem_type is
    FILE memfile : text open READ_MODE is MemFileName;
    variable MemFileLine : line;
    variable mem : mem_type;
    variable mem_row: std_logic_vector((BRAM_BITSIZE - 1) downto 0);
    begin
       for i in 0 to n_mem_elements-1 loop
        readline(memfile, MemFileLine);
        read(MemFileLine, mem_row);
        mem(i) := mem_row((byte_offset+1)*8-1 downto byte_offset*8);
      end loop;
      return mem;
  end function;

  signal mem : mem_type := InitMemFromFile(MEMORY_INIT_file);
begin
  dout_value_a &lt;= dout_value_a1;
  dout_value_b &lt;= dout_value_b1;
process (clock)
begin
  if (clock&apos;event and clock=&apos;1&apos;) then
    if(HIGH_LATENCY = 0) then
      if we_a = &apos;1&apos; and READ_ONLY_MEMORY=0 then
-- synthesis translate_off
        if (to_integer(unsigned(Addr_a)) &lt; n_mem_elements) then
-- synthesis translate_on
          mem(to_integer(unsigned(Addr_a))) &lt;= din_value_a;
-- synthesis translate_off
        end if;
-- synthesis translate_on
      end if;
-- synthesis translate_off
      if (to_integer(unsigned(Addr_a)) &gt;= n_mem_elements) then
        dout_value_a1 &lt;= (others =&gt; &apos;X&apos;);
      else
-- synthesis translate_on
        dout_value_a1 &lt;= mem(to_integer(unsigned(Addr_a)));
-- synthesis translate_off
      end if;
-- synthesis translate_on
      if we_b = &apos;1&apos; and READ_ONLY_MEMORY=0 then
-- synthesis translate_off
        if (to_integer(unsigned(Addr_b)) &lt; n_mem_elements) then
-- synthesis translate_on
          mem(to_integer(unsigned(Addr_b))) &lt;= din_value_b;
-- synthesis translate_off
        end if;
-- synthesis translate_on
      end if;
-- synthesis translate_off
      if (to_integer(unsigned(Addr_b)) &gt;= n_mem_elements) then
        dout_value_b1 &lt;= (others =&gt; &apos;X&apos;);
      else
-- synthesis translate_on
        dout_value_b1 &lt;= mem(to_integer(unsigned(Addr_b)));
-- synthesis translate_off
      end if;
-- synthesis translate_on
    elsif(HIGH_LATENCY = 1) then
      if we_a = &apos;1&apos; and READ_ONLY_MEMORY=0 then
-- synthesis translate_off
        if (to_integer(unsigned(Addr_a)) &lt; n_mem_elements) then
-- synthesis translate_on
          mem(to_integer(unsigned(Addr_a))) &lt;= din_value_a;
-- synthesis translate_off
        end if;
-- synthesis translate_on
      end if;
-- synthesis translate_off
      if (to_integer(unsigned(Addr_a)) &gt;= n_mem_elements) then
        dout_a_registered &lt;= (others =&gt; &apos;X&apos;);
      else
-- synthesis translate_on
        dout_a_registered &lt;= mem(to_integer(unsigned(Addr_a)));
-- synthesis translate_off
      end if;
-- synthesis translate_on
      dout_value_a1 &lt;= dout_a_registered;
      if we_b = &apos;1&apos; and READ_ONLY_MEMORY=0 then
-- synthesis translate_off
        if (to_integer(unsigned(Addr_b)) &lt; n_mem_elements) then
-- synthesis translate_on
          mem(to_integer(unsigned(Addr_b))) &lt;= din_value_b;
-- synthesis translate_off
        end if;
-- synthesis translate_on
      end if;
-- synthesis translate_off
      if (to_integer(unsigned(Addr_b)) &gt;= n_mem_elements) then
        dout_b_registered &lt;= (others =&gt; &apos;X&apos;);
      else
-- synthesis translate_on
        dout_b_registered &lt;= mem(to_integer(unsigned(Addr_b)));
-- synthesis translate_off
      end if;
-- synthesis translate_on
      dout_value_b1 &lt;= dout_b_registered;
    else
      if we_a1 = &apos;1&apos; and READ_ONLY_MEMORY=0 then
-- synthesis translate_off
        if (to_integer(unsigned(Addr_a1)) &lt; n_mem_elements) then
-- synthesis translate_on
          mem(to_integer(unsigned(Addr_a1))) &lt;= din_value_a1;
-- synthesis translate_off
        end if;
-- synthesis translate_on
      end if;
-- synthesis translate_off
      if (to_integer(unsigned(Addr_a1)) &gt;= n_mem_elements) then
        dout_a_registered &lt;= (others =&gt; &apos;X&apos;);
      else
-- synthesis translate_on
        dout_a_registered &lt;= mem(to_integer(unsigned(Addr_a1)));
-- synthesis translate_off
      end if;
-- synthesis translate_on
      dout_value_a1 &lt;= dout_a_registered;
      if we_b1 = &apos;1&apos; and READ_ONLY_MEMORY=0 then
-- synthesis translate_off
        if (to_integer(unsigned(Addr_b1)) &lt; n_mem_elements) then
-- synthesis translate_on
          mem(to_integer(unsigned(Addr_b1))) &lt;= din_value_b1;
-- synthesis translate_off
        end if;
-- synthesis translate_on
      end if;
-- synthesis translate_off
      if (to_integer(unsigned(Addr_b1)) &gt;= n_mem_elements) then
        dout_b_registered &lt;= (others =&gt; &apos;X&apos;);
      else
-- synthesis translate_on
        dout_b_registered &lt;= mem(to_integer(unsigned(Addr_b1)));
-- synthesis translate_off
      end if;
-- synthesis translate_on
      dout_value_b1 &lt;= dout_b_registered;
      Addr_a1 &lt;= Addr_a;
      Addr_b1 &lt;= Addr_b;
      we_a1 &lt;= we_a;
      we_b1 &lt;= we_b;
      din_value_a1 &lt;= din_value_a;
      din_value_b1 &lt;= din_value_b;
    end if;
  end if;
end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TRUE_DUAL_PORT_BYTE_ENABLING_RAM_NBE</name>
      <circuit>
        <component_o id="TRUE_DUAL_PORT_BYTE_ENABLING_RAM_NBE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <specialized>NanoXplore</specialized>
          <structural_type_descriptor id_type="TRUE_DUAL_PORT_BYTE_ENABLING_RAM_NBE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="bram_write0" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="bram_write1" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TRUE_DUAL_PORT_BYTE_ENABLING_RAM_NBE dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated_a din_value_aggregated_b be_a be_b MEMORY_INIT_file BRAM_BITSIZE n_byte_on_databus n_mem_elements READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="TRUE_DUAL_PORT" VERILOG_PROVIDED="
wire [n_byte_on_databus-1:0] we_a;
wire [n_byte_on_databus-1:0] we_b;

generate
genvar i1;
  for (i1=0; i1&lt;n_byte_on_databus; i1=i1+1)
  begin
    TRUE_DUAL_PORT #(
      .BITSIZE_Addr_a(BITSIZE_memory_addr_a),
      .BITSIZE_Addr_b(BITSIZE_memory_addr_b),
      .MEMORY_INIT_file(MEMORY_INIT_file),
      .n_mem_elements(n_mem_elements),
      .byte_offset(i1),
      .BRAM_BITSIZE(BRAM_BITSIZE),
      .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
      .HIGH_LATENCY(HIGH_LATENCY)
    ) TRUE_DUAL_PORT_instance (.clock(clock),
      .we_a(we_a[i1]),
      .we_b(we_b[i1]),
      .Addr_a(memory_addr_a),
      .Addr_b(memory_addr_b),
      .din_value_a(din_value_aggregated_a[(i1+1)*8-1:i1*8]),
      .din_value_b(din_value_aggregated_b[(i1+1)*8-1:(i1)*8]),
      .dout_value_a(dout_a[(i1+1)*8-1:i1*8]),
      .dout_value_b(dout_b[(i1+1)*8-1:i1*8])
    );
  end
endgenerate

generate
genvar i2_a;
  for (i2_a=0; i2_a&lt;n_byte_on_databus; i2_a=i2_a+1)
  begin  : write_enable_a
    assign we_a[i2_a] = (bram_write0) &amp;&amp; be_a[i2_a];
  end
endgenerate

generate
genvar i2_b;
  for (i2_b=0; i2_b&lt;n_byte_on_databus; i2_b=i2_b+1)
  begin  : write_enable_b
    assign we_b[i2_b] = (bram_write1) &amp;&amp; be_b[i2_b];
  end
endgenerate"
            VHDL_PROVIDED="signal we_a : std_logic_vector(n_byte_on_databus-1 downto 0);
signal we_b : std_logic_vector(n_byte_on_databus-1 downto 0);
signal dout_a_signal : std_logic_vector(BITSIZE_dout_a-1 downto 0) ;
signal dout_b_signal : std_logic_vector(BITSIZE_dout_b-1 downto 0) ;
begin
  N_TRUE_DUAL_PORT_GEN: 
    for i1 in 0 to n_byte_on_databus-1 generate
      TRUE_DUAL_PORT_instance : TRUE_DUAL_PORT generic map (BITSIZE_Addr_a=&gt;BITSIZE_memory_addr_a, BITSIZE_Addr_b=&gt;BITSIZE_memory_addr_b, MEMORY_INIT_file=&gt;MEMORY_INIT_file, n_mem_elements=&gt;n_mem_elements, byte_offset=&gt;i1, BRAM_BITSIZE=&gt;BRAM_BITSIZE, READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY, HIGH_LATENCY=&gt;HIGH_LATENCY) port map (clock=&gt;clock, we_a=&gt;(we_a(i1)), we_b=&gt;(we_b(i1)), Addr_a=&gt;(memory_addr_a), Addr_b=&gt;(memory_addr_b), din_value_a=&gt;(din_value_aggregated_a((i1+1)*8-1 downto i1*8)), din_value_b=&gt;(din_value_aggregated_b((i1+1)*8-1 downto (i1)*8)), dout_value_a=&gt;(dout_a_signal((i1+1)*8-1 downto i1*8)), dout_value_b=&gt;(dout_b_signal((i1+1)*8-1 downto i1*8)));
    end generate N_TRUE_DUAL_PORT_GEN;
  dout_a &lt;= dout_a_signal;
  dout_b &lt;= dout_b_signal;

  L_write_enable_a : process(bram_write0, be_a)
  begin
    for i2_a in 0 to n_byte_on_databus-1 loop
      we_a(i2_a) &lt;= bram_write0 and be_a(i2_a);
    end loop;
  end process;

  L_write_enable_b : process(bram_write1, be_b)
  begin
    for i2_b in 0 to n_byte_on_databus-1 loop
      we_b(i2_b) &lt;= bram_write1 and be_b(i2_b);
    end loop;
  end process;
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_NOBYTE_ENABLE</name>
      <circuit>
        <component_o id="BRAM_MEMORY_NOBYTE_ENABLE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_NOBYTE_ENABLE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="n_bytes">4</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_NOBYTE_ENABLE dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated be MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements n_bytes READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="STD_NRNW_BRAM_SB" 
          VERILOG_PROVIDED="
wire [n_byte_on_databus-1:0] we_a;
wire [n_byte_on_databus-1:0] we_b;


STD_NRNW_BRAM_SB #(.BITSIZE_we_a(n_byte_on_databus),
  .PORTSIZE_we_a(2),
  .BITSIZE_Addr(BITSIZE_memory_addr_a),
  .PORTSIZE_Addr(2),
  .BITSIZE_din_value(BRAM_BITSIZE),
  .PORTSIZE_din_value(2),
  .BITSIZE_dout_value(BITSIZE_dout_a),
  .PORTSIZE_dout_value(2),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_mem_elements(n_mem_elements),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) STD_NRNW_BRAM_instance (.clock(clock),
  .we_a({we_b,we_a}),
  .Addr({memory_addr_b,memory_addr_a}),
  .din_value(din_value_aggregated),
  .dout_value({dout_b,dout_a}));

generate
genvar i2_a;
  for (i2_a=0; i2_a&lt;n_byte_on_databus; i2_a=i2_a+1)
  begin  : write_enable_a
    assign we_a[i2_a] = (bram_write) &amp;&amp; be[i2_a];
  end
endgenerate

generate
genvar i2_b;
  for (i2_b=0; i2_b&lt;n_byte_on_databus; i2_b=i2_b+1)
  begin  : write_enable_b
    assign we_b[i2_b] = (bram_write) &amp;&amp; be[i2_b+n_byte_on_databus];
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_PMI</name>
      <circuit>
        <component_o id="BRAM_MEMORY_PMI">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_PMI"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="n_bytes">4</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_PMI dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated be MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements n_bytes READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="
reg bram_write1;
reg [BITSIZE_memory_addr_a-1:0] memory_addr_a1;
reg [BITSIZE_memory_addr_b-1:0] memory_addr_b1;
reg [BITSIZE_be-1:0] be1;
reg [BITSIZE_din_value_aggregated-1:0] din_value_aggregated1;

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       memory_addr_a1 &lt;= memory_addr_a;
       memory_addr_b1 &lt;= memory_addr_b;
       bram_write1 &lt;= bram_write;
       be1 &lt;= be;
       din_value_aggregated1 &lt;= din_value_aggregated;
    end
  end
endgenerate

generate
if(BRAM_BITSIZE == 8)
begin
  reg [(n_byte_on_databus)*8-1:0] dout_a_tmp;
  reg [(n_byte_on_databus)*8-1:0] dout_b_tmp;
  reg [(n_byte_on_databus)*8-1:0] dout_a_registered;
  reg [(n_byte_on_databus)*8-1:0] dout_b_registered;
  reg [(n_byte_on_databus)*8-1:0] memory [0:n_mem_elements-1]/* synthesis syn_ramstyle = &quot;no_rw_check&quot; */ ;
  assign dout_a = dout_a_tmp;
  assign dout_b = dout_b_tmp;
  initial
  begin
    $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
  end


  if(n_mem_elements == 1)
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write &amp;&amp; be[0] &amp;&amp; READ_ONLY_MEMORY==0)
          memory[memory_addr_a] &lt;= din_value_aggregated[BRAM_BITSIZE-1:0];
      end
      else
      begin
        if (bram_write1 &amp;&amp; be1[0] &amp;&amp; READ_ONLY_MEMORY==0)
          memory[memory_addr_a1] &lt;= din_value_aggregated1[BRAM_BITSIZE-1:0];
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a_tmp &lt;= dout_a_registered;
      end
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write &amp;&amp; be[1] &amp;&amp; READ_ONLY_MEMORY==0)
          memory[memory_addr_b] &lt;= din_value_aggregated[2*BRAM_BITSIZE-1:BRAM_BITSIZE];
      end
      else
      begin
        if (bram_write1 &amp;&amp; be1[1] &amp;&amp; READ_ONLY_MEMORY==0)
          memory[memory_addr_b1] &lt;= din_value_aggregated1[2*BRAM_BITSIZE-1:BRAM_BITSIZE];
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_b];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_b];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_b1];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
  else
  begin
    always @(posedge clock)
    begin
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write &amp;&amp; be[0] &amp;&amp; READ_ONLY_MEMORY==0)
          memory[memory_addr_a] &lt;= din_value_aggregated[BRAM_BITSIZE-1:0];
      end
      else
      begin
        if (bram_write1 &amp;&amp; be1[0] &amp;&amp; READ_ONLY_MEMORY==0)
          memory[memory_addr_a1] &lt;= din_value_aggregated1[BRAM_BITSIZE-1:0];
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a_tmp &lt;= dout_a_registered;
      end
    end
    always @(posedge clock)
    begin
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write &amp;&amp; be[1] &amp;&amp; READ_ONLY_MEMORY==0)
          memory[memory_addr_b] &lt;= din_value_aggregated[2*BRAM_BITSIZE-1:BRAM_BITSIZE];
      end
      else
      begin
        if (bram_write1 &amp;&amp; be1[1] &amp;&amp; READ_ONLY_MEMORY==0)
          memory[memory_addr_b1] &lt;= din_value_aggregated1[2*BRAM_BITSIZE-1:BRAM_BITSIZE];
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_b];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_b];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_b1];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
end
else
begin
  if(n_mem_elements == 1)
  begin
    reg [(n_byte_on_databus)*8-1:0] dout_a_tmp;
    reg [(n_byte_on_databus)*8-1:0] dout_b_tmp;
    reg [(n_byte_on_databus)*8-1:0] dout_a_registered;
    reg [(n_byte_on_databus)*8-1:0] dout_b_registered;
    reg [(n_byte_on_databus)*8-1:0] memory [0:n_mem_elements-1]/* synthesis syn_ramstyle = &quot;no_rw_check&quot; */ ;
    assign dout_a = dout_a_tmp;
    assign dout_b = dout_b_tmp;
    initial
    begin
      $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
    end
    always @(posedge clock)
    begin
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write)
        begin : L11_write
          integer i11;
          for (i11=0; i11&lt;n_byte_on_databus; i11=i11+1)
          begin
            if(be[i11] &amp;&amp; READ_ONLY_MEMORY==0)
              memory[memory_addr_a][i11*8+:8] &lt;= din_value_aggregated[i11*8+:8];
          end
        end
      end
      else
      begin
        if (bram_write1)
        begin : L11_write1
          integer i11;
          for (i11=0; i11&lt;n_byte_on_databus; i11=i11+1)
          begin
            if(be1[i11] &amp;&amp; READ_ONLY_MEMORY==0)
              memory[memory_addr_a1][i11*8+:8] &lt;= din_value_aggregated1[i11*8+:8];
          end
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1];
        dout_a_tmp &lt;= dout_a_registered;
      end
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write &amp;&amp; n_bytes &gt; BRAM_BITSIZE/8)
        begin : L22_write
          integer i22;
          for (i22=0; i22&lt;n_byte_on_databus; i22=i22+1)
          begin
            if(be[i22+n_byte_on_databus] &amp;&amp; READ_ONLY_MEMORY==0)
              memory[memory_addr_b][i22*8+:8] &lt;= din_value_aggregated[(i22+n_byte_on_databus)*8+:8];
          end
        end
      end
      else
      begin
        if (bram_write1 &amp;&amp; n_bytes &gt; BRAM_BITSIZE/8)
        begin : L22_write1
          integer i22;
          for (i22=0; i22&lt;n_byte_on_databus; i22=i22+1)
          begin
            if(be1[i22+n_byte_on_databus] &amp;&amp; READ_ONLY_MEMORY==0)
              memory[memory_addr_b1][i22*8+:8] &lt;= din_value_aggregated1[(i22+n_byte_on_databus)*8+:8];
          end
        end
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_b];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_b];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_b1];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
  else
  begin
    if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
    begin
      pmi_ram_dp_true_be #(.pmi_addr_depth_a(n_mem_elements),
        .pmi_addr_width_a(BITSIZE_memory_addr_a),
        .pmi_data_width_a((n_byte_on_databus)*8),
        .pmi_addr_depth_b(n_mem_elements),
        .pmi_addr_width_b(BITSIZE_memory_addr_a),
        .pmi_data_width_b((n_byte_on_databus)*8),
        .pmi_regmode_a(HIGH_LATENCY== 0 ? &quot;noreg&quot; : &quot;reg&quot;),
        .pmi_regmode_b(HIGH_LATENCY== 0 ? &quot;noreg&quot; : &quot;reg&quot;),
        .pmi_gsr(&quot;disable&quot;),
        .pmi_resetmode(&quot;sync&quot;),
        .pmi_optimization(&quot;speed&quot;),
        .pmi_init_file(MEMORY_INIT_file),
        .pmi_init_file_format(&quot;binary&quot;),
        .pmi_write_mode_a(&quot;normal&quot;),
        .pmi_write_mode_b(&quot;normal&quot;),
        .pmi_byte_size(8),
        .pmi_family(&quot;ECP3&quot;),
        .module_type(&quot;pmi_ram_dp_true_be&quot;)) pmi_ram_dp_true_be_instance
       (.DataInA(din_value_aggregated[BRAM_BITSIZE-1:0]),
        .DataInB(din_value_aggregated[2*BRAM_BITSIZE-1:BRAM_BITSIZE]),
        .AddressA(memory_addr_a),
        .AddressB(memory_addr_b),
        .ClockA(clock),
        .ClockB(clock),
        .ClockEnA(1&apos;b1),
        .ClockEnB(1&apos;b1),
        .WrA(bram_write &amp;&amp; READ_ONLY_MEMORY==0),
        .WrB(bram_write &amp;&amp; READ_ONLY_MEMORY==0),
        .ResetA(1&apos;b0),
        .ResetB(1&apos;b0),
        .ByteEnA(be[n_byte_on_databus-1:0]),
        .ByteEnB(be[2*n_byte_on_databus-1:n_byte_on_databus]),
        .QA(dout_a),
        .QB(dout_b)) /*synthesis syn_black_box*/;
    end
    else
    begin
      pmi_ram_dp_true_be #(.pmi_addr_depth_a(n_mem_elements),
        .pmi_addr_width_a(BITSIZE_memory_addr_a),
        .pmi_data_width_a((n_byte_on_databus)*8),
        .pmi_addr_depth_b(n_mem_elements),
        .pmi_addr_width_b(BITSIZE_memory_addr_a),
        .pmi_data_width_b((n_byte_on_databus)*8),
        .pmi_regmode_a(HIGH_LATENCY== 0 ? &quot;noreg&quot; : &quot;reg&quot;),
        .pmi_regmode_b(HIGH_LATENCY== 0 ? &quot;noreg&quot; : &quot;reg&quot;),
        .pmi_gsr(&quot;disable&quot;),
        .pmi_resetmode(&quot;sync&quot;),
        .pmi_optimization(&quot;speed&quot;),
        .pmi_init_file(MEMORY_INIT_file),
        .pmi_init_file_format(&quot;binary&quot;),
        .pmi_write_mode_a(&quot;normal&quot;),
        .pmi_write_mode_b(&quot;normal&quot;),
        .pmi_byte_size(8),
        .pmi_family(&quot;ECP3&quot;),
        .module_type(&quot;pmi_ram_dp_true_be&quot;)) pmi_ram_dp_true_be_instance
       (.DataInA(din_value_aggregated1[BRAM_BITSIZE-1:0]),
        .DataInB(din_value_aggregated1[2*BRAM_BITSIZE-1:BRAM_BITSIZE]),
        .AddressA(memory_addr_a1),
        .AddressB(memory_addr_b1),
        .ClockA(clock),
        .ClockB(clock),
        .ClockEnA(1&apos;b1),
        .ClockEnB(1&apos;b1),
        .WrA(bram_write1 &amp;&amp; READ_ONLY_MEMORY==0),
        .WrB(bram_write1 &amp;&amp; READ_ONLY_MEMORY==0),
        .ResetA(1&apos;b0),
        .ResetB(1&apos;b0),
        .ByteEnA(be1[n_byte_on_databus-1:0]),
        .ByteEnB(be1[2*n_byte_on_databus-1:n_byte_on_databus]),
        .QA(dout_a),
        .QB(dout_b)) /*synthesis syn_black_box*/;
    end
  end
end
endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_CORE</name>
      <circuit>
        <component_o id="BRAM_MEMORY_CORE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_CORE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="n_bytes">4</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_CORE dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated be MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements n_bytes READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="BRAM_MEMORY_CORE_SMALL,TRUE_DUAL_PORT_BYTE_ENABLING_RAM"
          VERILOG_PROVIDED="
generate
if(n_mem_elements == 1)
begin
  BRAM_MEMORY_CORE_SMALL #(
    .PORTSIZE_bram_write(2), 
    .BITSIZE_bram_write(1), 
    .PORTSIZE_memory_addr_a(2), 
    .BITSIZE_memory_addr_a(BITSIZE_memory_addr_a), 
    .PORTSIZE_din_value_aggregated(2), 
    .BITSIZE_din_value_aggregated(BITSIZE_din_value_aggregated/2), 
    .PORTSIZE_be(2), 
    .BITSIZE_be(BITSIZE_be/2), 
    .PORTSIZE_dout_a(2), 
    .BITSIZE_dout_a(BITSIZE_dout_a), 
    .MEMORY_INIT_file(MEMORY_INIT_file), 
    .n_byte_on_databus(n_byte_on_databus), 
    .n_mem_elements(n_mem_elements), 
    .n_bytes(n_bytes), 
    .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
    .HIGH_LATENCY(HIGH_LATENCY)
  ) BRAM_MEMORY_instance_small (
    .clock(clock), 
    .bram_write({bram_write,bram_write}), 
    .memory_addr_a({memory_addr_b,memory_addr_a}), 
    .din_value_aggregated(din_value_aggregated), 
    .be(be), 
    .dout_a({dout_b,dout_a})
  );
end
else
begin
  TRUE_DUAL_PORT_BYTE_ENABLING_RAM #(
    .BITSIZE_memory_addr_a(BITSIZE_memory_addr_a), 
    .BITSIZE_memory_addr_b(BITSIZE_memory_addr_b), 
    .BITSIZE_din_value_aggregated_a(BITSIZE_din_value_aggregated/2), 
    .BITSIZE_din_value_aggregated_b(BITSIZE_din_value_aggregated/2), 
    .BITSIZE_be_a(BITSIZE_be/2), 
    .BITSIZE_be_b(BITSIZE_be/2), 
    .BITSIZE_dout_a(BITSIZE_dout_a), 
    .BITSIZE_dout_b(BITSIZE_dout_b), 
    .MEMORY_INIT_file(MEMORY_INIT_file), 
    .BRAM_BITSIZE(BRAM_BITSIZE), 
    .n_byte_on_databus(n_byte_on_databus), 
    .n_mem_elements(n_mem_elements), 
    .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
    .HIGH_LATENCY(HIGH_LATENCY)
  ) TRUE_DUAL_PORT_BYTE_ENABLING_RAM_instance (
    .clock(clock), 
    .bram_write0(bram_write), 
    .bram_write1(bram_write), 
    .memory_addr_a(memory_addr_a), 
    .memory_addr_b(memory_addr_b), 
    .din_value_aggregated_a(din_value_aggregated[BITSIZE_din_value_aggregated/2-1:0]), 
    .din_value_aggregated_b(din_value_aggregated[BITSIZE_din_value_aggregated-1:BITSIZE_din_value_aggregated/2]), 
    .be_a(be[BITSIZE_be/2-1:0]), 
    .be_b(be[BITSIZE_be-1:BITSIZE_be/2]), 
    .dout_a(dout_a), 
    .dout_b(dout_b)
  );
end
endgenerate
"
            VHDL_PROVIDED="
signal memory_addr_a_tmp : std_logic_vector(2*BITSIZE_memory_addr_a-1 downto 0);
signal dout_a_tmp : std_logic_vector(2*BITSIZE_dout_a-1 downto 0);
signal bram_write_tmp : std_logic_vector(1 downto 0);
begin
BRAM_MEMORY_CORE_SMALL_case : if (n_mem_elements = 1) generate
  memory_addr_a_tmp(BITSIZE_memory_addr_a-1 downto 0) &lt;= memory_addr_a;
  memory_addr_a_tmp(2*BITSIZE_memory_addr_a-1 downto BITSIZE_memory_addr_a) &lt;= memory_addr_b;
  dout_a &lt;= dout_a_tmp(BITSIZE_dout_a-1 downto 0);
  dout_b &lt;= dout_a_tmp((2*BITSIZE_dout_a)-1 downto BITSIZE_dout_a);
  bram_write_tmp(0) &lt;= bram_write;
  bram_write_tmp(1) &lt;= bram_write;
  BRAM_MEMORY_CORE_SMALL_instance : BRAM_MEMORY_CORE_SMALL generic map (
    PORTSIZE_bram_write=&gt;2, 
    BITSIZE_bram_write=&gt;1, 
    PORTSIZE_memory_addr_a=&gt;2, 
    BITSIZE_memory_addr_a=&gt;BITSIZE_memory_addr_a, 
    PORTSIZE_din_value_aggregated=&gt;2, 
    BITSIZE_din_value_aggregated=&gt;BITSIZE_din_value_aggregated/2,
    PORTSIZE_be=&gt;2,
    BITSIZE_be=&gt;BITSIZE_be/2, 
    PORTSIZE_dout_a=&gt;2, 
    BITSIZE_dout_a=&gt;BITSIZE_dout_a, 
    MEMORY_INIT_file=&gt;MEMORY_INIT_file, 
    n_byte_on_databus=&gt;n_byte_on_databus, 
    n_mem_elements=&gt;n_mem_elements, 
    n_bytes=&gt;n_bytes, 
    READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY,
    HIGH_LATENCY=&gt;HIGH_LATENCY
  ) port map (
    clock=&gt;clock, 
    bram_write=&gt;bram_write_tmp, 
    memory_addr_a=&gt;memory_addr_a_tmp, 
    din_value_aggregated=&gt;din_value_aggregated, 
    be=&gt;be, dout_a=&gt;dout_a_tmp
  );
end generate;
TRUE_DUAL_PORT_BYTE_ENABLING_RAM_else : if(n_mem_elements /= 1) generate
  TRUE_DUAL_PORT_BYTE_ENABLING_RAM_instance : TRUE_DUAL_PORT_BYTE_ENABLING_RAM generic map (
    BITSIZE_memory_addr_a=&gt;BITSIZE_memory_addr_a, 
    BITSIZE_memory_addr_b=&gt;BITSIZE_memory_addr_b, 
    BITSIZE_din_value_aggregated_a=&gt;BITSIZE_din_value_aggregated/2, 
    BITSIZE_din_value_aggregated_b=&gt;BITSIZE_din_value_aggregated/2, 
    BITSIZE_be_a=&gt;BITSIZE_be/2, 
    BITSIZE_be_b=&gt;BITSIZE_be/2, 
    BITSIZE_dout_a=&gt;BITSIZE_dout_a, 
    BITSIZE_dout_b=&gt;BITSIZE_dout_b, 
    MEMORY_INIT_file=&gt;MEMORY_INIT_file, 
    BRAM_BITSIZE=&gt;BRAM_BITSIZE, 
    n_byte_on_databus=&gt;n_byte_on_databus, 
    n_mem_elements=&gt;n_mem_elements,
    READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY,
    HIGH_LATENCY=&gt;HIGH_LATENCY
  ) port map (
    clock=&gt;clock, 
    bram_write0=&gt;bram_write, 
    bram_write1=&gt;bram_write, 
    memory_addr_a=&gt;memory_addr_a, 
    memory_addr_b=&gt;memory_addr_b, 
    din_value_aggregated_a=&gt;din_value_aggregated(BITSIZE_din_value_aggregated/2-1 downto 0), 
    din_value_aggregated_b=&gt;din_value_aggregated(BITSIZE_din_value_aggregated-1 downto BITSIZE_din_value_aggregated/2), 
    be_a=&gt;be(BITSIZE_be/2-1 downto 0), 
    be_b=&gt;be(BITSIZE_be-1 downto BITSIZE_be/2), 
    dout_a=&gt;dout_a, 
    dout_b=&gt;dout_b
  );
end generate;
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_CORE_SMALL</name>
      <circuit>
        <component_o id="BRAM_MEMORY_CORE_SMALL">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_CORE_SMALL"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="n_bytes">4</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="bram_write" dir="IN">
            <structural_type_descriptor  type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value_aggregated" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="be" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_CORE_SMALL dout_a bram_write memory_addr_a din_value_aggregated be MEMORY_INIT_file n_byte_on_databus n_mem_elements n_bytes READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="
reg [PORTSIZE_bram_write-1:0] bram_write1;
reg [(PORTSIZE_memory_addr_a*BITSIZE_memory_addr_a)-1:0] memory_addr_a1;
reg [(PORTSIZE_be*BITSIZE_be)-1:0] be1;
reg [(PORTSIZE_din_value_aggregated*BITSIZE_din_value_aggregated)-1:0] din_value_aggregated1;
reg [(PORTSIZE_dout_a*BITSIZE_dout_a)-1:0] dout_a_tmp;
reg [(PORTSIZE_dout_a*BITSIZE_dout_a)-1:0] dout_a_registered;
reg [(n_byte_on_databus)*8-1:0] memory [0:n_mem_elements-1]/* synthesis syn_ramstyle = &quot;registers,no_rw_check&quot; */ ;
integer p1;

initial
begin
  $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
end

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       memory_addr_a1 &lt;= memory_addr_a;
       bram_write1 &lt;= bram_write;
       be1 &lt;= be;
       din_value_aggregated1 &lt;= din_value_aggregated;
    end
  end
endgenerate

assign dout_a = dout_a_tmp;

  always @(posedge clock)
  begin
    for (p1=0; p1&lt;PORTSIZE_memory_addr_a; p1=p1+1)
    begin
      if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
      begin
        if (bram_write[p1] &amp;&amp; READ_ONLY_MEMORY==0)
        begin : L11_write
          integer i11;
          for (i11=0; i11&lt;n_byte_on_databus; i11=i11+1)
          begin
            if(be[i11+p1*n_byte_on_databus])
              memory[memory_addr_a[p1*BITSIZE_memory_addr_a+:BITSIZE_memory_addr_a]][i11*8+:8] &lt;= din_value_aggregated[p1*n_byte_on_databus*8+i11*8+:8];
          end
        end
      end
      else
      begin
        if (bram_write1[p1] &amp;&amp; READ_ONLY_MEMORY==0)
        begin : L11_write1
          integer i11;
          for (i11=0; i11&lt;n_byte_on_databus; i11=i11+1)
          begin
            if(be1[i11+p1*n_byte_on_databus])
              memory[memory_addr_a1[p1*BITSIZE_memory_addr_a+:BITSIZE_memory_addr_a]][i11*8+:8] &lt;= din_value_aggregated1[p1*n_byte_on_databus*8+i11*8+:8];
          end
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp[p1*BITSIZE_dout_a+:BITSIZE_dout_a] &lt;= memory[memory_addr_a[p1*BITSIZE_memory_addr_a+:BITSIZE_memory_addr_a]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered[p1*BITSIZE_dout_a+:BITSIZE_dout_a] &lt;= memory[memory_addr_a[p1*BITSIZE_memory_addr_a+:BITSIZE_memory_addr_a]];
        dout_a_tmp[p1*BITSIZE_dout_a+:BITSIZE_dout_a] &lt;= dout_a_registered[p1*BITSIZE_dout_a+:BITSIZE_dout_a];
      end
      else
      begin
        dout_a_registered[p1*BITSIZE_dout_a+:BITSIZE_dout_a] &lt;= memory[memory_addr_a1[p1*BITSIZE_memory_addr_a+:BITSIZE_memory_addr_a]];
        dout_a_tmp[p1*BITSIZE_dout_a+:BITSIZE_dout_a] &lt;= dout_a_registered[p1*BITSIZE_dout_a+:BITSIZE_dout_a];
      end
    end
  end
"
            VHDL_PROVIDED="
  signal bram_write1 : std_logic_vector(PORTSIZE_bram_write-1 downto 0);
  signal memory_addr_a1 : std_logic_vector((PORTSIZE_memory_addr_a*BITSIZE_memory_addr_a)-1 downto 0);
  signal be1 : std_logic_vector((PORTSIZE_be*BITSIZE_be)-1 downto 0);
  signal din_value_aggregated1 : std_logic_vector((PORTSIZE_din_value_aggregated*BITSIZE_din_value_aggregated)-1 downto 0);
  signal dout_a_tmp : std_logic_vector((PORTSIZE_dout_a*BITSIZE_dout_a)-1 downto 0);
  signal dout_a_registered : std_logic_vector((PORTSIZE_dout_a*BITSIZE_dout_a)-1 downto 0);

  type mem_type is array (n_mem_elements-1 downto 0) of std_logic_vector((n_byte_on_databus)*8-1 downto 0);

  impure function InitMemFromFile (MemFileName : in string) return mem_type is
    FILE memfile  :  text open READ_MODE is MemFileName;
    variable MemFileLine  :  line;
    variable mem  :  mem_type;
    begin
      for i in 0 to n_mem_elements-1 loop
        readline(memfile, MemFileLine);
        read(MemFileLine, mem(i));
      end loop;
      return mem;
  end function;
  signal mem : mem_type := InitMemFromFile(MEMORY_INIT_file);
begin

  DelayProcess : process(clock)
  begin
    if (clock&apos;event and clock=&apos;1&apos;) then
       if(HIGH_LATENCY=2) then
         memory_addr_a1 &lt;= memory_addr_a;
         bram_write1 &lt;= bram_write;
         be1 &lt;= be;
         din_value_aggregated1 &lt;= din_value_aggregated;
       end if;
    end if;
  end process;
  
  dout_a &lt;= dout_a_tmp;

  L1_single_readwrite : process(clock)
  begin
    if (clock&apos;event and clock=&apos;1&apos;) then
      for p1 in 0 to PORTSIZE_memory_addr_a-1 loop
        if(HIGH_LATENCY = 0 or HIGH_LATENCY = 1) then
          if(bram_write(p1) =&apos;1&apos; and READ_ONLY_MEMORY=0) then
            for index2 in 0 to n_byte_on_databus-1 loop
              if(be(index2+p1*n_byte_on_databus)=&apos;1&apos;) then
-- synthesis translate_off
                if (to_integer(unsigned(memory_addr_a((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))) &lt; n_mem_elements) then
-- synthesis translate_on
                  mem(to_integer(unsigned(memory_addr_a((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))))((index2+1)*8-1 downto index2*8) &lt;= din_value_aggregated((index2+1)*8+p1*n_byte_on_databus*8-1 downto (index2)*8+p1*n_byte_on_databus*8);
-- synthesis translate_off
                end if;
-- synthesis translate_on
              end if;
            end loop;
          end if;
        else
          if(bram_write1(p1) =&apos;1&apos; and READ_ONLY_MEMORY=0) then
            for index2 in 0 to n_byte_on_databus-1 loop
              if(be1(index2+p1*n_byte_on_databus)=&apos;1&apos;) then
-- synthesis translate_off
                if (to_integer(unsigned(memory_addr_a1((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))) &lt; n_mem_elements) then
-- synthesis translate_on
                  mem(to_integer(unsigned(memory_addr_a1((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))))((index2+1)*8-1 downto index2*8) &lt;= din_value_aggregated1((index2+1)*8+p1*n_byte_on_databus*8-1 downto (index2)*8+p1*n_byte_on_databus*8);
-- synthesis translate_off
                end if;
-- synthesis translate_on
              end if;
            end loop;
          end if;
        end if;
        if(HIGH_LATENCY = 0) then
-- synthesis translate_off
          if (to_integer(unsigned(memory_addr_a((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))) &lt; n_mem_elements) then
-- synthesis translate_on
            dout_a_tmp((p1+1)*BITSIZE_dout_a-1 downto p1*BITSIZE_dout_a)  &lt;= mem(to_integer(unsigned(memory_addr_a((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))));
-- synthesis translate_off
          else
            dout_a_tmp((p1+1)*BITSIZE_dout_a-1 downto p1*BITSIZE_dout_a)  &lt;= (others =&gt; &apos;X&apos;);
          end if;
-- synthesis translate_on
        elsif(HIGH_LATENCY = 1) then
-- synthesis translate_off
          if (to_integer(unsigned(memory_addr_a((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))) &lt; n_mem_elements) then
-- synthesis translate_on
            dout_a_registered((p1+1)*BITSIZE_dout_a-1 downto p1*BITSIZE_dout_a)  &lt;= mem(to_integer(unsigned(memory_addr_a((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))));
-- synthesis translate_off
          else
            dout_a_registered((p1+1)*BITSIZE_dout_a-1 downto p1*BITSIZE_dout_a)  &lt;= (others =&gt; &apos;X&apos;);
          end if;
-- synthesis translate_on
          dout_a_tmp  &lt;= dout_a_registered;
        else
-- synthesis translate_off
          if (to_integer(unsigned(memory_addr_a1((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))) &lt; n_mem_elements) then
-- synthesis translate_on
            dout_a_registered((p1+1)*BITSIZE_dout_a-1 downto p1*BITSIZE_dout_a) &lt;= mem(to_integer(unsigned(memory_addr_a1((p1+1)*BITSIZE_memory_addr_a-1 downto p1*BITSIZE_memory_addr_a))));
-- synthesis translate_off
          else
            dout_a_registered((p1+1)*BITSIZE_dout_a-1 downto p1*BITSIZE_dout_a) &lt;= (others =&gt; &apos;X&apos;);
          end if;
-- synthesis translate_on
          dout_a_tmp &lt;= dout_a_registered;
        end if;
      end loop;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TRUE_DUAL_PORT_BYTE_ENABLING_RAM</name>
      <circuit>
        <component_o id="TRUE_DUAL_PORT_BYTE_ENABLING_RAM">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TRUE_DUAL_PORT_BYTE_ENABLING_RAM"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="bram_write0" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="bram_write1" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="memory_addr_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din_value_aggregated_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="be_b" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout_b" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TRUE_DUAL_PORT_BYTE_ENABLING_RAM dout_a dout_b memory_addr_a memory_addr_b din_value_aggregated_a din_value_aggregated_b be_a be_b MEMORY_INIT_file BRAM_BITSIZE n_byte_on_databus n_mem_elements READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="
wire [n_byte_on_databus-1:0] we_a;
wire [n_byte_on_databus-1:0] we_b;
reg [n_byte_on_databus-1:0] we_a1;
reg [n_byte_on_databus-1:0] we_b1;
reg [BITSIZE_din_value_aggregated_a-1:0] din_value_aggregated_a1;
reg [BITSIZE_din_value_aggregated_b-1:0] din_value_aggregated_b1;

reg [BITSIZE_dout_a-1:0] dout_a;
reg [BITSIZE_dout_a-1:0] dout_a_registered;
reg [BITSIZE_dout_b-1:0] dout_b;
reg [BITSIZE_dout_b-1:0] dout_b_registered;
reg [BITSIZE_memory_addr_a-1:0] memory_addr_a1;
reg [BITSIZE_memory_addr_b-1:0] memory_addr_b1;
reg [BRAM_BITSIZE-1:0] memory [0:n_mem_elements-1] /* synthesis syn_ramstyle = &quot;no_rw_check&quot; */;
integer i11, i12;

initial
begin
  $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
end

always @(posedge clock)
begin
  if(READ_ONLY_MEMORY==0)
  begin
    for (i11=0; i11&lt;n_byte_on_databus; i11=i11+1)
    begin : L11_write_a
      if(HIGH_LATENCY==0||HIGH_LATENCY==1)
      begin
        if(we_a[i11])
          memory[memory_addr_a][i11*8+:8] &lt;= din_value_aggregated_a[i11*8+:8];
      end
      else
      begin
        if(we_a1[i11])
          memory[memory_addr_a1][i11*8+:8] &lt;= din_value_aggregated_a1[i11*8+:8];
      end
    end
  end
  if(HIGH_LATENCY==0)
  begin
    dout_a &lt;= memory[memory_addr_a];
  end
  else if(HIGH_LATENCY==1)
  begin
    dout_a_registered &lt;= memory[memory_addr_a];
    dout_a &lt;= dout_a_registered;
  end
  else
  begin
    memory_addr_a1 &lt;= memory_addr_a;
    we_a1 &lt;= we_a;
    din_value_aggregated_a1 &lt;= din_value_aggregated_a;
    dout_a_registered &lt;= memory[memory_addr_a1];
    dout_a &lt;= dout_a_registered;
  end
end

always @(posedge clock)
begin
  if(READ_ONLY_MEMORY==0)
  begin
    for (i12=0; i12&lt;n_byte_on_databus; i12=i12+1)
    begin : L12_write_b
      if(HIGH_LATENCY==0||HIGH_LATENCY==1)
      begin
        if(we_b[i12])
          memory[memory_addr_b][i12*8+:8] &lt;= din_value_aggregated_b[i12*8+:8];
      end
      else
      begin
        if(we_b1[i12])
          memory[memory_addr_b1][i12*8+:8] &lt;= din_value_aggregated_b1[i12*8+:8];
      end
    end
  end
  if(HIGH_LATENCY==0)
  begin
    dout_b &lt;= memory[memory_addr_b];
  end
  else if(HIGH_LATENCY==1)
  begin
    dout_b_registered &lt;= memory[memory_addr_b];
    dout_b &lt;= dout_b_registered;
  end
  else
  begin
    memory_addr_b1 &lt;= memory_addr_b;
    we_b1 &lt;= we_b;
    din_value_aggregated_b1 &lt;= din_value_aggregated_b;
    dout_b_registered &lt;= memory[memory_addr_b1];
    dout_b &lt;= dout_b_registered;
  end
end

generate
genvar i2_a;
  for (i2_a=0; i2_a&lt;n_byte_on_databus; i2_a=i2_a+1)
  begin  : write_enable_a
    assign we_a[i2_a] = (bram_write0) &amp;&amp; be_a[i2_a];
  end
endgenerate

generate
genvar i2_b;
  for (i2_b=0; i2_b&lt;n_byte_on_databus; i2_b=i2_b+1)
  begin  : write_enable_b
    assign we_b[i2_b] = (bram_write1) &amp;&amp; be_b[i2_b];
  end
endgenerate"
            VHDL_PROVIDED="signal we_a : std_logic_vector(n_byte_on_databus-1 downto 0);
signal we_b : std_logic_vector(n_byte_on_databus-1 downto 0);
signal we_a1 : std_logic_vector(n_byte_on_databus-1 downto 0);
signal we_b1 : std_logic_vector(n_byte_on_databus-1 downto 0);
signal din_value_aggregated_a1 : std_logic_vector(BITSIZE_din_value_aggregated_a-1 downto 0);
signal din_value_aggregated_b1 : std_logic_vector(BITSIZE_din_value_aggregated_b-1 downto 0);

signal dout_a_0 : std_logic_vector(BITSIZE_dout_a-1 downto 0);
signal dout_a_registered : std_logic_vector(BITSIZE_dout_a-1 downto 0);
signal dout_b_0 : std_logic_vector(BITSIZE_dout_a-1 downto 0);
signal dout_b_registered : std_logic_vector(BITSIZE_dout_a-1 downto 0);
signal memory_addr_a1 : std_logic_vector(BITSIZE_memory_addr_a-1 downto 0);
signal memory_addr_b1 : std_logic_vector(BITSIZE_memory_addr_b-1 downto 0);

type mem_type is array (n_mem_elements-1 downto 0) of std_logic_vector(BRAM_BITSIZE-1 downto 0);

impure function InitMemFromFile (MemFileName : in string) return mem_type is
  FILE memfile  :  text open READ_MODE is MemFileName;
  variable MemFileLine  :  line;
  variable mem  :  mem_type;
  begin
     for i in 0 to n_mem_elements-1 loop
      readline(memfile, MemFileLine);
      read(MemFileLine, mem(i));
    end loop;
    return mem;
end function;

shared variable memory : mem_type := InitMemFromFile(MEMORY_INIT_file);
begin

dout_a &lt;= dout_a_0;
dout_b &lt;= dout_b_0;

L1_PROC : process(clock)
begin
   if (clock&apos;event and clock=&apos;1&apos;) then
      if(HIGH_LATENCY = 0) then
-- synthesis translate_off
         if (to_integer(unsigned(memory_addr_a)) &lt; n_mem_elements) then
-- synthesis translate_on
            dout_a_0  &lt;= memory(to_integer(unsigned(memory_addr_a)));
-- synthesis translate_off
         else
            dout_a_0  &lt;= (others =&gt; &apos;X&apos;);
         end if;
-- synthesis translate_on
      elsif(HIGH_LATENCY = 1) then
-- synthesis translate_off
         if (to_integer(unsigned(memory_addr_a)) &lt; n_mem_elements) then
-- synthesis translate_on
            dout_a_registered  &lt;= memory(to_integer(unsigned(memory_addr_a)));
-- synthesis translate_off
         else
            dout_a_registered  &lt;= (others =&gt; &apos;X&apos;);
         end if;
-- synthesis translate_on
         dout_a_0  &lt;= dout_a_registered;
      else
-- synthesis translate_off
         if (to_integer(unsigned(memory_addr_a1)) &lt; n_mem_elements) then
-- synthesis translate_on
            dout_a_registered &lt;= memory(to_integer(unsigned(memory_addr_a1)));
-- synthesis translate_off
         else
            dout_a_registered  &lt;= (others =&gt; &apos;X&apos;);
         end if;
-- synthesis translate_on
         memory_addr_a1 &lt;= memory_addr_a;
         we_a1 &lt;= we_a;
         din_value_aggregated_a1 &lt;= din_value_aggregated_a;
         dout_a_0 &lt;= dout_a_registered;
      end if;
      if (READ_ONLY_MEMORY=0) then
        for index1 in 0 to n_byte_on_databus-1 loop
           if(HIGH_LATENCY= 0 or HIGH_LATENCY = 1) then
              if(we_a(index1)=&apos;1&apos;) then
-- synthesis translate_off
                 if (to_integer(unsigned(memory_addr_a)) &lt; n_mem_elements) then
-- synthesis translate_on
                    memory(to_integer(unsigned(memory_addr_a)))((index1+1)*8-1 downto index1*8) := din_value_aggregated_a((index1+1)*8-1 downto index1*8);
-- synthesis translate_off
                 end if;
-- synthesis translate_on
              end if;
           else
              if(we_a1(index1)=&apos;1&apos;) then
-- synthesis translate_off
                 if (to_integer(unsigned(memory_addr_a1)) &lt; n_mem_elements) then
-- synthesis translate_on
                    memory(to_integer(unsigned(memory_addr_a1)))((index1+1)*8-1 downto index1*8) := din_value_aggregated_a1((index1+1)*8-1 downto index1*8);
-- synthesis translate_off
                 end if;
-- synthesis translate_on
              end if;
           end if;
        end loop;
     end if;
   end if;
end process;


L2_PROC : process(clock)
begin
  if (clock&apos;event and clock=&apos;1&apos;) then
    if(HIGH_LATENCY = 0) then
-- synthesis translate_off
       if (to_integer(unsigned(memory_addr_b)) &lt; n_mem_elements) then
-- synthesis translate_on
          dout_b_0  &lt;= memory(to_integer(unsigned(memory_addr_b)));
-- synthesis translate_off
       else
          dout_b_0  &lt;= (others =&gt; &apos;X&apos;);
       end if;
  -- synthesis translate_on
    elsif(HIGH_LATENCY = 1) then
-- synthesis translate_off
      if (to_integer(unsigned(memory_addr_b)) &lt; n_mem_elements) then
-- synthesis translate_on
          dout_b_registered  &lt;= memory(to_integer(unsigned(memory_addr_b)));
-- synthesis translate_off
      else
         dout_b_registered  &lt;= (others =&gt; &apos;X&apos;);
      end if;
-- synthesis translate_on
      dout_b_0  &lt;= dout_b_registered;
    else
-- synthesis translate_off
      if (to_integer(unsigned(memory_addr_b1)) &lt; n_mem_elements) then
-- synthesis translate_on
        dout_b_registered &lt;= memory(to_integer(unsigned(memory_addr_b1)));
-- synthesis translate_off
      else
        dout_b_registered  &lt;= (others =&gt; &apos;X&apos;);
      end if;
-- synthesis translate_on
      memory_addr_b1 &lt;= memory_addr_b;
      we_b1 &lt;= we_b;
      din_value_aggregated_b1 &lt;= din_value_aggregated_b;
      dout_b_0 &lt;= dout_b_registered;
    end if;
    if (READ_ONLY_MEMORY=0) then
      for index2 in 0 to n_byte_on_databus-1 loop
        if(HIGH_LATENCY= 0 or HIGH_LATENCY = 1) then
          if(we_b(index2)=&apos;1&apos;) then
-- synthesis translate_off
            if (to_integer(unsigned(memory_addr_b)) &lt; n_mem_elements) then
-- synthesis translate_on
              memory(to_integer(unsigned(memory_addr_b)))((index2+1)*8-1 downto index2*8) := din_value_aggregated_b((index2+1)*8-1 downto (index2)*8);
-- synthesis translate_off
            end if;
-- synthesis translate_on
          end if;
          else
          if(we_b1(index2)=&apos;1&apos;) then
-- synthesis translate_off
            if (to_integer(unsigned(memory_addr_b1)) &lt; n_mem_elements) then
-- synthesis translate_on
              memory(to_integer(unsigned(memory_addr_b1)))((index2+1)*8-1 downto index2*8) := din_value_aggregated_b1((index2+1)*8-1 downto (index2)*8);
-- synthesis translate_off
            end if;
-- synthesis translate_on
          end if;
        end if;
      end loop;
    end if;
  end if;
end process;

L_write_enable_a : process(bram_write0, be_a)
begin
   for i2_a in 0 to n_byte_on_databus-1 loop
      we_a(i2_a) &lt;= bram_write0 and be_a(i2_a);
   end loop;
end process;

L_write_enable_b : process(bram_write1, be_b)
begin
   for i2_b in 0 to n_byte_on_databus-1 loop
      we_b(i2_b) &lt;= bram_write1 and be_b(i2_b);
   end loop;
end process;
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_NN_NOBYTE_ENABLE</name>
      <circuit>
        <component_o id="BRAM_MEMORY_NN_NOBYTE_ENABLE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_NN_NOBYTE_ENABLE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="n_bytes">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="max_n_reads">2</parameter>
          <parameter name="max_n_writes">2</parameter>
          <parameter name="memory_offset">16</parameter>
          <parameter name="n_byte_on_databus_offset">2</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_vector_o>
          <port_vector_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value_aggregated_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="be_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_NN_NOBYTE_ENABLE bram_write dout_a memory_addr_a din_value_aggregated_swapped be_swapped MEMORY_INIT_file BRAM_BITSIZE n_bytes n_byte_on_databus n_mem_elements max_n_reads max_n_writes memory_offset n_byte_on_databus_offset READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="STD_NRNW_BRAM_SB" 
          VERILOG_PROVIDED="
wire [(n_byte_on_databus/2)*max_n_writes-1:0] we_a;
wire [max_n_writes*BRAM_BITSIZE-1:0] din_value_swapped;

STD_NRNW_BRAM_SB #(.BITSIZE_we_a(n_byte_on_databus/2),
  .PORTSIZE_we_a(max_n_writes),
  .BITSIZE_Addr(BITSIZE_memory_addr_a),
  .PORTSIZE_Addr(PORTSIZE_memory_addr_a),
  .BITSIZE_din_value(BITSIZE_din_value_aggregated_swapped/2),
  .PORTSIZE_din_value(max_n_writes),
  .BITSIZE_dout_value(BITSIZE_dout_a),
  .PORTSIZE_dout_value(PORTSIZE_dout_a),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_mem_elements(n_mem_elements),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .HIGH_LATENCY(HIGH_LATENCY)) STD_NRNW_BRAM_SB_instance (.clock(clock),
  .we_a(we_a),
  .Addr(memory_addr_a),
  .din_value(din_value_swapped),
  .dout_value(dout_a[BRAM_BITSIZE*max_n_reads-1:0]));

generate
genvar i1,i2;
  for (i2=0; i2&lt;max_n_writes; i2=i2+1)
  begin : we2
    for (i1=0; i1&lt;n_byte_on_databus/2; i1=i1+1)
    begin  : we1
      assign we_a[i1+(n_byte_on_databus/2)*i2] = bram_write[i2] &amp;&amp; be_swapped[i1+n_byte_on_databus*i2+n_byte_on_databus_offset];
    end
  end
  for (i2=0; i2&lt;max_n_writes; i2=i2+1)
  begin : din2
    for (i1=0; i1&lt;n_byte_on_databus/2; i1=i1+1)
    begin  : din1
      assign din_value_swapped[i2*n_byte_on_databus*4+i1*8+7:i2*(n_byte_on_databus)*4+i1*8] = din_value_aggregated_swapped[i2*2*BRAM_BITSIZE+i1*8+memory_offset+7:i2*2*BRAM_BITSIZE+i1*8+memory_offset];
    end
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_NN_CORE</name>
      <circuit>
        <component_o id="BRAM_MEMORY_NN_CORE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_NN_CORE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="n_bytes">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="max_n_reads">2</parameter>
          <parameter name="max_n_writes">2</parameter>
          <parameter name="memory_offset">16</parameter>
          <parameter name="n_byte_on_databus_offset">2</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_vector_o>
          <port_vector_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value_aggregated_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="be_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_NN_CORE bram_write dout_a memory_addr_a din_value_aggregated_swapped be_swapped MEMORY_INIT_file BRAM_BITSIZE n_bytes n_byte_on_databus n_mem_elements max_n_reads max_n_writes memory_offset n_byte_on_databus_offset READ_ONLY_MEMORY HIGH_LATENCY" 
          IP_COMPONENT="BRAM_MEMORY_CORE_SMALL,TRUE_DUAL_PORT_BYTE_ENABLING_RAM"
          VERILOG_PROVIDED="
generate
if(n_mem_elements == 1)
begin
  BRAM_MEMORY_CORE_SMALL #(.PORTSIZE_bram_write(PORTSIZE_bram_write),
  .BITSIZE_bram_write(BITSIZE_bram_write),
  .PORTSIZE_memory_addr_a(PORTSIZE_memory_addr_a),
  .BITSIZE_memory_addr_a(BITSIZE_memory_addr_a),
  .PORTSIZE_din_value_aggregated(PORTSIZE_din_value_aggregated_swapped),
  .BITSIZE_din_value_aggregated((n_byte_on_databus/2)*8),
  .PORTSIZE_be(PORTSIZE_be_swapped),
  .BITSIZE_be(n_byte_on_databus/PORTSIZE_be_swapped),
  .PORTSIZE_dout_a(PORTSIZE_dout_a),
  .BITSIZE_dout_a(BITSIZE_dout_a),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_byte_on_databus(n_byte_on_databus/2),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_instance_small (.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .din_value_aggregated({din_value_aggregated_swapped[2*BRAM_BITSIZE+memory_offset+:(n_byte_on_databus/2)*8],din_value_aggregated_swapped[memory_offset+:(n_byte_on_databus/2)*8]}),
  .be({be_swapped[n_byte_on_databus+n_byte_on_databus_offset+:n_byte_on_databus/2],be_swapped[n_byte_on_databus_offset+:n_byte_on_databus/2]}),
  .dout_a(dout_a));
end
else
begin
  TRUE_DUAL_PORT_BYTE_ENABLING_RAM #(.BITSIZE_memory_addr_a(BITSIZE_memory_addr_a),
    .BITSIZE_memory_addr_b(BITSIZE_memory_addr_a),
    .BITSIZE_din_value_aggregated_a((n_byte_on_databus/2)*8),
    .BITSIZE_din_value_aggregated_b((n_byte_on_databus/2)*8),
    .BITSIZE_be_a(n_byte_on_databus/2),
    .BITSIZE_be_b(n_byte_on_databus/2),
    .BITSIZE_dout_a((n_byte_on_databus/2)*8),
    .BITSIZE_dout_b((n_byte_on_databus/2)*8),
    .MEMORY_INIT_file(MEMORY_INIT_file),
    .BRAM_BITSIZE(BRAM_BITSIZE),
    .n_byte_on_databus(n_byte_on_databus/2),
    .n_mem_elements(n_mem_elements),
    .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
    .HIGH_LATENCY(HIGH_LATENCY)
  ) TRUE_DUAL_PORT_BYTE_ENABLING_RAM_instance (.clock(clock),
    .bram_write0(bram_write[0]),
    .bram_write1(bram_write[1]),
    .memory_addr_a(memory_addr_a[BITSIZE_memory_addr_a-1:0]),
    .memory_addr_b(memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]),
    .din_value_aggregated_a(din_value_aggregated_swapped[memory_offset +:(n_byte_on_databus/2)*8]),
    .din_value_aggregated_b(din_value_aggregated_swapped[2*BRAM_BITSIZE+memory_offset+:(n_byte_on_databus/2)*8]),
    .be_a(be_swapped[n_byte_on_databus_offset+:n_byte_on_databus/2]),
    .be_b(be_swapped[n_byte_on_databus+n_byte_on_databus_offset+:n_byte_on_databus/2]),
    .dout_a(dout_a[BRAM_BITSIZE-1:0]),
    .dout_b(dout_a[2*BRAM_BITSIZE-1:BRAM_BITSIZE])
  );
end
endgenerate
"
            VHDL_PROVIDED="
  signal din_value_aggregated_tmp : std_logic_vector((n_byte_on_databus*8)-1 downto 0);
  signal be_tmp : std_logic_vector(n_byte_on_databus-1 downto 0);
begin
din_value_aggregated_tmp &lt;= din_value_aggregated_swapped((n_byte_on_databus/2)*8+2*BRAM_BITSIZE+memory_offset-1 downto 2*BRAM_BITSIZE+memory_offset) &amp; din_value_aggregated_swapped((n_byte_on_databus/2)*8+memory_offset-1 downto memory_offset);
be_tmp &lt;= be_swapped(n_byte_on_databus/2+n_byte_on_databus+n_byte_on_databus_offset-1 downto n_byte_on_databus+n_byte_on_databus_offset) &amp; be_swapped(n_byte_on_databus/2+n_byte_on_databus_offset-1 downto n_byte_on_databus_offset);
BRAM_MEMORY_CORE_SMALL_case : if (n_mem_elements = 1) generate
  BRAM_MEMORY_CORE_SMALL_instance : BRAM_MEMORY_CORE_SMALL generic map (
    PORTSIZE_bram_write=&gt;PORTSIZE_bram_write,
    BITSIZE_bram_write=&gt;BITSIZE_bram_write,
    PORTSIZE_memory_addr_a=&gt;PORTSIZE_memory_addr_a,
    BITSIZE_memory_addr_a=&gt;BITSIZE_memory_addr_a,
    PORTSIZE_din_value_aggregated=&gt;PORTSIZE_din_value_aggregated_swapped,
    BITSIZE_din_value_aggregated=&gt;(n_byte_on_databus/2)*8,
    PORTSIZE_be=&gt;PORTSIZE_be_swapped,
    BITSIZE_be=&gt;n_byte_on_databus/PORTSIZE_be_swapped,
    PORTSIZE_dout_a=&gt;PORTSIZE_dout_a,
    BITSIZE_dout_a=&gt;BITSIZE_dout_a,
    MEMORY_INIT_file=&gt;MEMORY_INIT_file,
    n_byte_on_databus=&gt;n_byte_on_databus/2,
    n_mem_elements=&gt;n_mem_elements,
    n_bytes=&gt;n_bytes,
    READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY,
    HIGH_LATENCY=&gt;HIGH_LATENCY) port map (clock=&gt;clock,
    bram_write=&gt;bram_write,
    memory_addr_a=&gt;memory_addr_a,
    din_value_aggregated=&gt;din_value_aggregated_tmp,
    be=&gt;be_tmp,
    dout_a=&gt;dout_a);
end generate;
TRUE_DUAL_PORT_BYTE_ENABLING_RAM_else : if(n_mem_elements /= 1) generate
  TRUE_DUAL_PORT_BYTE_ENABLING_RAM_instance : TRUE_DUAL_PORT_BYTE_ENABLING_RAM generic map (BITSIZE_memory_addr_a=&gt;BITSIZE_memory_addr_a,
    BITSIZE_memory_addr_b=&gt;BITSIZE_memory_addr_a,
    BITSIZE_din_value_aggregated_a=&gt;(n_byte_on_databus/2)*8,
    BITSIZE_din_value_aggregated_b=&gt;(n_byte_on_databus/2)*8,
    BITSIZE_be_a=&gt;n_byte_on_databus/2,
    BITSIZE_be_b=&gt;n_byte_on_databus/2,
    BITSIZE_dout_a=&gt;(n_byte_on_databus/2)*8,
    BITSIZE_dout_b=&gt;(n_byte_on_databus/2)*8,
    MEMORY_INIT_file=&gt;MEMORY_INIT_file,
    BRAM_BITSIZE=&gt;BRAM_BITSIZE,
    n_byte_on_databus=&gt;n_byte_on_databus/2,
    n_mem_elements=&gt;n_mem_elements,
    READ_ONLY_MEMORY=&gt;READ_ONLY_MEMORY,
    HIGH_LATENCY=&gt;HIGH_LATENCY
  ) port map (
    clock=&gt;clock,
    bram_write0=&gt;bram_write(0),
    bram_write1=&gt;bram_write(1),
    memory_addr_a=&gt;memory_addr_a(BITSIZE_memory_addr_a-1 downto 0),
    memory_addr_b=&gt;memory_addr_a(2*BITSIZE_memory_addr_a-1 downto BITSIZE_memory_addr_a),
    din_value_aggregated_a=&gt; din_value_aggregated_swapped((n_byte_on_databus/2)*8+memory_offset-1 downto memory_offset),
    din_value_aggregated_b=&gt;din_value_aggregated_swapped((n_byte_on_databus/2)*8+2*BRAM_BITSIZE+memory_offset-1 downto 2*BRAM_BITSIZE+memory_offset),
    be_a=&gt;be_swapped(n_byte_on_databus/2+n_byte_on_databus_offset-1 downto n_byte_on_databus_offset),
    be_b=&gt;be_swapped(n_byte_on_databus/2+n_byte_on_databus+n_byte_on_databus_offset-1 downto n_byte_on_databus+n_byte_on_databus_offset),
    dout_a=&gt;dout_a(BRAM_BITSIZE-1 downto 0),
    dout_b=&gt;dout_a(2*BRAM_BITSIZE-1 downto BRAM_BITSIZE));
end generate;
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BRAM_MEMORY_NN_PMI</name>
      <circuit>
        <component_o id="BRAM_MEMORY_NN_PMI">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BRAM_MEMORY_NN_PMI"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="nbit_read_addr">32</parameter>
          <parameter name="n_byte_on_databus">4</parameter>
          <parameter name="n_mem_elements">4</parameter>
          <parameter name="max_n_reads">2</parameter>
          <parameter name="max_n_writes">2</parameter>
          <parameter name="memory_offset">16</parameter>
          <parameter name="n_byte_on_databus_offset">2</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="bram_write" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_vector_o>
          <port_vector_o id="memory_addr_a" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="din_value_aggregated_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="be_swapped" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dout_a" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BRAM_MEMORY_NN_PMI bram_write dout_a memory_addr_a din_value_aggregated_swapped be_swapped MEMORY_INIT_file BRAM_BITSIZE nbit_read_addr n_byte_on_databus n_mem_elements max_n_reads max_n_writes memory_offset n_byte_on_databus_offset READ_ONLY_MEMORY HIGH_LATENCY" VERILOG_PROVIDED="
reg [PORTSIZE_bram_write-1:0] bram_write1;
reg [(PORTSIZE_memory_addr_a*BITSIZE_memory_addr_a)+(-1):0] memory_addr_a1;
reg [(PORTSIZE_din_value_aggregated_swapped*BITSIZE_din_value_aggregated_swapped)+(-1):0] din_value_aggregated_swapped1;
reg [(PORTSIZE_be_swapped*BITSIZE_be_swapped)+(-1):0] be_swapped1;

generate
  if(HIGH_LATENCY==2)
  begin
    always @ (posedge clock)
    begin
       memory_addr_a1 &lt;= memory_addr_a;
       bram_write1 &lt;= bram_write;
       be_swapped1 &lt;= be_swapped;
       din_value_aggregated_swapped1 &lt;= din_value_aggregated_swapped;
    end
  end
endgenerate

generate
if(BRAM_BITSIZE == 8)
begin
  reg [(n_byte_on_databus/2)*8-1:0] dout_a_tmp;
  reg [(n_byte_on_databus/2)*8-1:0] dout_b_tmp;
  reg [(n_byte_on_databus/2)*8-1:0] dout_a_registered;
  reg [(n_byte_on_databus/2)*8-1:0] dout_b_registered;
  reg [(n_byte_on_databus/2)*8-1:0] memory [0:n_mem_elements-1]/* synthesis syn_ramstyle = &quot;no_rw_check&quot; */ ;
  assign dout_a[BRAM_BITSIZE-1:0] = dout_a_tmp;
  assign dout_a[2*BRAM_BITSIZE-1:BRAM_BITSIZE] = dout_b_tmp;
  initial
  begin
    $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
  end
  if(n_mem_elements == 1)
  begin
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write[0] &amp;&amp; be_swapped[n_byte_on_databus_offset])
            memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]] &lt;= din_value_aggregated_swapped[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset];
        end
        else
        begin
          if (bram_write1[0] &amp;&amp; be_swapped1[n_byte_on_databus_offset])
            memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]] &lt;= din_value_aggregated_swapped1[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset];
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write[1] &amp;&amp; be_swapped[n_byte_on_databus+n_byte_on_databus_offset])
            memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset];
        end
        else
        begin
          if (bram_write1[1] &amp;&amp; be_swapped1[n_byte_on_databus+n_byte_on_databus_offset])
            memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset];
        end
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
  else
  begin
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write[0] &amp;&amp; be_swapped[n_byte_on_databus_offset])
            memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]] &lt;= din_value_aggregated_swapped[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset];
        end
        else
        begin
          if (bram_write1[0] &amp;&amp; be_swapped1[n_byte_on_databus_offset])
            memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]] &lt;= din_value_aggregated_swapped1[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset];
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
    end
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write[1] &amp;&amp; be_swapped[n_byte_on_databus+n_byte_on_databus_offset])
            memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset];
        end
        else
        begin
          if (bram_write1[1] &amp;&amp; be_swapped1[n_byte_on_databus+n_byte_on_databus_offset])
            memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset];
        end
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
end
else
begin
  if(n_mem_elements == 1)
  begin
    reg [(n_byte_on_databus/2)*8-1:0] dout_a_tmp;
    reg [(n_byte_on_databus/2)*8-1:0] dout_b_tmp;
    reg [(n_byte_on_databus/2)*8-1:0] dout_a_registered;
    reg [(n_byte_on_databus/2)*8-1:0] dout_b_registered;
    reg [(n_byte_on_databus/2)*8-1:0] memory [0:n_mem_elements-1]/* synthesis syn_ramstyle = &quot;no_rw_check&quot; */ ;
    assign dout_a[BRAM_BITSIZE-1:0] = dout_a_tmp;
    assign dout_a[2*BRAM_BITSIZE-1:BRAM_BITSIZE] = dout_b_tmp;
    initial
    begin
      $readmemb(MEMORY_INIT_file, memory, 0, n_mem_elements-1);
    end
    always @(posedge clock)
    begin
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write[0])
          begin : L11_write
            integer i11;
            for (i11=0; i11&lt;n_byte_on_databus/2; i11=i11+1)
            begin
              if(be_swapped[i11+n_byte_on_databus_offset])
                memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]][i11*8+:8] &lt;= din_value_aggregated_swapped[i11*8+memory_offset+:8];
            end
          end
        end
        else
        begin
          if (bram_write1[0])
          begin : L11_write1
            integer i11;
            for (i11=0; i11&lt;n_byte_on_databus/2; i11=i11+1)
            begin
              if(be_swapped1[i11+n_byte_on_databus_offset])
                memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]][i11*8+:8] &lt;= din_value_aggregated_swapped1[i11*8+memory_offset+:8];
            end
          end
        end
      end
      if(HIGH_LATENCY == 0)
        dout_a_tmp &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_a_registered &lt;= memory[memory_addr_a[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      else
      begin
        dout_a_registered &lt;= memory[memory_addr_a1[BITSIZE_memory_addr_a-1:0]];
        dout_a_tmp &lt;= dout_a_registered;
      end
      if(READ_ONLY_MEMORY==0)
      begin
        if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
        begin
          if (bram_write[1])
          begin : L22_write
            integer i22;
            for (i22=0; i22&lt;n_byte_on_databus/2; i22=i22+1)
            begin
              if(be_swapped[i22+n_byte_on_databus+n_byte_on_databus_offset])
                memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]][i22*8+:8] &lt;= din_value_aggregated_swapped[2*BRAM_BITSIZE+memory_offset+i22*8+:8];
            end
          end
        end
        else
        begin
          if (bram_write1[1])
          begin : L22_write1
            integer i22;
            for (i22=0; i22&lt;n_byte_on_databus/2; i22=i22+1)
            begin
              if(be_swapped1[i22+n_byte_on_databus+n_byte_on_databus_offset])
                memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]][i22*8+:8] &lt;= din_value_aggregated_swapped1[2*BRAM_BITSIZE+memory_offset+i22*8+:8];
            end
          end
        end
      end
      if(HIGH_LATENCY == 0)
        dout_b_tmp &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
      else if(HIGH_LATENCY == 1)
      begin
        dout_b_registered &lt;= memory[memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
      else
      begin
        dout_b_registered &lt;= memory[memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]];
        dout_b_tmp &lt;= dout_b_registered;
      end
    end
  end
  else
    if(HIGH_LATENCY == 0||HIGH_LATENCY == 1)
    begin
      pmi_ram_dp_true_be #(.pmi_addr_depth_a(n_mem_elements),
        .pmi_addr_width_a(BITSIZE_memory_addr_a),
        .pmi_data_width_a((n_byte_on_databus/2)*8),
        .pmi_addr_depth_b(n_mem_elements),
        .pmi_addr_width_b(BITSIZE_memory_addr_a),
        .pmi_data_width_b((n_byte_on_databus/2)*8),
        .pmi_regmode_a(HIGH_LATENCY== 0 ? &quot;noreg&quot; : &quot;reg&quot;),
        .pmi_regmode_b(HIGH_LATENCY== 0 ? &quot;noreg&quot; : &quot;reg&quot;),
        .pmi_gsr(&quot;disable&quot;),
        .pmi_resetmode(&quot;sync&quot;),
        .pmi_optimization(&quot;speed&quot;),
        .pmi_init_file(MEMORY_INIT_file),
        .pmi_init_file_format(&quot;binary&quot;),
        .pmi_write_mode_a(&quot;normal&quot;),
        .pmi_write_mode_b(&quot;normal&quot;),
        .pmi_byte_size(8),
        .pmi_family(&quot;ECP3&quot;),
        .module_type(&quot;pmi_ram_dp_true_be&quot;)) pmi_ram_dp_true_be_instance
       (.DataInA(din_value_aggregated_swapped[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset]),
        .DataInB(din_value_aggregated_swapped[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset]),
        .AddressA(memory_addr_a[BITSIZE_memory_addr_a-1:0]),
        .AddressB(memory_addr_a[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]),
        .ClockA(clock),
        .ClockB(clock),
        .ClockEnA(1&apos;b1),
        .ClockEnB(1&apos;b1),
        .WrA(bram_write[0] &amp;&amp; READ_ONLY_MEMORY==0),
        .WrB(bram_write[1] &amp;&amp; READ_ONLY_MEMORY==0),
        .ResetA(1&apos;b0),
        .ResetB(1&apos;b0),
        .ByteEnA(be_swapped[n_byte_on_databus/2+n_byte_on_databus_offset-1:n_byte_on_databus_offset]),
        .ByteEnB(be_swapped[n_byte_on_databus/2+n_byte_on_databus+n_byte_on_databus_offset-1:n_byte_on_databus+n_byte_on_databus_offset]),
        .QA(dout_a[BRAM_BITSIZE-1:0]),
        .QB(dout_a[2*BRAM_BITSIZE-1:BRAM_BITSIZE])) /*synthesis syn_black_box*/;
    end
    else
    begin
      pmi_ram_dp_true_be #(.pmi_addr_depth_a(n_mem_elements),
        .pmi_addr_width_a(BITSIZE_memory_addr_a),
        .pmi_data_width_a((n_byte_on_databus/2)*8),
        .pmi_addr_depth_b(n_mem_elements),
        .pmi_addr_width_b(BITSIZE_memory_addr_a),
        .pmi_data_width_b((n_byte_on_databus/2)*8),
        .pmi_regmode_a(HIGH_LATENCY== 0 ? &quot;noreg&quot; : &quot;reg&quot;),
        .pmi_regmode_b(HIGH_LATENCY== 0 ? &quot;noreg&quot; : &quot;reg&quot;),
        .pmi_gsr(&quot;disable&quot;),
        .pmi_resetmode(&quot;sync&quot;),
        .pmi_optimization(&quot;speed&quot;),
        .pmi_init_file(MEMORY_INIT_file),
        .pmi_init_file_format(&quot;binary&quot;),
        .pmi_write_mode_a(&quot;normal&quot;),
        .pmi_write_mode_b(&quot;normal&quot;),
        .pmi_byte_size(8),
        .pmi_family(&quot;ECP3&quot;),
        .module_type(&quot;pmi_ram_dp_true_be&quot;)) pmi_ram_dp_true_be_instance
       (.DataInA(din_value_aggregated_swapped1[(n_byte_on_databus/2)*8+memory_offset-1:memory_offset]),
        .DataInB(din_value_aggregated_swapped1[2*BRAM_BITSIZE+(n_byte_on_databus/2)*8+memory_offset-1:2*BRAM_BITSIZE+memory_offset]),
        .AddressA(memory_addr_a1[BITSIZE_memory_addr_a-1:0]),
        .AddressB(memory_addr_a1[2*BITSIZE_memory_addr_a-1:BITSIZE_memory_addr_a]),
        .ClockA(clock),
        .ClockB(clock),
        .ClockEnA(1&apos;b1),
        .ClockEnB(1&apos;b1),
        .WrA(bram_write1[0] &amp;&amp; READ_ONLY_MEMORY==0),
        .WrB(bram_write1[1] &amp;&amp; READ_ONLY_MEMORY==0),
        .ResetA(1&apos;b0),
        .ResetB(1&apos;b0),
        .ByteEnA(be_swapped1[n_byte_on_databus/2+n_byte_on_databus_offset-1:n_byte_on_databus_offset]),
        .ByteEnB(be_swapped1[n_byte_on_databus/2+n_byte_on_databus+n_byte_on_databus_offset-1:n_byte_on_databus+n_byte_on_databus_offset]),
        .QA(dout_a[BRAM_BITSIZE-1:0]),
        .QB(dout_a[2*BRAM_BITSIZE-1:BRAM_BITSIZE])) /*synthesis syn_black_box*/;
    end
end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_NOBYTE_ENABLE</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_NOBYTE_ENABLE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_NOBYTE_ENABLE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> arrary address </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element loaded or stored </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_NOBYTE_ENABLE in1 in2 in3 out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_out1" IP_COMPONENT="ADDRESS_DECODING_LOGIC,BRAM_MEMORY_NOBYTE_ENABLE" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8;
parameter n_byte_on_databus = BRAM_BITSIZE/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
  
wire [nbit_read_addr-1:0] memory_addr_a;
wire [nbit_read_addr-1:0] memory_addr_b;
wire [n_byte_on_databus*2-1:0] be;

wire [2*BRAM_BITSIZE-1:0] din_value_aggregated;
wire bram_write;
wire [BRAM_BITSIZE-1:0] dout_a;
wire [BRAM_BITSIZE-1:0] dout_b;

BRAM_MEMORY_NOBYTE_ENABLE #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_instance (.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));

ADDRESS_DECODING_LOGIC #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .HIGH_LATENCY(HIGH_LATENCY)) ADDRESS_DECODING_LOGIC_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_PMI</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_PMI">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_PMI"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> arrary address </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element loaded or stored </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_PMI in1 in2 in3 out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY proxy_in1 proxy_in2 proxy_in3 proxy_out1" IP_COMPONENT="ADDRESS_DECODING_LOGIC,BRAM_MEMORY_PMI" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8;
parameter n_byte_on_databus = BRAM_BITSIZE/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
  
wire [nbit_read_addr-1:0] memory_addr_a;
wire [nbit_read_addr-1:0] memory_addr_b;
wire [n_byte_on_databus*2-1:0] be;

wire [2*BRAM_BITSIZE-1:0] din_value_aggregated;
wire bram_write;
wire [BRAM_BITSIZE-1:0] dout_a;
wire [BRAM_BITSIZE-1:0] dout_b;

BRAM_MEMORY_PMI #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_instance (.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));

ADDRESS_DECODING_LOGIC #(.BITSIZE_memory_addr_a(nbit_read_addr),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .BITSIZE_din_value_aggregated(2*BRAM_BITSIZE),
  .BITSIZE_be(n_byte_on_databus*2),
  .BITSIZE_dout_a(BRAM_BITSIZE),
  .BITSIZE_dout_b(BRAM_BITSIZE),
  .BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .n_bytes(n_bytes),
  .HIGH_LATENCY(HIGH_LATENCY)) ADDRESS_DECODING_LOGIC_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated(din_value_aggregated),
  .be(be),
  .dout_a(dout_a),
  .dout_b(dout_b));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_NN_NOBYTE_ENABLE</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_NN_NOBYTE_ENABLE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_NN_NOBYTE_ENABLE"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_NN_NOBYTE_ENABLE in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1 HIGH_LATENCY" 
          IP_COMPONENT="ADDRESS_DECODING_LOGIC_NN,BRAM_MEMORY_NN_NOBYTE_ENABLE" 
          VERILOG_PROVIDED="
`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8;
parameter memory_bitsize = 2*BRAM_BITSIZE;
parameter n_byte_on_databus = memory_bitsize/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
parameter max_n_writes = PORTSIZE_sel_STORE &gt; PORTSIZE_S_we_ram ? PORTSIZE_sel_STORE : PORTSIZE_S_we_ram;
parameter max_n_reads = PORTSIZE_sel_LOAD &gt; PORTSIZE_S_oe_ram ? PORTSIZE_sel_LOAD : PORTSIZE_S_oe_ram;
parameter max_n_rw = max_n_writes &gt; max_n_reads ? max_n_writes : max_n_reads;

wire [max_n_writes-1:0] bram_write;

wire [nbit_read_addr*max_n_rw-1:0] memory_addr_a;
wire [nbit_read_addr*max_n_rw-1:0] memory_addr_b;
wire [n_byte_on_databus*max_n_writes-1:0] be_swapped;

wire [memory_bitsize*max_n_writes-1:0] din_value_aggregated_swapped;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_a;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_b;


BRAM_MEMORY_NN_NOBYTE_ENABLE #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_a),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(0),
  .n_byte_on_databus_offset(0),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_NN_instance_a(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_a));

generate
  if (n_bytes &gt; BRAM_BITSIZE/8)
  begin : SECOND_MEMORY
    BRAM_MEMORY_NN_NOBYTE_ENABLE #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a((memory_bitsize/2)),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_b),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(memory_bitsize/2),
  .n_byte_on_databus_offset(n_byte_on_databus/2),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_NN_instance_b(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_b));
  end
else
  assign dout_b = {(memory_bitsize/2)*max_n_reads{1&apos;b0}};
endgenerate

ADDRESS_DECODING_LOGIC_NN #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_dout_b(memory_bitsize/2),
  .PORTSIZE_dout_b(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .PORTSIZE_memory_addr_b(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .BITSIZE_bram_write(1),
  .PORTSIZE_bram_write(max_n_writes),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .max_n_rw(max_n_rw),
  .HIGH_LATENCY(HIGH_LATENCY)) ADDRESS_DECODING_LOGIC_NN_instance (.clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .out1(out1),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .proxy_out1(proxy_out1),
  .dout_a(dout_a),
  .dout_b(dout_b),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .bram_write(bram_write));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_NN_PMI</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_NN_PMI">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_NN_PMI"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_NN_PMI in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1 HIGH_LATENCY" IP_COMPONENT="ADDRESS_DECODING_LOGIC_NN,BRAM_MEMORY_NN_PMI" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_bytes = (n_elements*data_size)/8;
parameter memory_bitsize = 2*BRAM_BITSIZE;
parameter n_byte_on_databus = memory_bitsize/8;
parameter n_mem_elements = n_bytes/(n_byte_on_databus) + (n_bytes%(n_byte_on_databus) == 0 ? 0 : 1);
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : $clog2(n_mem_elements);
`else
  localparam nbit_read_addr = n_mem_elements == 1 ? 1 : log2(n_mem_elements);
`endif
parameter max_n_writes = PORTSIZE_sel_STORE &gt; PORTSIZE_S_we_ram ? PORTSIZE_sel_STORE : PORTSIZE_S_we_ram;
parameter max_n_reads = PORTSIZE_sel_LOAD &gt; PORTSIZE_S_oe_ram ? PORTSIZE_sel_LOAD : PORTSIZE_S_oe_ram;
parameter max_n_rw = max_n_writes &gt; max_n_reads ? max_n_writes : max_n_reads;

wire [max_n_writes-1:0] bram_write;

wire [nbit_read_addr*max_n_rw-1:0] memory_addr_a;
wire [nbit_read_addr*max_n_rw-1:0] memory_addr_b;
wire [n_byte_on_databus*max_n_writes-1:0] be_swapped;

wire [memory_bitsize*max_n_writes-1:0] din_value_aggregated_swapped;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_a;
wire [(memory_bitsize/2)*max_n_reads-1:0] dout_b;


BRAM_MEMORY_NN_PMI #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_a),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(0),
  .n_byte_on_databus_offset(0),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_NN_instance_a(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_a),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_a));

generate
  if (n_bytes &gt; BRAM_BITSIZE/8)
  begin : SECOND_MEMORY
    BRAM_MEMORY_NN_PMI #(.PORTSIZE_bram_write(max_n_writes),
  .BITSIZE_bram_write(1),
  .BITSIZE_dout_a((memory_bitsize/2)),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .MEMORY_INIT_file(MEMORY_INIT_file_b),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .memory_offset(memory_bitsize/2),
  .n_byte_on_databus_offset(n_byte_on_databus/2),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)) BRAM_MEMORY_NN_instance_b(.clock(clock),
  .bram_write(bram_write),
  .memory_addr_a(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .dout_a(dout_b));
  end
else
  assign dout_b = {(memory_bitsize/2)*max_n_reads{1&apos;b0}};
endgenerate

ADDRESS_DECODING_LOGIC_NN #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1),
  .BITSIZE_dout_a(memory_bitsize/2),
  .PORTSIZE_dout_a(max_n_reads),
  .BITSIZE_dout_b(memory_bitsize/2),
  .PORTSIZE_dout_b(max_n_reads),
  .BITSIZE_memory_addr_a(nbit_read_addr),
  .PORTSIZE_memory_addr_a(max_n_rw),
  .BITSIZE_memory_addr_b(nbit_read_addr),
  .PORTSIZE_memory_addr_b(max_n_rw),
  .BITSIZE_din_value_aggregated_swapped(memory_bitsize),
  .PORTSIZE_din_value_aggregated_swapped(max_n_writes),
  .BITSIZE_be_swapped(n_byte_on_databus),
  .PORTSIZE_be_swapped(max_n_writes),
  .BITSIZE_bram_write(1),
  .PORTSIZE_bram_write(max_n_writes),
  .nbit_read_addr(nbit_read_addr),
  .n_byte_on_databus(n_byte_on_databus),
  .n_mem_elements(n_mem_elements),
  .max_n_reads(max_n_reads),
  .max_n_writes(max_n_writes),
  .max_n_rw(max_n_rw),
  .HIGH_LATENCY(HIGH_LATENCY)) ADDRESS_DECODING_LOGIC_NN_instance (.clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .out1(out1),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE),
  .proxy_out1(proxy_out1),
  .dout_a(dout_a),
  .dout_b(dout_b),
  .memory_addr_a(memory_addr_a),
  .memory_addr_b(memory_addr_b),
  .din_value_aggregated_swapped(din_value_aggregated_swapped),
  .be_swapped(be_swapped),
  .bram_write(bram_write));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_N1_NOBYTE_ENABLE</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_N1_NOBYTE_ENABLE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_N1_NOBYTE_ENABLE"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_N1_NOBYTE_ENABLE in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1 HIGH_LATENCY" IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_NOBYTE_ENABLE" VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_NN_NOBYTE_ENABLE #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(1),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(1),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(1),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(1),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(1),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(1),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(1),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(1),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(1),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1),
  .HIGH_LATENCY(HIGH_LATENCY)) ARRAY_1D_STD_BRAM_NN_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size ),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_N1_PMI</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_N1_PMI">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_N1_PMI"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_N1_PMI in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1 HIGH_LATENCY" IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_PMI" VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_NN_PMI #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(1),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(1),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(1),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(1),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(1),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(1),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(1),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(1),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(1),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(PRIVATE_MEMORY),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_proxy_in1),
  .PORTSIZE_proxy_in1(PORTSIZE_proxy_in1),
  .BITSIZE_proxy_in2(BITSIZE_proxy_in2),
  .PORTSIZE_proxy_in2(PORTSIZE_proxy_in2),
  .BITSIZE_proxy_in3(BITSIZE_proxy_in3),
  .PORTSIZE_proxy_in3(PORTSIZE_proxy_in3),
  .BITSIZE_proxy_sel_LOAD(BITSIZE_proxy_sel_LOAD),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_proxy_sel_LOAD),
  .BITSIZE_proxy_sel_STORE(BITSIZE_proxy_sel_STORE),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_proxy_sel_STORE),
  .BITSIZE_proxy_out1(BITSIZE_proxy_out1),
  .PORTSIZE_proxy_out1(PORTSIZE_proxy_out1),
  .HIGH_LATENCY(HIGH_LATENCY)) ARRAY_1D_STD_BRAM_NN_instance (.out1(out1),
  .Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .proxy_out1(proxy_out1),
  .clock(clock),
  .reset(reset),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size ),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(proxy_in1),
  .proxy_in2(proxy_in2),
  .proxy_in3(proxy_in3),
  .proxy_sel_LOAD(proxy_sel_LOAD),
  .proxy_sel_STORE(proxy_sel_STORE));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAM_NOBYTE_ENABLE</name>
      <circuit>
        <component_o id="STD_BRAM_NOBYTE_ENABLE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAM_NOBYTE_ENABLE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_BRAM_NOBYTE_ENABLE S_addr_ram S_Wdata_ram Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" IP_COMPONENT="ARRAY_1D_STD_BRAM_NOBYTE_ENABLE" VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_NOBYTE_ENABLE #(.BITSIZE_in1(1),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_out1(1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(1),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_proxy_out1(1),
  .HIGH_LATENCY(HIGH_LATENCY)) ARRAY_1D_STD_BRAM_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1(1&apos;b0),
  .in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD(1&apos;b0),
  .sel_STORE(1&apos;b0),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(1&apos;b0),
  .proxy_in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD(1&apos;b0),
  .proxy_sel_STORE(1&apos;b0));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAMN_NOBYTE_ENABLE</name>
      <circuit>
        <component_o id="STD_BRAMN_NOBYTE_ENABLE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAMN_NOBYTE_ENABLE"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_BRAMN_NOBYTE_ENABLE S_oe_ram S_we_ram S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_NOBYTE_ENABLE" VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_NN_NOBYTE_ENABLE #(.BITSIZE_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_sel_LOAD(1),
  .PORTSIZE_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_sel_STORE(1),
  .PORTSIZE_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_out1(1),
  .PORTSIZE_out1(PORTSIZE_S_addr_ram),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_proxy_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_proxy_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_proxy_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_proxy_sel_LOAD(1),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_sel_STORE(1),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_out1(1),
  .PORTSIZE_proxy_out1(PORTSIZE_S_addr_ram),
  .HIGH_LATENCY(HIGH_LATENCY)) ARRAY_1D_STD_BRAM_NN_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .proxy_in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAM_PMI</name>
      <circuit>
        <component_o id="STD_BRAM_PMI">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAM_PMI"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="STD_BRAM_PMI S_addr_ram S_Wdata_ram Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" IP_COMPONENT="ARRAY_1D_STD_BRAM_PMI" VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_PMI #(.BITSIZE_in1(1),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_out1(1),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(1),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .BITSIZE_proxy_out1(1),
  .HIGH_LATENCY(HIGH_LATENCY)) ARRAY_1D_STD_BRAM_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1(1&apos;b0),
  .in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD(1&apos;b0),
  .sel_STORE(1&apos;b0),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1(1&apos;b0),
  .proxy_in2({BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD(1&apos;b0),
  .proxy_sel_STORE(1&apos;b0));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>STD_BRAMN_PMI</name>
      <circuit>
        <component_o id="STD_BRAMN_PMI">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="STD_BRAMN_PMI"/>
          <parameter name="MEMORY_INIT_file_a">&quot;&quot;array_a.mem&quot;&quot;</parameter>
          <parameter name="MEMORY_INIT_file_b">&quot;&quot;array_b.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="BRAM_BITSIZE">32</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="STD_BRAMN_PMI S_oe_ram S_we_ram S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file_a MEMORY_INIT_file_b n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED BRAM_BITSIZE USE_SPARSE_MEMORY HIGH_LATENCY" IP_COMPONENT="ARRAY_1D_STD_BRAM_NN_PMI" VERILOG_PROVIDED="ARRAY_1D_STD_BRAM_NN_PMI #(.BITSIZE_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_sel_LOAD(1),
  .PORTSIZE_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_sel_STORE(1),
  .PORTSIZE_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_S_oe_ram(BITSIZE_S_oe_ram),
  .PORTSIZE_S_oe_ram(PORTSIZE_S_oe_ram),
  .BITSIZE_S_we_ram(BITSIZE_S_we_ram),
  .PORTSIZE_S_we_ram(PORTSIZE_S_we_ram),
  .BITSIZE_out1(1),
  .PORTSIZE_out1(PORTSIZE_S_addr_ram),
  .BITSIZE_S_addr_ram(BITSIZE_S_addr_ram),
  .PORTSIZE_S_addr_ram(PORTSIZE_S_addr_ram),
  .BITSIZE_S_Wdata_ram(BITSIZE_S_Wdata_ram),
  .PORTSIZE_S_Wdata_ram(PORTSIZE_S_Wdata_ram),
  .BITSIZE_Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_Sin_Rdata_ram(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram),
  .PORTSIZE_Sout_Rdata_ram(PORTSIZE_Sout_Rdata_ram),
  .BITSIZE_S_data_ram_size(BITSIZE_S_data_ram_size),
  .PORTSIZE_S_data_ram_size(PORTSIZE_S_data_ram_size),
  .BITSIZE_Sin_DataRdy(BITSIZE_Sin_DataRdy),
  .PORTSIZE_Sin_DataRdy(PORTSIZE_Sin_DataRdy),
  .BITSIZE_Sout_DataRdy(BITSIZE_Sout_DataRdy),
  .PORTSIZE_Sout_DataRdy(PORTSIZE_Sout_DataRdy),
  .MEMORY_INIT_file_a(MEMORY_INIT_file_a),
  .MEMORY_INIT_file_b(MEMORY_INIT_file_b),
  .n_elements(n_elements),
  .data_size(data_size),
  .address_space_begin(address_space_begin),
  .address_space_rangesize(address_space_rangesize),
  .BUS_PIPELINED(BUS_PIPELINED),
  .BRAM_BITSIZE(BRAM_BITSIZE),
  .PRIVATE_MEMORY(0),
  .USE_SPARSE_MEMORY(USE_SPARSE_MEMORY),
  .BITSIZE_proxy_in1(BITSIZE_Sin_Rdata_ram),
  .PORTSIZE_proxy_in1(PORTSIZE_Sin_Rdata_ram),
  .BITSIZE_proxy_in2(BITSIZE_S_addr_ram),
  .PORTSIZE_proxy_in2(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_in3(BITSIZE_S_data_ram_size),
  .PORTSIZE_proxy_in3(PORTSIZE_S_data_ram_size),
  .BITSIZE_proxy_sel_LOAD(1),
  .PORTSIZE_proxy_sel_LOAD(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_sel_STORE(1),
  .PORTSIZE_proxy_sel_STORE(PORTSIZE_S_addr_ram),
  .BITSIZE_proxy_out1(1),
  .PORTSIZE_proxy_out1(PORTSIZE_S_addr_ram),
  .HIGH_LATENCY(HIGH_LATENCY)) ARRAY_1D_STD_BRAM_NN_instance (.Sout_Rdata_ram(Sout_Rdata_ram),
  .Sout_DataRdy(Sout_DataRdy),
  .clock(clock),
  .reset(reset),
  .in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .S_oe_ram(S_oe_ram),
  .S_we_ram(S_we_ram),
  .S_addr_ram(S_addr_ram),
  .S_Wdata_ram(S_Wdata_ram),
  .Sin_Rdata_ram(Sin_Rdata_ram),
  .S_data_ram_size(S_data_ram_size),
  .Sin_DataRdy(Sin_DataRdy),
  .proxy_in1({PORTSIZE_Sin_Rdata_ram*BITSIZE_Sin_Rdata_ram{1&apos;b0}}),
  .proxy_in2({PORTSIZE_S_addr_ram*BITSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_in3({PORTSIZE_S_data_ram_size*BITSIZE_S_data_ram_size{1&apos;b0}}),
  .proxy_sel_LOAD({PORTSIZE_S_addr_ram{1&apos;b0}}),
  .proxy_sel_STORE({PORTSIZE_S_addr_ram{1&apos;b0}}));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_SDS_BASE</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_SDS_BASE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_SDS_BASE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <parameter name="ALIGNMENT">32</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> read array address </port_o>
          <port_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> write array address </port_o>
          <port_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element to be loaded </port_o>
          <port_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element to be stored </port_o>
          <port_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate for read </port_o>
          <port_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate for write </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_SDS_BASE in1 in2r in2w in3r in3w out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY ALIGNMENT proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_out1" 
            IP_COMPONENT="STD_SP_BRAM"
            VERILOG_PROVIDED="
`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_byte_on_databus = ALIGNMENT/8;
parameter nbit_addr_r = BITSIZE_in2r &gt; BITSIZE_proxy_in2r ? BITSIZE_in2r : BITSIZE_proxy_in2r;
parameter nbit_addr_w = BITSIZE_in2w &gt; BITSIZE_proxy_in2w ? BITSIZE_in2w : BITSIZE_proxy_in2w;

`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_elements == 1 ? 1 : $clog2(n_elements);
  localparam nbits_byte_offset = n_byte_on_databus&lt;=1 ? 0 : $clog2(n_byte_on_databus);
  localparam nbits_address_space_rangesize = $clog2(address_space_rangesize); 
`else
  localparam nbit_read_addr = n_elements == 1 ? 1 : log2(n_elements);
  localparam nbits_byte_offset = n_byte_on_databus&lt;=1 ? 0 : log2(n_byte_on_databus);
  localparam nbits_address_space_rangesize = log2(address_space_rangesize); 
`endif
  
wire [nbit_read_addr-1:0] memory_addr_a_r;
wire [nbit_read_addr-1:0] memory_addr_a_w;
wire bram_write;
wire [data_size-1:0] dout_a;
wire [data_size-1:0] din_a;

wire [nbit_addr_r-1:0] relative_addr_r;
wire [nbit_addr_w-1:0] relative_addr_w;

wire [nbit_addr_r-1:0] tmp_addr_r;
wire [nbit_addr_w-1:0] tmp_addr_w;

STD_SP_BRAM #(
  .BITSIZE_data_in(data_size), 
  .BITSIZE_data_out(data_size), 
  .BITSIZE_address_inr(nbit_read_addr), 
  .BITSIZE_address_inw(nbit_read_addr), 
  .n_elements(n_elements), 
  .MEMORY_INIT_file(MEMORY_INIT_file), 
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)
) STD_SP_BRAM_instance (
  .clock(clock),
  .write_enable(bram_write),
  .data_in(din_a),
  .address_inr(memory_addr_a_r),
  .address_inw(memory_addr_a_w),
  .data_out(dout_a)
);

assign din_a = (proxy_sel_STORE &amp;&amp; proxy_in4w) ? proxy_in1 : in1;
assign bram_write = (sel_STORE &amp;&amp; in4w) || (proxy_sel_STORE &amp;&amp; proxy_in4w);

assign tmp_addr_r = (proxy_sel_LOAD &amp;&amp; proxy_in4r) ? proxy_in2r : in2r;
assign tmp_addr_w = (proxy_sel_STORE &amp;&amp; proxy_in4w) ? proxy_in2w : in2w;

generate
  if(USE_SPARSE_MEMORY==1)
    assign relative_addr_r = tmp_addr_r[nbits_address_space_rangesize-1:0];
  else
    assign relative_addr_r = tmp_addr_r-address_space_begin[nbit_addr_r-1:0];
endgenerate

generate
  if(USE_SPARSE_MEMORY==1)
    assign relative_addr_w = tmp_addr_w[nbits_address_space_rangesize-1:0];
  else
    assign relative_addr_w = tmp_addr_w-address_space_begin[nbit_addr_w-1:0];
endgenerate

generate
  if (n_elements==1)
    assign memory_addr_a_r = {nbit_read_addr{1&apos;b0}};
  else
    assign memory_addr_a_r = relative_addr_r[nbit_read_addr+nbits_byte_offset-1:nbits_byte_offset];
endgenerate

generate
  if (n_elements==1)
    assign memory_addr_a_w = {nbit_read_addr{1&apos;b0}};
  else
    assign memory_addr_a_w = relative_addr_w[nbit_read_addr+nbits_byte_offset-1:nbits_byte_offset];
endgenerate


assign out1 = dout_a;
assign proxy_out1 = dout_a;
assign Sout_Rdata_ram =Sin_Rdata_ram;
assign Sout_DataRdy = Sin_DataRdy;
// Add assertion here
// psl default clock = (posedge clock);
// psl ERROR_SDS_data_ram_size: assert never {((data_size != in3r &amp;&amp; sel_LOAD &amp;&amp; in4r) || (data_size != in3w &amp;&amp; sel_STORE &amp; in4w)) || ((data_size != proxy_in3r &amp;&amp; proxy_sel_LOAD &amp;&amp; proxy_in4r) || (data_size != proxy_in3w &amp;&amp; proxy_sel_STORE &amp;&amp; proxy_in4w))};
// psl ERROR_SDS_alignment: assert never {(((in2r-address_space_begin) %(ALIGNMENT/8) != 0) &amp;&amp; sel_LOAD &amp;&amp; in4r) || (((in2r-address_space_begin) %(ALIGNMENT/8) != 0) &amp;&amp; sel_STORE &amp;&amp; in4w) || (((proxy_in2r-address_space_begin) %(ALIGNMENT/8) != 0) &amp;&amp; proxy_sel_LOAD  &amp;&amp; proxy_in4r) || (((proxy_in2w-address_space_begin) %(ALIGNMENT/8) != 0) &amp;&amp; proxy_sel_STORE &amp;&amp; proxy_in4w)};
"
            VHDL_PROVIDED="
  function integer_ternary_operator(cond : boolean; op1 : integer; op2 : integer) return integer is
  begin
    if cond then
      return op1;
    else
      return op2;
    end if;
  end integer_ternary_operator;
  constant n_byte_on_databus : integer := ALIGNMENT/8;
  constant nbit_addr_r         : integer := integer_ternary_operator(BITSIZE_in2r &gt; BITSIZE_proxy_in2r, BITSIZE_in2r, BITSIZE_proxy_in2r);
  constant nbit_addr_w         : integer := integer_ternary_operator(BITSIZE_in2w &gt; BITSIZE_proxy_in2w, BITSIZE_in2w, BITSIZE_proxy_in2w);
  constant nbit_read_addr    : integer := integer_ternary_operator(n_elements = 1, 1, integer(ceil(log2(real(n_elements)))));
  constant nbits_byte_offset : integer := integer_ternary_operator(n_byte_on_databus &lt;= 1, 0, integer(ceil(log2(real(n_byte_on_databus)))));

  constant nbits_address_space_rangesize  : integer := integer(ceil(log2(real(address_space_rangesize)))); 
  
  signal memory_addr_a_r : std_logic_vector(nbit_read_addr-1 downto 0);
  signal memory_addr_a_w : std_logic_vector(nbit_read_addr-1 downto 0);

  signal bram_write : std_logic;
  signal dout_a : std_logic_vector(data_size-1 downto 0);
  signal din_a : std_logic_vector(data_size-1 downto 0);

  signal relative_addr_r : std_logic_vector(nbit_addr_r-1 downto 0);
  signal relative_addr_w : std_logic_vector(nbit_addr_w-1 downto 0);

  signal tmp_addr_r : std_logic_vector(nbit_addr_r-1 downto 0);
  signal tmp_addr_w : std_logic_vector(nbit_addr_w-1 downto 0);

begin

  STD_SP_BRAM_instance : STD_SP_BRAM generic map(
    BITSIZE_data_in=>data_size, 
    BITSIZE_data_out=>data_size, 
    BITSIZE_address_inr=>nbit_read_addr, 
    BITSIZE_address_inw=>nbit_read_addr, 
    n_elements=>n_elements, 
    MEMORY_INIT_file=>MEMORY_INIT_file, 
    READ_ONLY_MEMORY=>READ_ONLY_MEMORY,
    HIGH_LATENCY=>HIGH_LATENCY
  ) port map (
    data_out => dout_a,
    write_enable => bram_write,
    clock => clock,
    data_in => din_a,
    address_inr => memory_addr_a_r,
    address_inw => memory_addr_a_w);

  din_a &lt;= std_logic_vector(resize(unsigned(proxy_in1), data_size))  when ((proxy_sel_STORE = &apos;1&apos;) and (proxy_in4w = &apos;1&apos;)) else std_logic_vector(resize(unsigned(in1), data_size));
  bram_write &lt;= (sel_STORE and in4w) or (proxy_sel_STORE and proxy_in4w);

  tmp_addr_r &lt;= proxy_in2r when ((proxy_sel_LOAD  = &apos;1&apos;) and (proxy_in4r = &apos;1&apos;)) else in2r;
  tmp_addr_w &lt;= proxy_in2w when ((proxy_sel_STORE = &apos;1&apos;) and (proxy_in4w = &apos;1&apos;)) else in2w;

  L2_r : process(relative_addr_r)
  begin
    if(n_elements=1) then
      memory_addr_a_r &lt;= (others =&gt; &apos;0&apos;);
    else
      memory_addr_a_r &lt;= relative_addr_r(nbit_read_addr+nbits_byte_offset-1 downto nbits_byte_offset);
    end if;
  end process;

  L2_w : process(relative_addr_w)
  begin
    if(n_elements=1) then
      memory_addr_a_w &lt;= (others =&gt; &apos;0&apos;);
    else
      memory_addr_a_w &lt;= relative_addr_w(nbit_read_addr+nbits_byte_offset-1 downto nbits_byte_offset);
    end if;
  end process;

  L3_r : process(tmp_addr_r)
  begin
      if(USE_SPARSE_MEMORY=1) then
        relative_addr_r &lt;= std_logic_vector(resize(unsigned(tmp_addr_r(nbits_address_space_rangesize-1 downto 0)), nbit_addr_r));
      else
        relative_addr_r &lt;= std_logic_vector(resize(unsigned(tmp_addr_r), nbit_addr_r) - to_unsigned(address_space_begin, nbit_addr_r));
      end if;
  end process;

  L3_w : process(tmp_addr_w)
  begin
      if(USE_SPARSE_MEMORY=1) then
        relative_addr_w &lt;= std_logic_vector(resize(unsigned(tmp_addr_w(nbits_address_space_rangesize-1 downto 0)), nbit_addr_w));
      else
        relative_addr_w &lt;= std_logic_vector(resize(unsigned(tmp_addr_w), nbit_addr_w) - to_unsigned(address_space_begin, nbit_addr_w));
      end if;
  end process;

  out1 &lt;= dout_a;
  proxy_out1 &lt;= std_logic_vector(resize(unsigned(dout_a), BITSIZE_proxy_out1));
  Sout_Rdata_ram &lt;=Sin_Rdata_ram;
  Sout_DataRdy &lt;= Sin_DataRdy;
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_SDS_BUS_BASE</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_SDS_BUS_BASE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_SDS_BUS_BASE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <parameter name="ALIGNMENT">32</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> arrary address </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element loaded or stored </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_SDS_BUS_BASE in1 in2 in3 out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY ALIGNMENT proxy_in1 proxy_in2 proxy_in3 proxy_out1"
            IP_COMPONENT="STD_SP_BRAM"
            VERILOG_PROVIDED="
`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_byte_on_databus = ALIGNMENT/8;
parameter nbit_addr = BITSIZE_in2 &gt; BITSIZE_proxy_in2 ? BITSIZE_in2 : BITSIZE_proxy_in2;

`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_elements == 1 ? 1 : $clog2(n_elements);
  localparam nbits_byte_offset = n_byte_on_databus&lt;=1 ? 0 : $clog2(n_byte_on_databus);
  localparam nbits_address_space_rangesize = $clog2(address_space_rangesize);
`else
  localparam nbit_read_addr = n_elements == 1 ? 1 : log2(n_elements);
  localparam nbits_byte_offset = n_byte_on_databus&lt;=1 ? 0 : log2(n_byte_on_databus);
  localparam nbits_address_space_rangesize = log2(address_space_rangesize);
`endif
  
wire [nbit_read_addr-1:0] memory_addr_a;
wire bram_write;
wire [data_size-1:0] dout_a;
wire [data_size-1:0] din_a;

wire cs, oe_ram_cs, we_ram_cs;
reg we_ram_cs_delayed;
reg oe_ram_cs_delayed;
reg oe_ram_cs_delayed_registered;
reg oe_ram_cs_delayed_registered1;
wire [nbit_addr-1:0] relative_addr;
wire [nbit_addr-1:0] tmp_addr;

STD_SP_BRAM #(
  .BITSIZE_data_in(data_size), 
  .BITSIZE_data_out(data_size), 
  .BITSIZE_address_inr(nbit_read_addr), 
  .BITSIZE_address_inw(nbit_read_addr), 
  .n_elements(n_elements), 
  .MEMORY_INIT_file(MEMORY_INIT_file), 
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)
) STD_SP_BRAM_instance (
  .clock(clock), 
  .write_enable(bram_write),
  .data_in(din_a),
  .address_inr(memory_addr_a), 
  .address_inw(memory_addr_a),
  .data_out(dout_a)
);

assign din_a = proxy_sel_STORE ? proxy_in1 : sel_STORE ? in1 : S_Wdata_ram;
assign bram_write = sel_STORE || proxy_sel_STORE || we_ram_cs;

assign tmp_addr = (proxy_sel_LOAD||proxy_sel_STORE) ? proxy_in2 : in2;

generate
  if(PRIVATE_MEMORY==0 &amp;&amp; USE_SPARSE_MEMORY==0)
    assign cs = (S_addr_ram &gt;= (address_space_begin)) &amp;&amp; (S_addr_ram &lt; (address_space_begin+address_space_rangesize));
  else if(PRIVATE_MEMORY==0 &amp;&amp; nbits_address_space_rangesize &lt; 32)
    assign cs = S_addr_ram[nbit_addr-1:nbits_address_space_rangesize] == address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):nbits_address_space_rangesize];
  else
    assign cs = 1&apos;b0;
endgenerate

assign oe_ram_cs = S_oe_ram &amp;&amp; cs;
assign we_ram_cs = S_we_ram &amp;&amp; cs;

generate
  if(PRIVATE_MEMORY==0 &amp;&amp; USE_SPARSE_MEMORY==0)
    assign relative_addr = (sel_STORE===1&apos;b1 || sel_LOAD===1&apos;b1 || proxy_sel_STORE===1&apos;b1 || proxy_sel_LOAD===1&apos;b1) ? tmp_addr-address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):0] : S_addr_ram-address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):0];
  else if(PRIVATE_MEMORY==0)
    assign relative_addr = (sel_STORE===1&apos;b1 || sel_LOAD===1&apos;b1 || proxy_sel_STORE===1&apos;b1 || proxy_sel_LOAD===1&apos;b1) ? tmp_addr[nbits_address_space_rangesize-1:0] : S_addr_ram[nbits_address_space_rangesize-1:0];
  else if(USE_SPARSE_MEMORY==1)
    assign relative_addr = tmp_addr[nbits_address_space_rangesize-1:0];
  else
    assign relative_addr = tmp_addr-address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):0];
endgenerate

generate
  if (n_elements==1)
    assign memory_addr_a = {nbit_read_addr{1&apos;b0}};
  else
    assign memory_addr_a = relative_addr[nbit_read_addr+nbits_byte_offset-1:nbits_byte_offset];
endgenerate

assign out1 = dout_a;
assign proxy_out1 = dout_a;
always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
    begin
      oe_ram_cs_delayed &lt;= 1&apos;b0;
      if(HIGH_LATENCY != 0) oe_ram_cs_delayed_registered &lt;= 1&apos;b0;
      if(HIGH_LATENCY == 2) oe_ram_cs_delayed_registered1 &lt;= 1&apos;b0;
    end
  else
    begin
      if(HIGH_LATENCY==0)
        oe_ram_cs_delayed &lt;= oe_ram_cs &amp; (!oe_ram_cs_delayed | BUS_PIPELINED);
      else if(HIGH_LATENCY==1)
      begin
        oe_ram_cs_delayed_registered &lt;= oe_ram_cs &amp; ((!oe_ram_cs_delayed_registered &amp; !oe_ram_cs_delayed) | BUS_PIPELINED);
        oe_ram_cs_delayed &lt;= oe_ram_cs_delayed_registered;
      end
      else
      begin
        oe_ram_cs_delayed_registered1 &lt;= oe_ram_cs &amp; ((!oe_ram_cs_delayed_registered1 &amp; !oe_ram_cs_delayed_registered) | BUS_PIPELINED);
        oe_ram_cs_delayed_registered &lt;= oe_ram_cs_delayed_registered1;
        oe_ram_cs_delayed &lt;= oe_ram_cs_delayed_registered;
      end
    end
end
  
always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
    we_ram_cs_delayed &lt;= 1&apos;b0;
  else
    we_ram_cs_delayed &lt;= we_ram_cs &amp; !we_ram_cs_delayed;
end

generate
  if(PRIVATE_MEMORY==1)
    assign Sout_Rdata_ram =Sin_Rdata_ram;
  else if (BITSIZE_Sout_Rdata_ram &lt;= data_size)
    assign Sout_Rdata_ram = oe_ram_cs_delayed ? dout_a[BITSIZE_Sout_Rdata_ram-1:0] : Sin_Rdata_ram;
  else
    assign Sout_Rdata_ram = oe_ram_cs_delayed ? {{BITSIZE_Sout_Rdata_ram-data_size{1&apos;b0}}, dout_a} : Sin_Rdata_ram;
endgenerate

generate
  if(PRIVATE_MEMORY==1)
    assign Sout_DataRdy = Sin_DataRdy;
  else
    assign Sout_DataRdy = oe_ram_cs_delayed | Sin_DataRdy | we_ram_cs_delayed;
endgenerate

// Add assertion here
// psl default clock = (posedge clock);
// psl ERROR_SDS_data_ram_size: assert never {(data_size != in3 &amp;&amp; (sel_LOAD || sel_STORE)) || (data_size != proxy_in3 &amp;&amp; (proxy_sel_LOAD || proxy_sel_STORE))};
// psl ERROR_SDS_alignment: assert never {(((in2-address_space_begin) %(ALIGNMENT/8) != 0) &amp;&amp; (sel_LOAD || sel_STORE)) || (((proxy_in2-address_space_begin) %(ALIGNMENT/8) != 0) &amp;&amp; (proxy_sel_LOAD || proxy_sel_STORE))};"
            VHDL_PROVIDED="  function integer_ternary_operator(cond : boolean; op1 : integer; op2 : integer) return integer is
  begin
    if cond then
      return op1;
    else
      return op2;
    end if;
  end integer_ternary_operator;
  constant n_byte_on_databus : integer := ALIGNMENT/8;
  constant nbit_addr         : integer := integer_ternary_operator(BITSIZE_in2 &gt; BITSIZE_proxy_in2, BITSIZE_in2, BITSIZE_proxy_in2);
  constant nbit_read_addr    : integer := integer_ternary_operator(n_elements = 1, 1, integer(ceil(log2(real(n_elements)))));
  constant nbits_byte_offset : integer := integer_ternary_operator(n_byte_on_databus &lt;= 1, 0, integer(ceil(log2(real(n_byte_on_databus)))));

  constant nbits_address_space_rangesize  : integer := integer(ceil(log2(real(address_space_rangesize))));
  constant address_space_begin_u         : unsigned(nbit_addr-1 downto 0) := to_unsigned(address_space_begin, nbit_addr);
  signal memory_addr_a : std_logic_vector(nbit_read_addr-1 downto 0);
  signal memory_addr_a_mem : std_logic_vector(nbit_read_addr-1 downto 0);
  signal memory_addr_a1 : std_logic_vector(nbit_read_addr-1 downto 0);

  signal bram_write : std_logic;
  signal bram_write_mem : std_logic;
  signal bram_write1 : std_logic;

  signal dout_a_tmp : std_logic_vector(data_size-1 downto 0) ;
  signal dout_a : std_logic_vector(data_size-1 downto 0);
  signal dout_a_registered : std_logic_vector(data_size-1 downto 0);
  signal cs, oe_ram_cs, we_ram_cs: std_logic;
  signal we_ram_cs_delayed : std_logic;
  signal oe_ram_cs_delayed : std_logic;
  signal oe_ram_cs_delayed_registered : std_logic;
  signal oe_ram_cs_delayed_registered1 : std_logic;

  signal relative_addr : std_logic_vector(nbit_addr-1 downto 0);
  signal tmp_addr : std_logic_vector(nbit_addr-1 downto 0);
  signal din_a : std_logic_vector(data_size-1 downto 0);
  signal din_a_mem : std_logic_vector(data_size-1 downto 0);
  signal din_a1 : std_logic_vector(data_size-1 downto 0);

begin

  STD_SP_BRAM_instance : STD_SP_BRAM generic map(
    BITSIZE_data_in=>data_size, 
    BITSIZE_data_out=>data_size, 
    BITSIZE_address_inr=>nbit_read_addr, 
    BITSIZE_address_inw=>nbit_read_addr, 
    n_elements=>n_elements, 
    MEMORY_INIT_file=>MEMORY_INIT_file, 
    READ_ONLY_MEMORY=>READ_ONLY_MEMORY,
    HIGH_LATENCY=>HIGH_LATENCY
  ) port map (
    data_out => dout_a,
    write_enable => bram_write,
    clock => clock, 
    data_in => din_a,
    address_inr => memory_addr_a,
    address_inw => memory_addr_a
  );

  din_a &lt;= std_logic_vector(resize(unsigned(proxy_in1), data_size))  when (proxy_sel_STORE = &apos;1&apos;) else std_logic_vector(resize(unsigned(in1), data_size)) when  (sel_STORE = &apos;1&apos;) else std_logic_vector(resize(unsigned(S_Wdata_ram), data_size));
  bram_write &lt;= sel_STORE or proxy_sel_STORE or we_ram_cs;

  tmp_addr &lt;= proxy_in2 when ((proxy_sel_LOAD or proxy_sel_STORE)=&apos;1&apos;) else in2;

  L3 : process(S_addr_ram)
  begin
    if(PRIVATE_MEMORY = 0 and USE_SPARSE_MEMORY = 0) then
       if(to_integer(unsigned(S_addr_ram)) &gt;= (address_space_begin)) and (to_integer(unsigned(S_addr_ram)) &lt; (address_space_begin+address_space_rangesize)) then
          cs &lt;= &apos;1&apos;;
       else
          cs &lt;= &apos;0&apos;;
       end if;
    else
       if(PRIVATE_MEMORY=0) then
          if S_addr_ram(nbit_addr-1 downto nbits_address_space_rangesize) = std_logic_vector(address_space_begin_u(nbit_addr-1 downto nbits_address_space_rangesize)) then
             cs &lt;= &apos;1&apos;;
          else
             cs &lt;= &apos;0&apos;;
          end if;
       else
          cs &lt;= &apos;0&apos;;
       end if;
    end if;
  end process;
  
  oe_ram_cs &lt;= S_oe_ram and cs;
  we_ram_cs &lt;= S_we_ram and cs;

  L6 : process(sel_STORE, proxy_sel_STORE, sel_LOAD, proxy_sel_LOAD, tmp_addr, S_addr_ram)
  begin
      if(PRIVATE_MEMORY=0 and USE_SPARSE_MEMORY=0) then
         if(sel_STORE = &apos;1&apos; or sel_LOAD = &apos;1&apos; or proxy_sel_STORE = &apos;1&apos; or proxy_sel_LOAD = &apos;1&apos;) then
            relative_addr &lt;= std_logic_vector(unsigned(tmp_addr)-(to_unsigned(address_space_begin, nbit_addr)));
         else
            relative_addr &lt;= std_logic_vector(unsigned(S_addr_ram) - (to_unsigned(address_space_begin, nbit_addr)));
         end if;
      else
         if(PRIVATE_MEMORY=0) then
            if(sel_STORE = &apos;1&apos; or sel_LOAD = &apos;1&apos; or proxy_sel_STORE = &apos;1&apos; or proxy_sel_LOAD = &apos;1&apos;) then
               relative_addr &lt;= std_logic_vector(resize(unsigned(tmp_addr(nbits_address_space_rangesize-1 downto 0)), nbit_addr));
            else
               relative_addr &lt;= std_logic_vector(resize(unsigned(S_addr_ram(nbits_address_space_rangesize-1 downto 0)), nbit_addr));
            end if;
         else
            if(USE_SPARSE_MEMORY=1) then
               relative_addr &lt;= std_logic_vector(resize(unsigned(tmp_addr(nbits_address_space_rangesize-1 downto 0)), nbit_addr));
            else
               relative_addr &lt;= std_logic_vector(unsigned(tmp_addr) - to_unsigned(address_space_begin, nbit_addr));
            end if;
         end if;
      end if;
   end process;

   L7_A : process(relative_addr)
   begin
      if (n_elements=1) then
         memory_addr_a &lt;= (others =&gt; &apos;0&apos;);
      elsif (n_byte_on_databus&lt;=1) then
         memory_addr_a &lt;= relative_addr(nbit_read_addr-1 downto 0);
      else
         memory_addr_a &lt;= relative_addr(nbit_read_addr+nbits_byte_offset-1 downto nbits_byte_offset);
      end if;
   end process;

   out1 &lt;= std_logic_vector(resize(unsigned(dout_a), BITSIZE_out1));
   proxy_out1 &lt;= std_logic_vector(resize(unsigned(dout_a), BITSIZE_proxy_out1));

   L16 : process(reset, clock)
   begin
      if(1RESET_VALUE) then
         oe_ram_cs_delayed &lt;= &apos;0&apos;;
         if(HIGH_LATENCY /= 0) then
            oe_ram_cs_delayed_registered &lt;= &apos;0&apos;;
         end if;
         if(HIGH_LATENCY = 2) then
            oe_ram_cs_delayed_registered1 &lt;= &apos;0&apos;;
         end if;
      else
         if (clock&apos;event and clock = &apos;1&apos;) then
            if(HIGH_LATENCY = 0) then
               if(BUS_PIPELINED /= 0) then
                  oe_ram_cs_delayed &lt;= oe_ram_cs;
               else
                  oe_ram_cs_delayed &lt;= oe_ram_cs and (not oe_ram_cs_delayed);
               end if;
            elsif(HIGH_LATENCY = 1) then
               if(BUS_PIPELINED /= 0) then
                  oe_ram_cs_delayed_registered &lt;= oe_ram_cs;
               else
                  oe_ram_cs_delayed_registered &lt;= oe_ram_cs and ((not oe_ram_cs_delayed_registered and not oe_ram_cs_delayed));
               end if;
               oe_ram_cs_delayed &lt;= oe_ram_cs_delayed_registered;
            else
               if(BUS_PIPELINED /= 0) then
                  oe_ram_cs_delayed_registered1 &lt;= oe_ram_cs;
               else
                  oe_ram_cs_delayed_registered1 &lt;= oe_ram_cs and ((not oe_ram_cs_delayed_registered1 and not oe_ram_cs_delayed_registered and not oe_ram_cs_delayed));
               end if;
               oe_ram_cs_delayed_registered &lt;= oe_ram_cs_delayed_registered1;
               oe_ram_cs_delayed &lt;= oe_ram_cs_delayed_registered;
            end if;
         end if;
      end if;
   end process;

   process(clock, reset)
   begin
      if(1RESET_VALUE) then
         we_ram_cs_delayed &lt;= &apos;0&apos;;
      else
         if (clock&apos;event and clock = &apos;1&apos;) then
            we_ram_cs_delayed &lt;= we_ram_cs and not we_ram_cs_delayed;
         end if;
      end if;
   end process;

   L18 : process(Sin_Rdata_ram, dout_a, oe_ram_cs_delayed)
   begin
      if(PRIVATE_MEMORY=1) then
         Sout_Rdata_ram(BITSIZE_Sout_Rdata_ram-1 downto 0) &lt;= Sin_Rdata_ram(BITSIZE_Sin_Rdata_ram-1 downto 0);
      else
         if (BITSIZE_Sout_Rdata_ram &lt;= data_size) then
            if(oe_ram_cs_delayed /= &apos;0&apos;) then
               Sout_Rdata_ram &lt;= dout_a(BITSIZE_Sout_Rdata_ram-1 downto 0);
            else
               Sout_Rdata_ram &lt;= Sin_Rdata_ram;
            end if;
         else
            if(oe_ram_cs_delayed /= &apos;0&apos;) then
               Sout_Rdata_ram &lt;= std_logic_vector(resize(unsigned(dout_a), BITSIZE_Sout_Rdata_ram));
            else
               Sout_Rdata_ram &lt;= Sin_Rdata_ram;
            end if;
         end if;
      end if;
   end process;

   L19 : process(oe_ram_cs_delayed, Sin_DataRdy, we_ram_cs_delayed)
   begin
      if(PRIVATE_MEMORY=0) then
         Sout_DataRdy &lt;= oe_ram_cs_delayed or Sin_DataRdy or we_ram_cs_delayed;
      else
         Sout_DataRdy &lt;= Sin_DataRdy;
      end if;
   end process;
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_NN_SDS_BASE</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_NN_SDS_BASE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_NN_SDS_BASE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <parameter name="ALIGNMENT">32</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_vector_o>
          <port_vector_o id="in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> read array address </port_vector_o>
          <port_vector_o id="in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> write array address </port_vector_o>
          <port_vector_o id="in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element to be loaded </port_vector_o>
          <port_vector_o id="in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element to be stored </port_vector_o>
          <port_vector_o id="in4r" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> read predicate </port_vector_o>
          <port_vector_o id="in4w" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> write predicate </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_slave="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2r" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2w" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3r" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3w" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4r" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in4w" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_NN_SDS_BASE in1 in2r in2w in3r in3w in4r in4w sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY ALIGNMENT proxy_in1 proxy_in2r proxy_in2w proxy_in3r proxy_in3w proxy_in4r proxy_in4w proxy_sel_LOAD proxy_sel_STORE proxy_out1"
            IP_COMPONENT="STD_NRNW_BRAM_GEN"
            VERILOG_PROVIDED="
`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_byte_on_databus = ALIGNMENT/8;
parameter nbit_addr_r = BITSIZE_in2r &gt; BITSIZE_proxy_in2r ? BITSIZE_in2r : BITSIZE_proxy_in2r;
parameter nbit_addr_w = BITSIZE_in2w &gt; BITSIZE_proxy_in2w ? BITSIZE_in2w : BITSIZE_proxy_in2w;
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_elements == 1 ? 1 : $clog2(n_elements);
  localparam nbits_byte_offset = n_byte_on_databus&lt;=1 ? 0 : $clog2(n_byte_on_databus);
`else
  localparam nbit_read_addr = n_elements == 1 ? 1 : log2(n_elements);
  localparam nbits_byte_offset = n_byte_on_databus&lt;=1 ? 0 : log2(n_byte_on_databus);
`endif
parameter max_n_writes = PORTSIZE_sel_STORE;
parameter max_n_reads = PORTSIZE_sel_LOAD;

wire [nbit_read_addr*max_n_reads-1:0] memory_addr_a_r;
wire [nbit_read_addr*max_n_writes-1:0] memory_addr_a_w;

wire [max_n_writes-1:0] bram_write;

wire [data_size*max_n_reads-1:0] dout_a;
wire [nbit_addr_r*max_n_reads-1:0] relative_addr_r;
wire [nbit_addr_w*max_n_writes-1:0] relative_addr_w;
wire [nbit_addr_r*max_n_reads-1:0] tmp_addr_r;
wire [nbit_addr_w*max_n_writes-1:0] tmp_addr_w;
wire [data_size*max_n_writes-1:0] din_a;
wire [data_size*max_n_writes-1:0] din_a_mem;
reg [data_size*max_n_writes-1:0] din_a1;

STD_NRNW_BRAM_GEN #(
  .PORTSIZE_we_a(max_n_writes),
  .BITSIZE_we_a(1),
  .PORTSIZE_din_value(max_n_writes),
  .BITSIZE_din_value(data_size),
  .PORTSIZE_dout_value(max_n_reads),
  .BITSIZE_dout_value(data_size),
  .PORTSIZE_raddr(max_n_reads),
  .BITSIZE_raddr(nbit_read_addr),
  .PORTSIZE_waddr(max_n_writes),
  .BITSIZE_waddr(nbit_read_addr),
  .n_mem_elements(n_elements),
  .MEMORY_INIT_file(MEMORY_INIT_file),
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)
) STD_NRNW_BRAM_GEN_instance (
  .clock(clock),
  .we_a(bram_write),
  .din_value(din_a),
  .raddr(memory_addr_a_r),
  .waddr(memory_addr_a_w),
  .dout_value(dout_a)
);

generate
genvar i14;
  for (i14=0; i14&lt;max_n_writes; i14=i14+1)
  begin : L14
    assign din_a[(i14+1)*data_size-1:i14*data_size] = (proxy_sel_STORE[i14] &amp;&amp; proxy_in4w[i14]) ? proxy_in1[(i14+1)*BITSIZE_proxy_in1-1:i14*BITSIZE_proxy_in1] : in1[(i14+1)*BITSIZE_in1-1:i14*BITSIZE_in1];
  end
endgenerate

generate
genvar i21;
  for (i21=0; i21&lt;max_n_writes; i21=i21+1)
  begin : L21
      assign bram_write[i21] = (sel_STORE[i21] &amp;&amp; in4w[i21]) || (proxy_sel_STORE[i21] &amp;&amp; proxy_in4w[i21]);
  end
endgenerate

generate
genvar ind2r;
for (ind2r=0; ind2r&lt;max_n_reads; ind2r=ind2r+1)
  begin : Lind2r
    assign tmp_addr_r[(ind2r+1)*nbit_addr_r-1:ind2r*nbit_addr_r] = (proxy_sel_LOAD[ind2r] &amp;&amp; proxy_in4r[ind2r]) ? proxy_in2r[(ind2r+1)*BITSIZE_proxy_in2r-1:ind2r*BITSIZE_proxy_in2r] : in2r[(ind2r+1)*BITSIZE_in2r-1:ind2r*BITSIZE_in2r];
  end
endgenerate

generate
genvar ind2w;
for (ind2w=0; ind2w&lt;max_n_writes; ind2w=ind2w+1)
  begin : Lind2w
    assign tmp_addr_w[(ind2w+1)*nbit_addr_w-1:ind2w*nbit_addr_w] = (proxy_sel_STORE[ind2w] &amp;&amp; proxy_in4w[ind2w]) ? proxy_in2w[(ind2w+1)*BITSIZE_proxy_in2w-1:ind2w*BITSIZE_proxy_in2w] : in2w[(ind2w+1)*BITSIZE_in2w-1:ind2w*BITSIZE_in2w];
  end
endgenerate

generate
genvar i6r;
  for (i6r=0; i6r&lt;max_n_reads; i6r=i6r+1)
  begin : L6r
    if(USE_SPARSE_MEMORY==1)
      assign relative_addr_r[(i6r+1)*nbit_addr_r-1:i6r*nbit_addr_r] = tmp_addr_r[(i6r+1)*nbit_addr_r-1:i6r*nbit_addr_r];
    else
      assign relative_addr_r[(i6r+1)*nbit_addr_r-1:i6r*nbit_addr_r] = tmp_addr_r[(i6r+1)*nbit_addr_r-1:i6r*nbit_addr_r]-address_space_begin;
  end
endgenerate

generate
genvar i6w;
  for (i6w=0; i6w&lt;max_n_writes; i6w=i6w+1)
  begin : L6w
    if(USE_SPARSE_MEMORY==1)
      assign relative_addr_w[(i6w+1)*nbit_addr_w-1:i6w*nbit_addr_w] = tmp_addr_w[(i6w+1)*nbit_addr_w-1:i6w*nbit_addr_w];
    else
      assign relative_addr_w[(i6w+1)*nbit_addr_w-1:i6w*nbit_addr_w] = tmp_addr_w[(i6w+1)*nbit_addr_w-1:i6w*nbit_addr_w]-address_space_begin;
  end
endgenerate

generate
genvar i7r;
  for (i7r=0; i7r&lt;max_n_reads; i7r=i7r+1)
  begin : L7_Ar
    if (n_elements==1)
      assign memory_addr_a_r[(i7r+1)*nbit_read_addr-1:i7r*nbit_read_addr] = {nbit_read_addr{1&apos;b0}};
    else
      assign memory_addr_a_r[(i7r+1)*nbit_read_addr-1:i7r*nbit_read_addr] = relative_addr_r[nbit_read_addr+nbits_byte_offset-1+i7r*nbit_addr_r:nbits_byte_offset+i7r*nbit_addr_r];
  end
endgenerate

generate
genvar i7w;
  for (i7w=0; i7w&lt;max_n_writes; i7w=i7w+1)
  begin : L7_Aw
    if (n_elements==1)
      assign memory_addr_a_w[(i7w+1)*nbit_read_addr-1:i7w*nbit_read_addr] = {nbit_read_addr{1&apos;b0}};
    else
      assign memory_addr_a_w[(i7w+1)*nbit_read_addr-1:i7w*nbit_read_addr] = relative_addr_w[nbit_read_addr+nbits_byte_offset-1+i7w*nbit_addr_w:nbits_byte_offset+i7w*nbit_addr_w];
  end
endgenerate

assign out1 = dout_a;
assign proxy_out1 = dout_a;
assign Sout_Rdata_ram =Sin_Rdata_ram;
assign Sout_DataRdy = Sin_DataRdy;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ARRAY_1D_STD_BRAM_NN_SDS_BUS_BASE</name>
      <circuit>
        <component_o id="ARRAY_1D_STD_BRAM_NN_SDS_BUS_BASE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ARRAY_1D_STD_BRAM_NN_SDS_BUS_BASE"/>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <parameter name="n_elements">1</parameter>
          <parameter name="data_size">32</parameter>
          <parameter name="address_space_begin">0</parameter>
          <parameter name="address_space_rangesize">4</parameter>
          <parameter name="BUS_PIPELINED">1</parameter>
          <parameter name="PRIVATE_MEMORY">0</parameter>
          <parameter name="READ_ONLY_MEMORY">0</parameter>
          <parameter name="USE_SPARSE_MEMORY">1</parameter>
          <parameter name="HIGH_LATENCY">0</parameter>
          <parameter name="ALIGNMENT">32</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> arrary address </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> size of the element loaded or stored </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data returned by a LOAD operation </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in1" dir="IN" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="proxy_out1" dir="OUT" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="ARRAY_1D_STD_BRAM_NN_SDS_BUS_BASE in1 in2 in3 sel_LOAD sel_STORE S_oe_ram S_we_ram out1 S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy MEMORY_INIT_file n_elements data_size address_space_begin address_space_rangesize BUS_PIPELINED PRIVATE_MEMORY READ_ONLY_MEMORY USE_SPARSE_MEMORY HIGH_LATENCY ALIGNMENT proxy_in1 proxy_in2 proxy_in3 proxy_sel_LOAD proxy_sel_STORE proxy_out1" 
            IP_COMPONENT="STD_NRNW_BRAM_GEN"
            VERILOG_PROVIDED="
`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
parameter n_byte_on_databus = ALIGNMENT/8;
parameter nbit_addr = BITSIZE_in2 &gt; BITSIZE_proxy_in2 ? BITSIZE_in2 : BITSIZE_proxy_in2;
`ifdef _SIM_HAVE_CLOG2
  localparam nbit_read_addr = n_elements == 1 ? 1 : $clog2(n_elements);
  localparam nbits_address_space_rangesize = $clog2(address_space_rangesize);
  localparam nbits_byte_offset = n_byte_on_databus&lt;=1 ? 0 : $clog2(n_byte_on_databus);
`else
  localparam nbit_read_addr = n_elements == 1 ? 1 : log2(n_elements);
  localparam nbits_address_space_rangesize = log2(address_space_rangesize);
  localparam nbits_byte_offset = n_byte_on_databus&lt;=1 ? 0 : log2(n_byte_on_databus);
`endif
parameter max_n_writes = PORTSIZE_sel_STORE;
parameter max_n_reads = PORTSIZE_sel_LOAD;
parameter max_n_rw = max_n_writes &gt; max_n_reads ? max_n_writes : max_n_reads;
parameter n_bus_ports = PORTSIZE_S_addr_ram;

wire [nbit_read_addr*max_n_rw-1:0] memory_addr_a;
  
wire [max_n_writes-1:0] bram_write;
wire [data_size*max_n_reads-1:0] dout_a;
wire [n_bus_ports-1:0] cs;
wire [n_bus_ports-1:0] oe_ram_cs;
wire [n_bus_ports-1:0] we_ram_cs;
reg [n_bus_ports-1:0] we_ram_cs_delayed;
reg [n_bus_ports-1:0] oe_ram_cs_delayed;
reg [n_bus_ports-1:0] oe_ram_cs_delayed_registered;
reg [n_bus_ports-1:0] oe_ram_cs_delayed_registered1;
wire [nbit_addr*max_n_rw-1:0] relative_addr;
wire [nbit_addr*max_n_rw-1:0] tmp_addr;
wire [data_size*max_n_writes-1:0] din_a;
wire [data_size*max_n_writes-1:0] din_a_mem;
reg [data_size*max_n_writes-1:0] din_a1;
wire [data_size*PORTSIZE_S_Wdata_ram-1:0] S_Wdata_ram_int;

STD_NRNW_BRAM_GEN #(
  .PORTSIZE_we_a(max_n_writes), 
  .BITSIZE_we_a(1), 
  .PORTSIZE_din_value(max_n_writes), 
  .BITSIZE_din_value(data_size), 
  .PORTSIZE_dout_value(max_n_reads), 
  .BITSIZE_dout_value(data_size), 
  .PORTSIZE_raddr(max_n_rw), 
  .BITSIZE_raddr(nbit_read_addr), 
  .PORTSIZE_waddr(max_n_rw), 
  .BITSIZE_waddr(nbit_read_addr), 
  .n_mem_elements(n_elements), 
  .MEMORY_INIT_file(MEMORY_INIT_file), 
  .READ_ONLY_MEMORY(READ_ONLY_MEMORY),
  .HIGH_LATENCY(HIGH_LATENCY)
) STD_NRNW_BRAM_GEN_instance (
  .clock(clock), 
  .we_a(bram_write),
  .din_value(din_a),
  .raddr(memory_addr_a),
  .waddr(memory_addr_a),
  .dout_value(dout_a)
);

generate
genvar ind2;
for (ind2=0; ind2&lt;max_n_rw; ind2=ind2+1)
  begin : Lind2
    assign tmp_addr[(ind2+1)*nbit_addr-1:ind2*nbit_addr] = (proxy_sel_LOAD[ind2]||proxy_sel_STORE[ind2]) ? proxy_in2[(ind2+1)*BITSIZE_proxy_in2-1:ind2*BITSIZE_proxy_in2] : in2[(ind2+1)*BITSIZE_in2-1:ind2*BITSIZE_in2];
  end
endgenerate

generate
genvar i3;
  for (i3=0; i3&lt;n_bus_ports; i3=i3+1)
  begin : L3
    if(PRIVATE_MEMORY==0 &amp;&amp; USE_SPARSE_MEMORY==0)
      assign cs[i3] = (S_addr_ram[(i3+1)*BITSIZE_S_addr_ram-1:i3*BITSIZE_S_addr_ram] &gt;= (address_space_begin)) &amp;&amp; (S_addr_ram[(i3+1)*BITSIZE_S_addr_ram-1:i3*BITSIZE_S_addr_ram] &lt; (address_space_begin+address_space_rangesize));
    else if(PRIVATE_MEMORY==0 &amp;&amp; nbits_address_space_rangesize &lt; 32)
      assign cs[i3] = S_addr_ram[(i3+1)*BITSIZE_S_addr_ram-1:i3*BITSIZE_S_addr_ram+nbits_address_space_rangesize] == address_space_begin[((nbit_addr-1) &lt; 32 ? (nbit_addr-1) : 31):nbits_address_space_rangesize];
    else
      assign cs[i3] = 1&apos;b0;
  end
endgenerate

generate
genvar i4;
  for (i4=0; i4&lt;n_bus_ports; i4=i4+1)
  begin : L4
    assign oe_ram_cs[i4] = S_oe_ram[i4] &amp; cs[i4];
  end
endgenerate

generate
genvar i5;
  for (i5=0; i5&lt;n_bus_ports; i5=i5+1)
  begin : L5
    assign we_ram_cs[i5] = S_we_ram[i5] &amp; cs[i5];
  end
endgenerate

generate
genvar i6;
  for (i6=0; i6&lt;max_n_rw; i6=i6+1)
  begin : L6
    if(PRIVATE_MEMORY==0 &amp;&amp; USE_SPARSE_MEMORY==0 &amp;&amp; i6&lt; n_bus_ports)
      assign relative_addr[(i6+1)*nbit_addr-1:i6*nbit_addr] = ((i6 &lt; max_n_writes &amp;&amp; (sel_STORE[i6]==1&apos;b1 || proxy_sel_STORE[i6]==1&apos;b1)) || (i6 &lt; max_n_reads &amp;&amp; (sel_LOAD[i6]==1&apos;b1 || proxy_sel_LOAD[i6]==1&apos;b1))) ? tmp_addr[(i6+1)*BITSIZE_in2-1:i6*BITSIZE_in2]-address_space_begin: S_addr_ram[(i6+1)*BITSIZE_S_addr_ram-1:i6*BITSIZE_S_addr_ram]-address_space_begin;
    else if(PRIVATE_MEMORY==0 &amp;&amp; i6&lt; n_bus_ports)
      assign relative_addr[(i6)*nbit_addr+nbits_address_space_rangesize-1:i6*nbit_addr] = ((i6 &lt; max_n_writes &amp;&amp; (sel_STORE[i6]==1&apos;b1 || proxy_sel_STORE[i6]==1&apos;b1)) || (i6 &lt; max_n_reads &amp;&amp; (sel_LOAD[i6]==1&apos;b1 || proxy_sel_LOAD[i6]==1&apos;b1))) ? tmp_addr[(i6)*BITSIZE_in2+nbits_address_space_rangesize-1:i6*BITSIZE_in2] : S_addr_ram[(i6)*BITSIZE_S_addr_ram+nbits_address_space_rangesize-1:i6*BITSIZE_S_addr_ram];
    else if(USE_SPARSE_MEMORY==1)
      assign relative_addr[(i6)*nbit_addr+nbits_address_space_rangesize-1:i6*nbit_addr] = tmp_addr[(i6)*BITSIZE_in2+nbits_address_space_rangesize-1:i6*BITSIZE_in2];
    else
      assign relative_addr[(i6+1)*nbit_addr-1:i6*nbit_addr] = tmp_addr[(i6+1)*BITSIZE_in2-1:i6*BITSIZE_in2]-address_space_begin;
  end
endgenerate

generate
genvar i7;
  for (i7=0; i7&lt;max_n_rw; i7=i7+1)
  begin : L7_A
    if (n_elements==1)
      assign memory_addr_a[(i7+1)*nbit_read_addr-1:i7*nbit_read_addr] = {nbit_read_addr{1&apos;b0}};
    else
      assign memory_addr_a[(i7+1)*nbit_read_addr-1:i7*nbit_read_addr] = relative_addr[nbit_read_addr+nbits_byte_offset-1+i7*nbit_addr:nbits_byte_offset+i7*nbit_addr];
  end
endgenerate

generate
genvar i13;
  for (i13=0; i13&lt;n_bus_ports; i13=i13+1)
  begin : L13
    if (BITSIZE_S_Wdata_ram &lt; data_size)
      assign S_Wdata_ram_int[data_size*(i13+1)-1:data_size*i13] = {{data_size-BITSIZE_S_Wdata_ram{1&apos;b0}}, S_Wdata_ram[(i13+1)*BITSIZE_S_Wdata_ram-1:BITSIZE_S_Wdata_ram*i13]};
    else
      assign S_Wdata_ram_int[data_size*(i13+1)-1:data_size*i13] = S_Wdata_ram[data_size+BITSIZE_S_Wdata_ram*i13-1:BITSIZE_S_Wdata_ram*i13];
  end
endgenerate

generate
genvar i14;
  for (i14=0; i14&lt;max_n_writes; i14=i14+1)
  begin : L14
    if(PRIVATE_MEMORY==0 &amp;&amp; i14 &lt; n_bus_ports)
      assign din_a[(i14+1)*data_size-1:i14*data_size] = proxy_sel_STORE[i14] ? proxy_in1[(i14+1)*BITSIZE_proxy_in1-1:i14*BITSIZE_proxy_in1] : (sel_STORE[i14] ? in1[(i14+1)*BITSIZE_in1-1:i14*BITSIZE_in1] : S_Wdata_ram_int[data_size*(i14+1)-1:data_size*i14]);
    else
      assign din_a[(i14+1)*data_size-1:i14*data_size] = proxy_sel_STORE[i14] ? proxy_in1[(i14+1)*BITSIZE_proxy_in1-1:i14*BITSIZE_proxy_in1] : in1[(i14+1)*BITSIZE_in1-1:i14*BITSIZE_in1];
  end
endgenerate

assign out1 = dout_a;
assign proxy_out1 = dout_a;

generate
genvar i16;
  for (i16=0; i16&lt;n_bus_ports; i16=i16+1)
  begin : L16
    always @(posedge clock 1RESET_EDGE)
    begin
      if(1RESET_VALUE)
        begin
          oe_ram_cs_delayed[i16] &lt;= 1&apos;b0;
          if(HIGH_LATENCY!=0) oe_ram_cs_delayed_registered[i16] &lt;= 1&apos;b0;
          if(HIGH_LATENCY == 2) oe_ram_cs_delayed_registered1[i16] &lt;= 1&apos;b0;
        end
      else
        begin
          if(HIGH_LATENCY==0)
            oe_ram_cs_delayed[i16] &lt;= oe_ram_cs[i16] &amp; (!oe_ram_cs_delayed[i16] | BUS_PIPELINED);
          else if(HIGH_LATENCY==1)
          begin
            oe_ram_cs_delayed_registered[i16] &lt;= oe_ram_cs[i16] &amp; ((!oe_ram_cs_delayed_registered[i16] &amp; !oe_ram_cs_delayed[i16]) | BUS_PIPELINED);
            oe_ram_cs_delayed[i16] &lt;= oe_ram_cs_delayed_registered[i16];
          end
          else
          begin
            oe_ram_cs_delayed_registered1[i16] &lt;= oe_ram_cs[i16] &amp; ((!oe_ram_cs_delayed_registered1[i16] &amp; !oe_ram_cs_delayed_registered[i16]) | BUS_PIPELINED);
            oe_ram_cs_delayed_registered[i16] &lt;= oe_ram_cs_delayed_registered1[i16];
            oe_ram_cs_delayed[i16] &lt;= oe_ram_cs_delayed_registered[i16];
          end
        end
    end
  end
endgenerate

generate
genvar i17;
  for (i17=0; i17&lt;n_bus_ports; i17=i17+1)
  begin : L17
    always @(posedge clock 1RESET_EDGE)
    begin
      if(1RESET_VALUE)
        we_ram_cs_delayed[i17] &lt;= 1&apos;b0;
      else
        we_ram_cs_delayed[i17] &lt;= we_ram_cs[i17] &amp; !we_ram_cs_delayed[i17];
    end
  end
endgenerate

generate
genvar i18;
  for (i18=0; i18&lt;n_bus_ports; i18=i18+1)
  begin : L18
    if(PRIVATE_MEMORY==1)
      assign Sout_Rdata_ram[(i18+1)*BITSIZE_Sout_Rdata_ram-1:i18*BITSIZE_Sout_Rdata_ram] = Sin_Rdata_ram[(i18+1)*BITSIZE_Sin_Rdata_ram-1:i18*BITSIZE_Sin_Rdata_ram];
    else if (BITSIZE_Sout_Rdata_ram &lt;= data_size)
      assign Sout_Rdata_ram[(i18+1)*BITSIZE_Sout_Rdata_ram-1:i18*BITSIZE_Sout_Rdata_ram] = oe_ram_cs_delayed[i18] ? dout_a[BITSIZE_Sout_Rdata_ram+i18*data_size-1:i18*data_size] : Sin_Rdata_ram[(i18+1)*BITSIZE_Sin_Rdata_ram-1:i18*BITSIZE_Sin_Rdata_ram];
    else
      assign Sout_Rdata_ram[(i18+1)*BITSIZE_Sout_Rdata_ram-1:i18*BITSIZE_Sout_Rdata_ram] = oe_ram_cs_delayed[i18] ? {{BITSIZE_S_Wdata_ram-data_size{1&apos;b0}}, dout_a[(i18+1)*data_size-1:i18*data_size]} : Sin_Rdata_ram[(i18+1)*BITSIZE_Sin_Rdata_ram-1:i18*BITSIZE_Sin_Rdata_ram];
  end
endgenerate

generate
genvar i19;
  for (i19=0; i19&lt;n_bus_ports; i19=i19+1)
  begin : L19
    if(PRIVATE_MEMORY==0)
      assign Sout_DataRdy[i19] = (i19 &lt; n_bus_ports &amp;&amp; oe_ram_cs_delayed[i19]) | Sin_DataRdy[i19] | (i19 &lt; n_bus_ports &amp;&amp; we_ram_cs_delayed[i19]);
    else
      assign Sout_DataRdy[i19] = Sin_DataRdy[i19];
  end
endgenerate

generate
genvar i21;
  for (i21=0; i21&lt;max_n_writes; i21=i21+1)
  begin : L21
    if(i21 &lt; n_bus_ports)
      assign bram_write[i21] = (sel_STORE[i21] || proxy_sel_STORE[i21] || we_ram_cs[i21]);
    else
      assign bram_write[i21] = (sel_STORE[i21] || proxy_sel_STORE[i21]);
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
  </library>
  <library>
    <name>STD_FU</name>
    <cell>
      <name>BMEMORY_CTRL</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="2"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_11,MEM_ACC_N1</channels_type>
      <memory_ctrl_type>D00</memory_ctrl_type>
      <bram_load_latency>2</bram_load_latency>
      <component_timing_alias>ARRAY_1D_STD_BRAM</component_timing_alias>
      <circuit>
        <component_o id="BMEMORY_CTRL">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BMEMORY_CTRL"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> address </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data size </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="BMEMORY_CTRL in1 in2 in3 out1 Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size" VERILOG_PROVIDED="
wire  [BITSIZE_in2-1:0] tmp_addr;
wire int_sel_LOAD;
wire int_sel_STORE;
assign tmp_addr = in2;
assign Mout_addr_ram = (int_sel_LOAD || int_sel_STORE) ? tmp_addr : Min_addr_ram;
assign Mout_oe_ram = int_sel_LOAD ? 1&apos;b1 : Min_oe_ram;
assign Mout_we_ram = int_sel_STORE ? 1&apos;b1 : Min_we_ram;
assign out1 = M_Rdata_ram[BITSIZE_out1-1:0];
assign Mout_Wdata_ram = int_sel_STORE ? in1 : Min_Wdata_ram;
assign Mout_data_ram_size = int_sel_STORE || int_sel_LOAD ? in3[BITSIZE_in3-1:0] : Min_data_ram_size;
assign int_sel_LOAD = sel_LOAD &amp; in4;
assign int_sel_STORE = sel_STORE &amp; in4;
// Add assertion here
// psl default clock = (posedge clock);
// psl ERROR_LOAD_Min_oe_ram: assert never {sel_LOAD &amp;&amp; Min_oe_ram};
// psl ERROR_STORE_Min_we_ram: assert never {sel_STORE &amp;&amp; Min_we_ram};
// psl ERROR_STORE_LOAD: assert never {sel_STORE &amp;&amp; sel_LOAD};"
            VHDL_PROVIDED="
  signal tmp_addr : std_logic_vector(BITSIZE_in2-1 downto 0);
  signal int_sel_LOAD : std_logic;
  signal int_sel_STORE : std_logic;

begin
  tmp_addr &lt;= in2;
  Mout_addr_ram &lt;=  tmp_addr when ((int_sel_LOAD or int_sel_STORE) = &apos;1&apos;) else Min_addr_ram;
  Mout_oe_ram  &lt;= &apos;1&apos; when (int_sel_LOAD = &apos;1&apos;) else  Min_oe_ram;
  Mout_we_ram  &lt;= &apos;1&apos; when (int_sel_STORE = &apos;1&apos;) else  Min_we_ram;
  out1  &lt;= M_Rdata_ram(BITSIZE_out1-1 downto 0);
  Mout_Wdata_ram  &lt;= std_logic_vector(resize(unsigned(in1), BITSIZE_Mout_Wdata_ram)) when (int_sel_STORE = &apos;1&apos;) else Min_Wdata_ram;
  Mout_data_ram_size &lt;= in3(BITSIZE_in3-1 downto 0) when ((int_sel_STORE or int_sel_LOAD) = &apos;1&apos;) else Min_data_ram_size;
  int_sel_LOAD &lt;= sel_LOAD and in4;
  int_sel_STORE &lt;= sel_STORE and in4;
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BMEMORY_CTRL_3</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="3"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_11,MEM_ACC_N1</channels_type>
      <memory_ctrl_type>D00</memory_ctrl_type>
      <bram_load_latency>3</bram_load_latency>
      <component_timing_alias>ARRAY_1D_STD_BRAM_3</component_timing_alias>
      <circuit>
        <component_o id="BMEMORY_CTRL_3">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BMEMORY_CTRL_3"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> address </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data size </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="BMEMORY_CTRL_3 in1 in2 in3 out1 Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size" IP_COMPONENT="BMEMORY_CTRL" VERILOG_PROVIDED="BMEMORY_CTRL #(.BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_Min_addr_ram(BITSIZE_Min_addr_ram),
  .BITSIZE_Mout_addr_ram(BITSIZE_Mout_addr_ram),
  .BITSIZE_M_Rdata_ram(BITSIZE_M_Rdata_ram),
  .BITSIZE_Min_Wdata_ram(BITSIZE_Min_Wdata_ram),
  .BITSIZE_Mout_Wdata_ram(BITSIZE_Mout_Wdata_ram),
  .BITSIZE_Min_data_ram_size(BITSIZE_Min_data_ram_size),
  .BITSIZE_Mout_data_ram_size(BITSIZE_Mout_data_ram_size)) BMEMORY_CTRL_i (.out1(out1),
  .Mout_oe_ram(Mout_oe_ram),
  .Mout_we_ram(Mout_we_ram),
  .Mout_addr_ram(Mout_addr_ram),
  .Mout_Wdata_ram(Mout_Wdata_ram),
  .Mout_data_ram_size(Mout_data_ram_size),
  .clock(clock),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .in4(in4),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .Min_oe_ram(Min_oe_ram),
  .Min_we_ram(Min_we_ram),
  .Min_addr_ram(Min_addr_ram),
  .M_Rdata_ram(M_Rdata_ram),
  .Min_Wdata_ram(Min_Wdata_ram),
  .Min_data_ram_size(Min_data_ram_size),
  .M_DataRdy(M_DataRdy));" VHDL_PROVIDED="
begin
  BMEMORY_CTRL_i0 : BMEMORY_CTRL generic map(BITSIZE_in1=>BITSIZE_in1, BITSIZE_in2=>BITSIZE_in2, BITSIZE_in3=>BITSIZE_in3, BITSIZE_out1=>BITSIZE_out1, BITSIZE_Min_addr_ram=>BITSIZE_Min_addr_ram, BITSIZE_Mout_addr_ram=>BITSIZE_Mout_addr_ram, BITSIZE_M_Rdata_ram=>BITSIZE_M_Rdata_ram, BITSIZE_Min_Wdata_ram=>BITSIZE_Min_Wdata_ram, BITSIZE_Mout_Wdata_ram=>BITSIZE_Mout_Wdata_ram, BITSIZE_Min_data_ram_size=>BITSIZE_Min_data_ram_size, BITSIZE_Mout_data_ram_size=>BITSIZE_Mout_data_ram_size) port map (out1 => out1, Mout_oe_ram => Mout_oe_ram, Mout_we_ram => Mout_we_ram, Mout_addr_ram => Mout_addr_ram, Mout_Wdata_ram => Mout_Wdata_ram, Mout_data_ram_size => Mout_data_ram_size, clock => clock, in1 => in1, in2 => in2, in3 => in3, in4 => in4, sel_LOAD => sel_LOAD, sel_STORE => sel_STORE, Min_oe_ram => Min_oe_ram, Min_we_ram => Min_we_ram, Min_addr_ram => Min_addr_ram, M_Rdata_ram => M_Rdata_ram, Min_Wdata_ram => Min_Wdata_ram, Min_data_ram_size => Min_data_ram_size, M_DataRdy => M_DataRdy);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BMEMORY_CTRL_4</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="4"/>
      <operation operation_name="STORE" initiation_time="1" cycles="2"/>
      <channels_type>MEM_ACC_11,MEM_ACC_N1</channels_type>
      <memory_ctrl_type>D00</memory_ctrl_type>
      <bram_load_latency>4</bram_load_latency>
      <component_timing_alias>ARRAY_1D_STD_BRAM_4</component_timing_alias>
      <circuit>
        <component_o id="BMEMORY_CTRL_4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BMEMORY_CTRL_4"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_o>
          <port_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> address </port_o>
          <port_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data size </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="BMEMORY_CTRL_4 in1 in2 in3 out1 Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size" IP_COMPONENT="BMEMORY_CTRL" VERILOG_PROVIDED="BMEMORY_CTRL #(.BITSIZE_in1(BITSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .BITSIZE_out1(BITSIZE_out1),
  .BITSIZE_Min_addr_ram(BITSIZE_Min_addr_ram),
  .BITSIZE_Mout_addr_ram(BITSIZE_Mout_addr_ram),
  .BITSIZE_M_Rdata_ram(BITSIZE_M_Rdata_ram),
  .BITSIZE_Min_Wdata_ram(BITSIZE_Min_Wdata_ram),
  .BITSIZE_Mout_Wdata_ram(BITSIZE_Mout_Wdata_ram),
  .BITSIZE_Min_data_ram_size(BITSIZE_Min_data_ram_size),
  .BITSIZE_Mout_data_ram_size(BITSIZE_Mout_data_ram_size)) BMEMORY_CTRL_i (.out1(out1),
  .Mout_oe_ram(Mout_oe_ram),
  .Mout_we_ram(Mout_we_ram),
  .Mout_addr_ram(Mout_addr_ram),
  .Mout_Wdata_ram(Mout_Wdata_ram),
  .Mout_data_ram_size(Mout_data_ram_size),
  .clock(clock),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .in4(in4),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .Min_oe_ram(Min_oe_ram),
  .Min_we_ram(Min_we_ram),
  .Min_addr_ram(Min_addr_ram),
  .M_Rdata_ram(M_Rdata_ram),
  .Min_Wdata_ram(Min_Wdata_ram),
  .Min_data_ram_size(Min_data_ram_size),
  .M_DataRdy(M_DataRdy));" VHDL_PROVIDED="
begin
  BMEMORY_CTRL_i0 : BMEMORY_CTRL generic map(BITSIZE_in1=>BITSIZE_in1, BITSIZE_in2=>BITSIZE_in2, BITSIZE_in3=>BITSIZE_in3, BITSIZE_out1=>BITSIZE_out1, BITSIZE_Min_addr_ram=>BITSIZE_Min_addr_ram, BITSIZE_Mout_addr_ram=>BITSIZE_Mout_addr_ram, BITSIZE_M_Rdata_ram=>BITSIZE_M_Rdata_ram, BITSIZE_Min_Wdata_ram=>BITSIZE_Min_Wdata_ram, BITSIZE_Mout_Wdata_ram=>BITSIZE_Mout_Wdata_ram, BITSIZE_Min_data_ram_size=>BITSIZE_Min_data_ram_size, BITSIZE_Mout_data_ram_size=>BITSIZE_Mout_data_ram_size) port map (out1 => out1, Mout_oe_ram => Mout_oe_ram, Mout_we_ram => Mout_we_ram, Mout_addr_ram => Mout_addr_ram, Mout_Wdata_ram => Mout_Wdata_ram, Mout_data_ram_size => Mout_data_ram_size, clock => clock, in1 => in1, in2 => in2, in3 => in3, in4 => in4, sel_LOAD => sel_LOAD, sel_STORE => sel_STORE, Min_oe_ram => Min_oe_ram, Min_we_ram => Min_we_ram, Min_addr_ram => Min_addr_ram, M_Rdata_ram => M_Rdata_ram, Min_Wdata_ram => Min_Wdata_ram, Min_data_ram_size => Min_data_ram_size, M_DataRdy => M_DataRdy);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BMEMORY_CTRLN</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="2"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_NN</channels_type>
      <memory_ctrl_type>D00</memory_ctrl_type>
      <bram_load_latency>2</bram_load_latency>
      <component_timing_alias>ARRAY_1D_STD_BRAM_NN</component_timing_alias>
      <circuit>
        <component_o id="BMEMORY_CTRLN">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BMEMORY_CTRLN"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> address </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data size </port_vector_o>
          <port_vector_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BMEMORY_CTRLN in1 in2 in3 in4 sel_LOAD sel_STORE out1 Min_oe_ram Min_we_ram Mout_oe_ram Mout_we_ram M_DataRdy Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size" VERILOG_PROVIDED="
parameter max_n_writes = PORTSIZE_sel_STORE &gt; PORTSIZE_Mout_we_ram ? PORTSIZE_sel_STORE : PORTSIZE_Mout_we_ram;
parameter max_n_reads = PORTSIZE_sel_LOAD &gt; PORTSIZE_Mout_oe_ram ? PORTSIZE_sel_STORE : PORTSIZE_Mout_oe_ram;
parameter max_n_rw = max_n_writes &gt; max_n_reads ? max_n_writes : max_n_reads;
wire  [(PORTSIZE_in2*BITSIZE_in2)-1:0] tmp_addr;
wire [PORTSIZE_sel_LOAD-1:0] int_sel_LOAD;
wire [PORTSIZE_sel_STORE-1:0] int_sel_STORE;
assign int_sel_LOAD = sel_LOAD &amp; in4;
assign int_sel_STORE = sel_STORE &amp; in4;
assign tmp_addr = in2;
generate
genvar i;
  for (i=0; i&lt;max_n_rw; i=i+1)
  begin : L0
    assign Mout_addr_ram[(i+1)*BITSIZE_Mout_addr_ram-1:i*BITSIZE_Mout_addr_ram] = ((i &lt; PORTSIZE_sel_LOAD &amp;&amp; int_sel_LOAD[i]) || (i &lt; PORTSIZE_sel_STORE &amp;&amp; int_sel_STORE[i])) ? (tmp_addr[(i+1)*BITSIZE_in2-1:i*BITSIZE_in2]) : Min_addr_ram[(i+1)*BITSIZE_Min_addr_ram-1:i*BITSIZE_Min_addr_ram];
  end
  endgenerate
assign Mout_oe_ram = int_sel_LOAD | Min_oe_ram;
assign Mout_we_ram = int_sel_STORE | Min_we_ram;
generate
  for (i=0; i&lt;max_n_reads; i=i+1)
  begin : L1
    assign out1[(i+1)*BITSIZE_out1-1:i*BITSIZE_out1] = M_Rdata_ram[i*BITSIZE_M_Rdata_ram+BITSIZE_out1-1:i*BITSIZE_M_Rdata_ram];
end
endgenerate
generate
  for (i=0; i&lt;max_n_rw; i=i+1)
  begin : L2
    assign Mout_Wdata_ram[(i+1)*BITSIZE_Mout_Wdata_ram-1:i*BITSIZE_Mout_Wdata_ram] = int_sel_STORE[i] ? in1[(i+1)*BITSIZE_in1-1:i*BITSIZE_in1] : Min_Wdata_ram[(i+1)*BITSIZE_Min_Wdata_ram-1:i*BITSIZE_Min_Wdata_ram];
end
endgenerate
generate
  for (i=0; i&lt;max_n_rw; i=i+1)
  begin : L3
    assign Mout_data_ram_size[(i+1)*BITSIZE_Mout_data_ram_size-1:i*BITSIZE_Mout_data_ram_size] = ((i &lt; PORTSIZE_sel_LOAD &amp;&amp; int_sel_LOAD[i]) || (i &lt; PORTSIZE_sel_STORE &amp;&amp; int_sel_STORE[i])) ? (in3[(i+1)*BITSIZE_in3-1:i*BITSIZE_in3]) : Min_data_ram_size[(i+1)*BITSIZE_Min_data_ram_size-1:i*BITSIZE_Min_data_ram_size];
  end
  endgenerate
" VHDL_PROVIDED="  function integer_ternary_operator(cond : boolean; op1 : integer; op2 : integer) return integer is
  begin
    if cond then
      return op1;
    else
      return op2;
    end if;
  end integer_ternary_operator;

  constant max_n_writes : integer := integer_ternary_operator(PORTSIZE_sel_STORE &gt; PORTSIZE_Mout_we_ram, PORTSIZE_sel_STORE, PORTSIZE_Mout_we_ram);
  constant max_n_reads  : integer := integer_ternary_operator(PORTSIZE_sel_LOAD &gt; PORTSIZE_Mout_oe_ram, PORTSIZE_sel_STORE, PORTSIZE_Mout_oe_ram);
  constant max_n_rw     : integer := integer_ternary_operator(max_n_writes &gt; max_n_reads, max_n_writes, max_n_reads);

  signal tmp_addr : std_logic_vector((PORTSIZE_in2*BITSIZE_in2)-1 downto 0);
  signal int_sel_LOAD : std_logic_vector(PORTSIZE_sel_LOAD-1 downto 0);
  signal int_sel_STORE : std_logic_vector(PORTSIZE_sel_STORE-1 downto 0);

begin
  tmp_addr &lt;= in2;
  int_sel_LOAD &lt;= sel_LOAD and in4;
  int_sel_STORE &lt;= sel_STORE and in4;

  L0 : process(tmp_addr, Min_addr_ram, int_sel_LOAD, int_sel_STORE)
  begin
    for i in 0 to max_n_rw-1 loop
      if((i &lt; PORTSIZE_sel_LOAD and int_sel_LOAD(i)=&apos;1&apos;) or (i &lt; PORTSIZE_sel_STORE and int_sel_STORE(i)=&apos;1&apos;)) then
        Mout_addr_ram((i+1)*BITSIZE_Mout_addr_ram-1 downto i*BITSIZE_Mout_addr_ram) &lt;= tmp_addr((i+1)*BITSIZE_in2-1 downto i*BITSIZE_in2);
      else
        Mout_addr_ram((i+1)*BITSIZE_Mout_addr_ram-1 downto i*BITSIZE_Mout_addr_ram) &lt;= Min_addr_ram((i+1)*BITSIZE_Min_addr_ram-1 downto i*BITSIZE_Min_addr_ram);
      end if;
    end loop;
  end process;

  Mout_oe_ram &lt;= int_sel_LOAD or Min_oe_ram;
  Mout_we_ram &lt;= int_sel_STORE or Min_we_ram;

  L1 : process(M_Rdata_ram)
  begin
    for i in 0 to max_n_reads-1 loop
       out1((i+1)*BITSIZE_out1-1 downto i*BITSIZE_out1) &lt;= M_Rdata_ram(i*BITSIZE_M_Rdata_ram+BITSIZE_out1-1 downto i*BITSIZE_M_Rdata_ram);
    end loop;
  end process;

  L2 : process(int_sel_STORE, in1,Min_Wdata_ram)
  begin
     for i in 0 to max_n_rw-1 loop
       if(int_sel_STORE(i)=&apos;1&apos;) then
         Mout_Wdata_ram((i+1)*BITSIZE_Mout_Wdata_ram-1 downto i*BITSIZE_Mout_Wdata_ram) &lt;= std_logic_vector(resize(unsigned(in1((i+1)*BITSIZE_in1-1 downto i*BITSIZE_in1)), BITSIZE_Mout_Wdata_ram));
       else
         Mout_Wdata_ram((i+1)*BITSIZE_Mout_Wdata_ram-1 downto i*BITSIZE_Mout_Wdata_ram) &lt;= std_logic_vector(resize(unsigned(Min_Wdata_ram((i+1)*BITSIZE_Min_Wdata_ram-1 downto i*BITSIZE_Min_Wdata_ram)), BITSIZE_Mout_Wdata_ram));
       end if;
     end loop;
  end process;

  L3 : process(int_sel_LOAD, int_sel_STORE, in3, Min_data_ram_size)
  begin
    for i in 0 to max_n_rw-1 loop
      if((i &lt; PORTSIZE_sel_LOAD and int_sel_LOAD(i)=&apos;1&apos;) or (i &lt; PORTSIZE_sel_STORE and int_sel_STORE(i)=&apos;1&apos;)) then
        Mout_data_ram_size((i+1)*BITSIZE_Mout_data_ram_size-1 downto i*BITSIZE_Mout_data_ram_size) &lt;= in3((i+1)*BITSIZE_in3-1 downto i*BITSIZE_in3);
      else
        Mout_data_ram_size((i+1)*BITSIZE_Mout_data_ram_size-1 downto i*BITSIZE_Mout_data_ram_size) &lt;= Min_data_ram_size((i+1)*BITSIZE_Min_data_ram_size-1 downto i*BITSIZE_Min_data_ram_size);
      end if;
    end loop;
  end process;
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BMEMORY_CTRLN_3</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="3"/>
      <operation operation_name="STORE"/>
      <channels_type>MEM_ACC_NN</channels_type>
      <memory_ctrl_type>D00</memory_ctrl_type>
      <bram_load_latency>3</bram_load_latency>
      <component_timing_alias>ARRAY_1D_STD_BRAM_NN_3</component_timing_alias>
      <circuit>
        <component_o id="BMEMORY_CTRLN_3">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BMEMORY_CTRLN_3"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> address </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data size </port_vector_o>
          <port_vector_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BMEMORY_CTRLN_3 in1 in2 in3 in4 sel_LOAD sel_STORE out1 Min_oe_ram Min_we_ram Mout_oe_ram Mout_we_ram M_DataRdy Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size" IP_COMPONENT="BMEMORY_CTRLN" VERILOG_PROVIDED="BMEMORY_CTRLN #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_in4(BITSIZE_in4),
  .PORTSIZE_in4(PORTSIZE_in4),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_Min_oe_ram(BITSIZE_Min_oe_ram),
  .PORTSIZE_Min_oe_ram(PORTSIZE_Min_oe_ram),
  .BITSIZE_Min_we_ram(BITSIZE_Min_we_ram),
  .PORTSIZE_Min_we_ram(PORTSIZE_Min_we_ram),
  .BITSIZE_Mout_oe_ram(BITSIZE_Mout_oe_ram),
  .PORTSIZE_Mout_oe_ram(PORTSIZE_Mout_oe_ram),
  .BITSIZE_Mout_we_ram(BITSIZE_Mout_we_ram),
  .PORTSIZE_Mout_we_ram(PORTSIZE_Mout_we_ram),
  .BITSIZE_M_DataRdy(BITSIZE_M_DataRdy),
  .PORTSIZE_M_DataRdy(PORTSIZE_M_DataRdy),
  .BITSIZE_Min_addr_ram(BITSIZE_Min_addr_ram),
  .PORTSIZE_Min_addr_ram(PORTSIZE_Min_addr_ram),
  .BITSIZE_Mout_addr_ram(BITSIZE_Mout_addr_ram),
  .PORTSIZE_Mout_addr_ram(PORTSIZE_Mout_addr_ram),
  .BITSIZE_M_Rdata_ram(BITSIZE_M_Rdata_ram),
  .PORTSIZE_M_Rdata_ram(PORTSIZE_M_Rdata_ram),
  .BITSIZE_Min_Wdata_ram(BITSIZE_Min_Wdata_ram),
  .PORTSIZE_Min_Wdata_ram(PORTSIZE_Min_Wdata_ram),
  .BITSIZE_Mout_Wdata_ram(BITSIZE_Mout_Wdata_ram),
  .PORTSIZE_Mout_Wdata_ram(PORTSIZE_Mout_Wdata_ram),
  .BITSIZE_Min_data_ram_size(BITSIZE_Min_data_ram_size),
  .PORTSIZE_Min_data_ram_size(PORTSIZE_Min_data_ram_size),
  .BITSIZE_Mout_data_ram_size(BITSIZE_Mout_data_ram_size),
  .PORTSIZE_Mout_data_ram_size(PORTSIZE_Mout_data_ram_size)) BMEMORY_CTRLN_i0 (.out1(out1),
  .Mout_oe_ram(Mout_oe_ram),
  .Mout_we_ram(Mout_we_ram),
  .Mout_addr_ram(Mout_addr_ram),
  .Mout_Wdata_ram(Mout_Wdata_ram),
  .Mout_data_ram_size(Mout_data_ram_size),
  .clock(clock),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .in4(in4),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .Min_oe_ram(Min_oe_ram),
  .Min_we_ram(Min_we_ram),
  .Min_addr_ram(Min_addr_ram),
  .M_Rdata_ram(M_Rdata_ram),
  .Min_Wdata_ram(Min_Wdata_ram),
  .Min_data_ram_size(Min_data_ram_size),
  .M_DataRdy(M_DataRdy));" VHDL_PROVIDED="
begin
  BMEMORY_CTRLN_i0 : BMEMORY_CTRLN generic map(BITSIZE_in1=>BITSIZE_in1, PORTSIZE_in1=>PORTSIZE_in1, BITSIZE_in2=>BITSIZE_in2, PORTSIZE_in2=>PORTSIZE_in2, BITSIZE_in3=>BITSIZE_in3, PORTSIZE_in3=>PORTSIZE_in3, BITSIZE_in4=>BITSIZE_in4, PORTSIZE_in4=>PORTSIZE_in4, BITSIZE_sel_LOAD=>BITSIZE_sel_LOAD, PORTSIZE_sel_LOAD=>PORTSIZE_sel_LOAD, BITSIZE_sel_STORE=>BITSIZE_sel_STORE, PORTSIZE_sel_STORE=>PORTSIZE_sel_STORE, BITSIZE_out1=>BITSIZE_out1, PORTSIZE_out1=>PORTSIZE_out1, BITSIZE_Min_oe_ram=>BITSIZE_Min_oe_ram, PORTSIZE_Min_oe_ram=>PORTSIZE_Min_oe_ram, BITSIZE_Min_we_ram=>BITSIZE_Min_we_ram, PORTSIZE_Min_we_ram=>PORTSIZE_Min_we_ram, BITSIZE_Mout_oe_ram=>BITSIZE_Mout_oe_ram, PORTSIZE_Mout_oe_ram=>PORTSIZE_Mout_oe_ram, BITSIZE_Mout_we_ram=>BITSIZE_Mout_we_ram, PORTSIZE_Mout_we_ram=>PORTSIZE_Mout_we_ram, BITSIZE_M_DataRdy=>BITSIZE_M_DataRdy, PORTSIZE_M_DataRdy=>PORTSIZE_M_DataRdy, BITSIZE_Min_addr_ram=>BITSIZE_Min_addr_ram, PORTSIZE_Min_addr_ram=>PORTSIZE_Min_addr_ram, BITSIZE_Mout_addr_ram=>BITSIZE_Mout_addr_ram, PORTSIZE_Mout_addr_ram=>PORTSIZE_Mout_addr_ram, BITSIZE_M_Rdata_ram=>BITSIZE_M_Rdata_ram, PORTSIZE_M_Rdata_ram=>PORTSIZE_M_Rdata_ram, BITSIZE_Min_Wdata_ram=>BITSIZE_Min_Wdata_ram, PORTSIZE_Min_Wdata_ram=>PORTSIZE_Min_Wdata_ram, BITSIZE_Mout_Wdata_ram=>BITSIZE_Mout_Wdata_ram, PORTSIZE_Mout_Wdata_ram=>PORTSIZE_Mout_Wdata_ram, BITSIZE_Min_data_ram_size=>BITSIZE_Min_data_ram_size, PORTSIZE_Min_data_ram_size=>PORTSIZE_Min_data_ram_size, BITSIZE_Mout_data_ram_size=>BITSIZE_Mout_data_ram_size, PORTSIZE_Mout_data_ram_size=>PORTSIZE_Mout_data_ram_size) port map (out1 => out1, Mout_oe_ram => Mout_oe_ram, Mout_we_ram => Mout_we_ram, Mout_addr_ram => Mout_addr_ram, Mout_Wdata_ram => Mout_Wdata_ram, Mout_data_ram_size => Mout_data_ram_size, clock => clock, in1 => in1, in2 => in2, in3 => in3, in4 => in4, sel_LOAD => sel_LOAD, sel_STORE => sel_STORE, Min_oe_ram => Min_oe_ram, Min_we_ram => Min_we_ram, Min_addr_ram => Min_addr_ram, M_Rdata_ram => M_Rdata_ram, Min_Wdata_ram => Min_Wdata_ram, Min_data_ram_size => Min_data_ram_size, M_DataRdy => M_DataRdy);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>BMEMORY_CTRLN_4</name>
      <operation operation_name="LOAD" initiation_time="1" cycles="4"/>
      <operation operation_name="STORE" initiation_time="1" cycles="2"/>
      <channels_type>MEM_ACC_NN</channels_type>
      <memory_ctrl_type>D00</memory_ctrl_type>
      <bram_load_latency>4</bram_load_latency>
      <component_timing_alias>ARRAY_1D_STD_BRAM_NN_4</component_timing_alias>
      <circuit>
        <component_o id="BMEMORY_CTRLN_4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="BMEMORY_CTRLN_4"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data to be written </port_vector_o>
          <port_vector_o id="in2" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> address </port_vector_o>
          <port_vector_o id="in3" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> data size </port_vector_o>
          <port_vector_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> predicate </port_vector_o>
          <port_vector_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="BMEMORY_CTRLN_4 in1 in2 in3 in4 sel_LOAD sel_STORE out1 Min_oe_ram Min_we_ram Mout_oe_ram Mout_we_ram M_DataRdy Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size" IP_COMPONENT="BMEMORY_CTRLN" VERILOG_PROVIDED="BMEMORY_CTRLN #(.BITSIZE_in1(BITSIZE_in1),
  .PORTSIZE_in1(PORTSIZE_in1),
  .BITSIZE_in2(BITSIZE_in2),
  .PORTSIZE_in2(PORTSIZE_in2),
  .BITSIZE_in3(BITSIZE_in3),
  .PORTSIZE_in3(PORTSIZE_in3),
  .BITSIZE_in4(BITSIZE_in4),
  .PORTSIZE_in4(PORTSIZE_in4),
  .BITSIZE_sel_LOAD(BITSIZE_sel_LOAD),
  .PORTSIZE_sel_LOAD(PORTSIZE_sel_LOAD),
  .BITSIZE_sel_STORE(BITSIZE_sel_STORE),
  .PORTSIZE_sel_STORE(PORTSIZE_sel_STORE),
  .BITSIZE_out1(BITSIZE_out1),
  .PORTSIZE_out1(PORTSIZE_out1),
  .BITSIZE_Min_oe_ram(BITSIZE_Min_oe_ram),
  .PORTSIZE_Min_oe_ram(PORTSIZE_Min_oe_ram),
  .BITSIZE_Min_we_ram(BITSIZE_Min_we_ram),
  .PORTSIZE_Min_we_ram(PORTSIZE_Min_we_ram),
  .BITSIZE_Mout_oe_ram(BITSIZE_Mout_oe_ram),
  .PORTSIZE_Mout_oe_ram(PORTSIZE_Mout_oe_ram),
  .BITSIZE_Mout_we_ram(BITSIZE_Mout_we_ram),
  .PORTSIZE_Mout_we_ram(PORTSIZE_Mout_we_ram),
  .BITSIZE_M_DataRdy(BITSIZE_M_DataRdy),
  .PORTSIZE_M_DataRdy(PORTSIZE_M_DataRdy),
  .BITSIZE_Min_addr_ram(BITSIZE_Min_addr_ram),
  .PORTSIZE_Min_addr_ram(PORTSIZE_Min_addr_ram),
  .BITSIZE_Mout_addr_ram(BITSIZE_Mout_addr_ram),
  .PORTSIZE_Mout_addr_ram(PORTSIZE_Mout_addr_ram),
  .BITSIZE_M_Rdata_ram(BITSIZE_M_Rdata_ram),
  .PORTSIZE_M_Rdata_ram(PORTSIZE_M_Rdata_ram),
  .BITSIZE_Min_Wdata_ram(BITSIZE_Min_Wdata_ram),
  .PORTSIZE_Min_Wdata_ram(PORTSIZE_Min_Wdata_ram),
  .BITSIZE_Mout_Wdata_ram(BITSIZE_Mout_Wdata_ram),
  .PORTSIZE_Mout_Wdata_ram(PORTSIZE_Mout_Wdata_ram),
  .BITSIZE_Min_data_ram_size(BITSIZE_Min_data_ram_size),
  .PORTSIZE_Min_data_ram_size(PORTSIZE_Min_data_ram_size),
  .BITSIZE_Mout_data_ram_size(BITSIZE_Mout_data_ram_size),
  .PORTSIZE_Mout_data_ram_size(PORTSIZE_Mout_data_ram_size)) BMEMORY_CTRLN_i0 (.out1(out1),
  .Mout_oe_ram(Mout_oe_ram),
  .Mout_we_ram(Mout_we_ram),
  .Mout_addr_ram(Mout_addr_ram),
  .Mout_Wdata_ram(Mout_Wdata_ram),
  .Mout_data_ram_size(Mout_data_ram_size),
  .clock(clock),
  .in1(in1),
  .in2(in2),
  .in3(in3),
  .in4(in4),
  .sel_LOAD(sel_LOAD),
  .sel_STORE(sel_STORE),
  .Min_oe_ram(Min_oe_ram),
  .Min_we_ram(Min_we_ram),
  .Min_addr_ram(Min_addr_ram),
  .M_Rdata_ram(M_Rdata_ram),
  .Min_Wdata_ram(Min_Wdata_ram),
  .Min_data_ram_size(Min_data_ram_size),
  .M_DataRdy(M_DataRdy));" VHDL_PROVIDED="
begin
  BMEMORY_CTRLN_i0 : BMEMORY_CTRLN generic map(BITSIZE_in1=>BITSIZE_in1, PORTSIZE_in1=>PORTSIZE_in1, BITSIZE_in2=>BITSIZE_in2, PORTSIZE_in2=>PORTSIZE_in2, BITSIZE_in3=>BITSIZE_in3, PORTSIZE_in3=>PORTSIZE_in3, BITSIZE_in4=>BITSIZE_in4, PORTSIZE_in4=>PORTSIZE_in4, BITSIZE_sel_LOAD=>BITSIZE_sel_LOAD, PORTSIZE_sel_LOAD=>PORTSIZE_sel_LOAD, BITSIZE_sel_STORE=>BITSIZE_sel_STORE, PORTSIZE_sel_STORE=>PORTSIZE_sel_STORE, BITSIZE_out1=>BITSIZE_out1, PORTSIZE_out1=>PORTSIZE_out1, BITSIZE_Min_oe_ram=>BITSIZE_Min_oe_ram, PORTSIZE_Min_oe_ram=>PORTSIZE_Min_oe_ram, BITSIZE_Min_we_ram=>BITSIZE_Min_we_ram, PORTSIZE_Min_we_ram=>PORTSIZE_Min_we_ram, BITSIZE_Mout_oe_ram=>BITSIZE_Mout_oe_ram, PORTSIZE_Mout_oe_ram=>PORTSIZE_Mout_oe_ram, BITSIZE_Mout_we_ram=>BITSIZE_Mout_we_ram, PORTSIZE_Mout_we_ram=>PORTSIZE_Mout_we_ram, BITSIZE_M_DataRdy=>BITSIZE_M_DataRdy, PORTSIZE_M_DataRdy=>PORTSIZE_M_DataRdy, BITSIZE_Min_addr_ram=>BITSIZE_Min_addr_ram, PORTSIZE_Min_addr_ram=>PORTSIZE_Min_addr_ram, BITSIZE_Mout_addr_ram=>BITSIZE_Mout_addr_ram, PORTSIZE_Mout_addr_ram=>PORTSIZE_Mout_addr_ram, BITSIZE_M_Rdata_ram=>BITSIZE_M_Rdata_ram, PORTSIZE_M_Rdata_ram=>PORTSIZE_M_Rdata_ram, BITSIZE_Min_Wdata_ram=>BITSIZE_Min_Wdata_ram, PORTSIZE_Min_Wdata_ram=>PORTSIZE_Min_Wdata_ram, BITSIZE_Mout_Wdata_ram=>BITSIZE_Mout_Wdata_ram, PORTSIZE_Mout_Wdata_ram=>PORTSIZE_Mout_Wdata_ram, BITSIZE_Min_data_ram_size=>BITSIZE_Min_data_ram_size, PORTSIZE_Min_data_ram_size=>PORTSIZE_Min_data_ram_size, BITSIZE_Mout_data_ram_size=>BITSIZE_Mout_data_ram_size, PORTSIZE_Mout_data_ram_size=>PORTSIZE_Mout_data_ram_size) port map (out1 => out1, Mout_oe_ram => Mout_oe_ram, Mout_we_ram => Mout_we_ram, Mout_addr_ram => Mout_addr_ram, Mout_Wdata_ram => Mout_Wdata_ram, Mout_data_ram_size => Mout_data_ram_size, clock => clock, in1 => in1, in2 => in2, in3 => in3, in4 => in4, sel_LOAD => sel_LOAD, sel_STORE => sel_STORE, Min_oe_ram => Min_oe_ram, Min_we_ram => Min_we_ram, Min_addr_ram => Min_addr_ram, M_Rdata_ram => M_Rdata_ram, Min_Wdata_ram => Min_Wdata_ram, Min_data_ram_size => Min_data_ram_size, M_DataRdy => M_DataRdy);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>__builtin_memstore</name>
      <operation operation_name="__builtin_memstore" bounded="0"/>
      <circuit>
        <component_o id="__builtin_memstore">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="__builtin_memstore"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="addr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="size" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="done_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="__builtin_memstore data addr size Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size" VERILOG_PROVIDED="
parameter [1:0] S_0 = 2&apos;d0,
  S_1 = 2&apos;d1,
  S_2 = 2&apos;d2;
reg [1:0] _present_state=S_0, _next_state;
reg done_port;
reg Mout_oe_ram;
reg Mout_we_ram;
reg [BITSIZE_Mout_addr_ram-1:0] Mout_addr_ram;
reg [BITSIZE_Mout_Wdata_ram-1:0] Mout_Wdata_ram;
reg [BITSIZE_Mout_data_ram_size-1:0] Mout_data_ram_size;
always @(posedge clock 1RESET_EDGE)
  if (1RESET_VALUE)
    _present_state &lt;= S_0;
  else 
    _present_state &lt;= _next_state;

always @(*)
begin
  _next_state=S_0;
  done_port=1&apos;b0;
  Mout_oe_ram=Min_oe_ram;
  Mout_we_ram=Min_we_ram;
  Mout_data_ram_size=Min_data_ram_size;
  Mout_Wdata_ram=Min_Wdata_ram;
  Mout_addr_ram=Min_addr_ram;
  case (_present_state)
    S_0 :
      if(start_port != 1&apos;b1)
      begin
        _next_state=S_0;
      end
      else
      begin
        _next_state=S_1;
        Mout_we_ram=1&apos;b1;
        Mout_addr_ram=addr;
        Mout_Wdata_ram=data;
        Mout_data_ram_size=size;
        if(M_DataRdy)
        begin
          _next_state=S_2;
        end
      end
    S_1 :
    begin
      _next_state=S_1;
      Mout_we_ram=1&apos;b1;
      Mout_addr_ram=addr;
      Mout_Wdata_ram=data;
      Mout_data_ram_size=size;
      if(M_DataRdy)
      begin
        _next_state=S_2;
      end
    end
    S_2 :
    begin
      _next_state=S_0;
      done_port=1&apos;b1;
    end
  endcase
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>__builtin_memstore_N</name>
      <operation operation_name="__builtin_memstore_N" bounded="0"/>
      <circuit>
        <component_o id="__builtin_memstore_N">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="__builtin_memstore_N"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="addr" dir="IN" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="size" dir="IN" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="done_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="__builtin_memstore_N data addr size Min_oe_ram Min_we_ram Mout_oe_ram Mout_we_ram M_DataRdy Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size" VERILOG_PROVIDED="
parameter [1:0] S_0 = 2&apos;d0,
  S_1 = 2&apos;d1,
  S_2 = 2&apos;d2;
reg [1:0] _present_state=S_0, _next_state;
reg done_port;
reg [PORTSIZE_Mout_oe_ram-1:0] Mout_oe_ram;
reg [PORTSIZE_Mout_we_ram-1:0] Mout_we_ram;
reg [(PORTSIZE_Mout_addr_ram*BITSIZE_Mout_addr_ram)+(-1):0] Mout_addr_ram;
reg [(PORTSIZE_Mout_Wdata_ram*BITSIZE_Mout_Wdata_ram)+(-1):0] Mout_Wdata_ram;
reg [(PORTSIZE_Mout_data_ram_size*BITSIZE_Mout_data_ram_size)+(-1):0] Mout_data_ram_size;
always @(posedge clock 1RESET_EDGE)
  if (1RESET_VALUE)
    _present_state &lt;= S_0;
  else 
    _present_state &lt;= _next_state;

always @(*)
begin
  _next_state=S_0;
  done_port=1&apos;b0;
  Mout_oe_ram=Min_oe_ram;
  Mout_we_ram=Min_we_ram;
  Mout_data_ram_size=Min_data_ram_size;
  Mout_Wdata_ram=Min_Wdata_ram;
  Mout_addr_ram=Min_addr_ram;
  case (_present_state)
    S_0 :
      if(start_port != 1&apos;b1)
      begin
        _next_state=S_0;
      end
      else
      begin
        _next_state=S_1;
        Mout_we_ram[0]=1&apos;b1;
        Mout_addr_ram[BITSIZE_Mout_addr_ram-1:0]=addr;
        Mout_Wdata_ram[BITSIZE_Mout_Wdata_ram-1:0]=data;
        Mout_data_ram_size[BITSIZE_Mout_data_ram_size-1:0]=size;
        if(M_DataRdy[0])
        begin
          _next_state=S_2;
        end
      end
    S_1 :
    begin
      _next_state=S_1;
      Mout_we_ram[0]=1&apos;b1;
      Mout_addr_ram[BITSIZE_Mout_addr_ram-1:0]=addr;
      Mout_Wdata_ram[BITSIZE_Mout_Wdata_ram-1:0]=data;
      Mout_data_ram_size[BITSIZE_Mout_data_ram_size-1:0]=size;
      if(M_DataRdy[0])
      begin
        _next_state=S_2;
      end
    end
    S_2 :
    begin
      _next_state=S_0;
      done_port=1&apos;b1;
    end
  endcase
end" VHDL_PROVIDED="
signal present_state : std_logic_vector(1 downto 0) := &quot;00&quot;;
signal next_state : std_logic_vector(1 downto 0);
begin
process(clock,reset)
begin
  if(1RESET_VALUE) then
    present_state &lt;= &quot;00&quot;;
  elsif (clock&apos;event and clock = &apos;1&apos;) then
    present_state &lt;= next_state;
  end if;
end process;
process(present_state, start_port, Min_oe_ram, Min_we_ram, Min_data_ram_size,Min_Wdata_ram,Min_addr_ram, M_DataRdy(0), M_Rdata_ram,data)
begin
  next_state &lt;= &quot;00&quot;;
  done_port &lt;= &apos;0&apos;;
  Mout_oe_ram &lt;= Min_oe_ram;
  Mout_we_ram &lt;=Min_we_ram;
  Mout_data_ram_size &lt;= Min_data_ram_size;
  Mout_Wdata_ram &lt;= Min_Wdata_ram;
  Mout_addr_ram &lt;= Min_addr_ram;
  case present_state is
    when &quot;00&quot; =&gt;
     if(start_port = &apos;0&apos;) then
       next_state &lt;= &quot;00&quot;;
    else
      next_state &lt;= &quot;01&quot;;
      Mout_we_ram(0) &lt;= &apos;1&apos;;
      Mout_addr_ram(BITSIZE_Mout_addr_ram-1 downto 0) &lt;= std_logic_vector(resize(unsigned(addr), BITSIZE_Mout_addr_ram));
      Mout_Wdata_ram(BITSIZE_data-1 downto 0) &lt;= data;
      Mout_data_ram_size(BITSIZE_Mout_data_ram_size-1 downto 0) &lt;= std_logic_vector(resize(unsigned(size), BITSIZE_Mout_data_ram_size));
      if(M_DataRdy(0) = &apos;1&apos;) then
        next_state &lt;= &quot;10&quot;;
      end if;
    end if;
  when &quot;01&quot; =&gt;
    next_state &lt;= &quot;01&quot;;
    Mout_we_ram(0) &lt;= &apos;1&apos;;
    Mout_addr_ram(BITSIZE_Mout_addr_ram-1 downto 0) &lt;= std_logic_vector(resize(unsigned(addr), BITSIZE_Mout_addr_ram));
    Mout_Wdata_ram(BITSIZE_data-1 downto 0) &lt;= data;
    Mout_data_ram_size(BITSIZE_Mout_data_ram_size-1 downto 0) &lt;= std_logic_vector(resize(unsigned(size), BITSIZE_Mout_data_ram_size));
    if(M_DataRdy(0) = &apos;1&apos;) then
       next_state &lt;= &quot;10&quot;;
    end if;
  when &quot;10&quot; =&gt; 
    next_state &lt;= &quot;00&quot;;
     done_port &lt;= &apos;1&apos;;
     when others =&gt;
    end case;
end process;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>_comparator</name>
      <circuit>
        <component_o id="_comparator">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="_comparator"/>
          <port_o id="dataa" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="datab" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="aeb" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="_comparator dataa datab" VERILOG_PROVIDED="assign aeb = (dataa == datab);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>CACHE_DIR</name>
      <circuit>
        <component_o id="CACHE_DIR">
          <description>This component is based on the work available at https://www.eecg.utoronto.ca/~jayar/software/cachegen/cachegen.html and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="CACHE_DIR"/>
          <parameter name="ADDRESSWIDTH"> 32 </parameter>
          <parameter name="DATAWIDTH"> 32 </parameter>
          <parameter name="LOG2DATAWIDTH"> 2 </parameter>
          <parameter name="CACHEDEPTH"> 1024 </parameter>
          <parameter name="LOG2CACHEDEPTH"> 10 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_address" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> Memory address from controller to cache </port_o>
          <port_o id="M_rddata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> Read data from cache to controller </port_o>
          <port_o id="M_wrdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> Write data from controller to cache </port_o>
          <port_o id="M_write" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> Write flag from controller to cache </port_o>
          <port_o id="M_read" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> Read flag from controller to cache </port_o>
          <port_o id="M_wait" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/> Flag indicating that the cache is not done handling the request, from cache to controller </port_o>

          <port_o id="S_address" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> Memory address from cache to memory </port_o>
          <port_o id="S_rddata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> Read data from memory to cache </port_o>
          <port_o id="S_wrdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/> Write data from cache to memory </port_o>
          <port_o id="S_write" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/> Write flag from cache to memory </port_o>
          <port_o id="S_read" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/> Read flag from cache to memory </port_o>
          <port_o id="S_wait" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/> Flag indicating that the memory is not done handling the request, from memory to cache </port_o>
          <NP_functionality LIBRARY="CACHE_DIR ADDRESSWIDTH DATAWIDTH LOG2DATAWIDTH CACHEDEPTH LOG2CACHEDEPTH M_address M_rddata M_wrdata S_address S_rddata S_wrdata" IP_COMPONENT="STD_SP_BRAM,_comparator" VERILOG_PROVIDED="
parameter idle=0,taglookup=1,readdata=3,waitmemread=4,write=6;
//Control Signals
reg tagwrite;
reg datawrite;
reg countup;
reg cachereadswitch,writefrommem;  // mux controls
reg M_wait;
reg S_read;
reg S_write;

//Control inputs
wire cachehit;

reg [3:0] state,nextstate;

wire [DATAWIDTH-1:0] Cache_rddata,Cache_wrdata;
wire [ADDRESSWIDTH-1:LOG2CACHEDEPTH] oldtag;
wire valid,tagsmatch;

assign M_rddata=(cachereadswitch) ? Cache_rddata : S_rddata;
assign S_address=M_address;
assign S_wrdata=M_wrdata;
assign Cache_wrdata = (writefrommem) ? S_rddata : M_wrdata;

  _comparator #(.BITSIZE_dataa(ADDRESSWIDTH-LOG2CACHEDEPTH),
  .BITSIZE_datab(ADDRESSWIDTH-LOG2CACHEDEPTH)) 
            comparator(  
              .dataa(M_address[ADDRESSWIDTH-1:LOG2CACHEDEPTH]),
              .datab(oldtag),
              .aeb(tagsmatch)
            );
  assign cachehit=tagsmatch&amp;valid;

  // Tag and valid bit cache
  STD_SP_BRAM #(
    .BITSIZE_data_out(ADDRESSWIDTH - LOG2CACHEDEPTH + 1),
    .BITSIZE_data_in(ADDRESSWIDTH - LOG2CACHEDEPTH + 1),
    .BITSIZE_address_inr(LOG2CACHEDEPTH),
    .BITSIZE_address_inw(LOG2CACHEDEPTH),
    .MEMORY_INIT_file(&quot;&quot;),
    .n_elements(CACHEDEPTH),
    .READ_ONLY_MEMORY(0),
    .HIGH_LATENCY(0)
	) tagcache (
      .clock (clock),
      .write_enable(tagwrite),
      .address_inr (M_address[LOG2CACHEDEPTH + LOG2DATAWIDTH -1:LOG2DATAWIDTH]),
      .address_inw (M_address[LOG2CACHEDEPTH + LOG2DATAWIDTH -1:LOG2DATAWIDTH]),
      .data_in ({1&apos;b1,M_address[ADDRESSWIDTH-1:LOG2CACHEDEPTH]}),
      .data_out ({valid,oldtag})
    );
  
  //Ram used to store data
  STD_SP_BRAM #(
    .BITSIZE_data_out(DATAWIDTH),
    .BITSIZE_data_in(DATAWIDTH),
    .BITSIZE_address_inr(LOG2CACHEDEPTH),
    .BITSIZE_address_inw(LOG2CACHEDEPTH),
    .MEMORY_INIT_file(&quot;&quot;),
    .n_elements(CACHEDEPTH),
    .READ_ONLY_MEMORY(0),
    .HIGH_LATENCY(0)
  ) data_cache (
    .clock (clock),
    .write_enable(datawrite),
    .address_inr(M_address[LOG2CACHEDEPTH + LOG2DATAWIDTH -1: LOG2DATAWIDTH]),
    .address_inw(M_address[LOG2CACHEDEPTH + LOG2DATAWIDTH -1: LOG2DATAWIDTH]),
    .data_in (Cache_wrdata),
    .data_out (Cache_rddata)
    );

  // ******************* Cache Controller **********************//
  always @(posedge clock)
    state&lt;=nextstate;

  always @(M_read or M_write or state or S_wait or cachehit)
  begin
     tagwrite&lt;=0;
    datawrite&lt;=0;
    cachereadswitch&lt;=0; writefrommem&lt;=0;
    M_wait&lt;=0;
    S_read&lt;=0;
    S_write&lt;=0;
    case(state)
    idle: 
      if (M_read==0 &amp;&amp; M_write==0)
        nextstate&lt;=idle;
      else if (M_read==1 &amp;&amp; M_write==0)
      begin
        M_wait&lt;=1;
        nextstate&lt;=readdata;
      end
      else //is a write request
      begin
        M_wait&lt;=1;
        datawrite&lt;=1;   //write to data cache
        tagwrite&lt;=1;
        S_write&lt;=1;
        nextstate&lt;=write;
      end
    write:
      if (S_wait)
      begin
        S_write&lt;=1;
        M_wait&lt;=1;
        nextstate&lt;=write;
      end
      else
        nextstate&lt;=idle;
    readdata:
      if (cachehit)
      begin
        cachereadswitch&lt;=1;
        nextstate&lt;=idle;
      end
      else
      begin
        M_wait&lt;=1;
        S_read&lt;=1;
        nextstate&lt;=waitmemread;
      end
    waitmemread:
      if (S_wait)
      begin
        S_read&lt;=1;
        M_wait&lt;=1;
        nextstate&lt;=waitmemread;
      end
      else
      begin
        tagwrite&lt;=1;
        datawrite&lt;=1;
        writefrommem&lt;=1;
        nextstate&lt;=idle;
      end
    default:
      nextstate&lt;=idle;
    endcase
  end
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_front_end</name>
      <circuit>
        <component_o id="IOB_front_end">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_front_end"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_BYTE_W"> 2 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_valid_reg" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_addr_reg" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_wdata_reg" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_wstrb_reg" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ctrl_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ctrl_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ctrl_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ctrl_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_front_end FE_ADDR_W CTRL_CACHE CTRL_CNT addr wdata wstrb rdata data_addr data_rdata data_addr_reg data_wdata_reg data_wstrb_reg ctrl_addr ctrl_rdata" VERILOG_PROVIDED="
   `define CTRL_ADDR_W 4
   localparam FE_DATA_W = BITSIZE_wdata;
   localparam FE_NBYTES = BITSIZE_wstrb;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   wire                                         valid_int;
   
   reg                                          valid_reg;
   reg [FE_ADDR_W-1:FE_BYTE_W]                  addr_reg;
   reg [FE_DATA_W-1:0]                          wdata_reg;
   reg [FE_NBYTES-1:0]                          wstrb_reg;

   
   //////////////////////////////////////////////////////////////////////////////////
     //    Cache-selection - cache-memory or cache-control 
   /////////////////////////////////////////////////////////////////////////////////
   generate
      if(CTRL_CACHE) 
        begin

           //Front-end output signals
           assign ready = ctrl_ready | data_ready;
           assign rdata = (ctrl_ready)? ctrl_rdata  : data_rdata;     
           
           assign valid_int  = ~addr[CTRL_CACHE + FE_ADDR_W -1 - FE_BYTE_W] &amp; valid;
           
           assign ctrl_valid =  addr[CTRL_CACHE + FE_ADDR_W -1 - FE_BYTE_W] &amp; valid;       
           assign ctrl_addr  =  addr[FE_BYTE_W - FE_BYTE_W +: `CTRL_ADDR_W];
           
        end // if (CTRL_CACHE)
      else 
        begin
           //Front-end output signals
           assign ready = data_ready; 
           assign rdata = data_rdata;
           
           assign valid_int = valid;
           
           assign ctrl_valid = 1&apos;bx;
           assign ctrl_addr = `CTRL_ADDR_W&apos;dx;
           
        end // else: !if(CTRL_CACHE)
   endgenerate

   //////////////////////////////////////////////////////////////////////////////////
   // Input Data stored signals
   /////////////////////////////////////////////////////////////////////////////////

   always @(posedge clock 1RESET_EDGE)
     begin
        if(1RESET_VALUE)
          begin
             valid_reg &lt;= 0;
             addr_reg  &lt;= 0;
             wdata_reg &lt;= 0;
             wstrb_reg &lt;= 0;
             
          end
        else if(ready) begin
             valid_reg &lt;= 0;
             addr_reg  &lt;= 0;
             wdata_reg &lt;= 0;
             wstrb_reg &lt;= 0;
        end
        else if(valid)
          begin
             valid_reg &lt;= valid_int;
             addr_reg  &lt;= addr[FE_ADDR_W-1 - FE_BYTE_W : 0];
             wdata_reg &lt;= wdata;
             wstrb_reg &lt;= wstrb;
          end
     end

   
   //////////////////////////////////////////////////////////////////////////////////
   // Data-output ports
   /////////////////////////////////////////////////////////////////////////////////
   
   
   assign data_addr  = addr[FE_ADDR_W-1 - FE_BYTE_W : 0];
   assign data_valid = valid_int | valid_reg;
   
   assign data_addr_reg  = addr_reg[FE_ADDR_W-1 : FE_BYTE_W];
   assign data_wdata_reg = wdata_reg;
   assign data_wstrb_reg = wstrb_reg;
   assign data_valid_reg = valid_reg;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_read_channel_axi</name>
      <circuit>
        <component_o id="IOB_read_channel_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_read_channel_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_read_channel_axi FE_ADDR_W FE_DATA_W WORD_OFF_W BE_ADDR_W AXI_ID replace_addr read_addr read_rdata m_axi_arid m_axi_araddr m_axi_arlen m_axi_rid m_axi_rdata" VERILOG_PROVIDED="
   localparam LINE2MEM_W = BITSIZE_read_addr;
   localparam BE_BYTE_W = $clog2(BITSIZE_read_rdata/8);

   reg [BITSIZE_read_addr - 1 : 0] read_addr;
   reg replace;
   
   reg                                           m_axi_arvalid_int;
   reg                                           m_axi_rready_int;

   assign m_axi_arvalid = m_axi_arvalid_int;
   assign m_axi_rready = m_axi_rready_int;
   assign m_axi_arqos = &apos;b0;
           
   generate
      if(LINE2MEM_W &gt; 0)
        begin
           
           //Constant AXI signals
           assign m_axi_arid    = AXI_ID;
           assign m_axi_arlock  = 1&apos;b0;
           assign m_axi_arcache = 4&apos;b0011;
           assign m_axi_arprot  = 3&apos;d0;
           //Burst parameters
           assign m_axi_arlen   = 2**LINE2MEM_W -1; //will choose the burst lenght depending on the cache&apos;s and slave&apos;s data width
           assign m_axi_arsize  = BE_BYTE_W; //each word will be the width of the memory for maximum bandwidth
           assign m_axi_arburst = 2&apos;b01; //incremental burst
           assign m_axi_araddr  = {BE_ADDR_W{1&apos;b0}} + {replace_addr, {(LINE2MEM_W+BE_BYTE_W){1&apos;b0}}}; //base address for the burst, with width extension 

           
           // Read Line values
           assign read_rdata = m_axi_rdata;
           assign read_valid = m_axi_rvalid;
           
           
           localparam
             idle          = 2&apos;d0,
             init_process  = 2&apos;d1,
             load_process  = 2&apos;d2,
             end_process   = 2&apos;d3;
           
           
           reg [1:0]                           state;
           reg                                 slave_error;//axi slave_error during reply (m_axi_rresp[1] == 1) - burst can&apos;t be interrupted, so a flag needs to be active
           
           
           always @(posedge clock 1RESET_EDGE)
             begin
                if(1RESET_VALUE)
                  begin
                     state &lt;= idle;
                     read_addr &lt;= 0;
                     slave_error &lt;= 0;
                  end
                else
                  begin
                     slave_error &lt;= slave_error;
                     case (state)   
                       idle:
                         begin
                            slave_error &lt;= 0;
                            read_addr &lt;= 0;  
                            if(replace_valid)
                              state &lt;= init_process;
                            else
                              state &lt;= idle;
                         end

                       init_process:
                         begin
                            slave_error &lt;= 0;
                            read_addr &lt;= 0;  
                            if(m_axi_arready)
                              state &lt;= load_process;
                            else
                              state &lt;= init_process;
                         end

                       load_process:
                         begin
                            if(m_axi_rvalid)
                              if(m_axi_rlast)
                                begin
                                   state &lt;= end_process;
                                   read_addr &lt;= read_addr; //to avoid writting last data in first line word
                                   if(m_axi_rresp != 2&apos;b00) //slave_error - received at the same time as the valid - needs to wait until the end to start all over - going directly to init_process would cause a stall to this burst
                                     slave_error &lt;= 1;
                                end
                              else
                                begin
                                   read_addr &lt;= read_addr +1;
                                   state &lt;= load_process;
                                   if(m_axi_rresp != 2&apos;b00) //slave_error - received at the same time as the valid - needs to wait until the end to start all over - going directly to init_process would cause a stall to this burst
                                     slave_error &lt;= 1;
                                end
                            else
                              begin
                                 read_addr &lt;= read_addr;
                                 state &lt;= load_process;
                              end
                         end

                       //end_process://delay for the read_latency of the memories (if the rdata is the last word)
                                     default:
                                       if (slave_error)
                                         state &lt;= init_process;
                                       else
                                         state &lt;= idle;
                       
                     endcase
                  end
             end

           always @*
             begin
                m_axi_arvalid_int   = 1&apos;b0;
                m_axi_rready_int    = 1&apos;b0;
                replace = 1&apos;b1;
                case(state)

                  idle:
                    replace = 1&apos;b0;
                  
                  init_process:
                    m_axi_arvalid_int = 1&apos;b1;

                  //load_process:
                  default:
                    m_axi_rready_int  = 1&apos;b1;
                  
                endcase
             end // always @ *
        end // if (LINE2MEM_W &gt; 0)

      
      else
         
        begin
           //Constant AXI signals
           assign m_axi_arid    = AXI_ID;
           assign m_axi_arlock  = 1&apos;b0;
           assign m_axi_arcache = 4&apos;b0011;
           assign m_axi_arprot  = 3&apos;d0;
           //Burst parameters - single 
           assign m_axi_arlen   = 8&apos;d0; //A single burst of Memory data width word
           assign m_axi_arsize  = BE_BYTE_W; //each word will be the width of the memory for maximum bandwidth
           assign m_axi_arburst = 2&apos;b00; 
           assign m_axi_araddr  = {BE_ADDR_W{1&apos;b0}} + {replace_addr, {BE_BYTE_W{1&apos;b0}}}; //base address for the burst, with width extension 

           // Read Line values
           assign read_valid = m_axi_rvalid;
           assign read_rdata  = m_axi_rdata;
           
           
           localparam
             idle          = 2&apos;d0,
             init_process  = 2&apos;d1,
             load_process  = 2&apos;d2,
             end_process   = 2&apos;d3;
           
           
           reg [1:0]                           state;

           
           always @(posedge clock 1RESET_EDGE)
             begin
                if(1RESET_VALUE)
                   
                  state &lt;= idle;
                
                else
                   
                  case (state)   
                    idle:
                      begin
                         if(replace_valid)
                           state &lt;= init_process;
                         else
                           state &lt;= idle;
                      end

                    init_process:
                      begin                      
                         if(m_axi_arready)
                           state &lt;= load_process;
                         else
                           state &lt;= init_process;
                      end

                    load_process:
                      begin
                         if(m_axi_rvalid)
                           if(m_axi_rresp != 2&apos;b00) //slave_error - received at the same time as valid
                             state &lt;= init_process;
                           else
                             state &lt;= end_process;
                         else
                           state &lt;= load_process;
                      end

                    end_process://delay for the read_latency of the memories (if the rdata is the last word)
                      state &lt;= idle;
                    
                    
                    default:;
                  endcase
             end
           
           
           always @*
             begin
                m_axi_arvalid_int   = 1&apos;b0;
                m_axi_rready_int    = 1&apos;b0;
                replace = 1&apos;b1;
                case(state)

                  idle:
                    begin
                       replace = 1&apos;b0;
                    end
                  
                  init_process:
                    begin
                       m_axi_arvalid_int = 1&apos;b1;
                    end

                  load_process:
                    begin
                       m_axi_rready_int  = 1&apos;b1;             
                    end
                  
                  default:;
                  
                endcase
             end // always @ *
           
        end     
   endgenerate 
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_write_channel_axi</name>
      <circuit>
        <component_o id="IOB_write_channel_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_write_channel_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_DATA_W"> 32 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="b_fail" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="b_done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_write_channel_axi FE_ADDR_W FE_DATA_W BE_ADDR_W BE_DATA_W AXI_ID WRITE_POL WORD_OFF_W addr wdata wstrb m_axi_awid m_axi_awaddr m_axi_awlen m_axi_wdata m_axi_wstrb m_axi_bid" VERILOG_PROVIDED="
   //Write Policy
   `define WRITE_THROUGH 0 //write-through not allocate: implements a write-through buffer
   `define WRITE_BACK 1    //write-back allocate: implementes a dirty-memory

   localparam FE_NBYTES = BITSIZE_wstrb;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   localparam BE_NBYTES = BE_DATA_W / 8;
   localparam BE_BYTE_W = $clog2(BE_NBYTES);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);

   reg ready;

   reg                                                                       m_axi_awvalid_int;
   reg                                                                       m_axi_wvalid_int;
   reg                                                                       m_axi_bready_int;

   assign m_axi_awvalid = m_axi_awvalid_int;
   assign m_axi_wvalid = m_axi_wvalid_int;
   assign m_axi_awqos = &apos;b0;

   // Write failed signals
   assign b_fail = m_axi_bvalid &amp;&amp; (m_axi_bresp != 2&apos;b00);
   assign b_done = m_axi_bvalid;
   reg [BITSIZE_addr - 1:0] reg_addr;
   reg [FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)-1 :0]  reg_wdata;

   localparam
     aw_idle     = 2&apos;b00,
     aw_address  = 2&apos;b01,
     aw_wait     = 2&apos;b10;
            
   localparam
     w_idle      = 1&apos;b0,
     w_active    = 1&apos;b1;

   reg [1:0]                               aw_state;
   reg [0:0]                               w_state;         
   
   genvar                                                                       i;
   generate
      if(WRITE_POL == `WRITE_THROUGH) begin

         //Constant AXI signals
         assign m_axi_awid    = AXI_ID;
         assign m_axi_awlen   = 8&apos;d0;
         assign m_axi_awsize  = BE_BYTE_W; // verify - Writes data of the size of BE_DATA_W
         assign m_axi_awburst = 2&apos;d0;
         assign m_axi_awlock  = 1&apos;b0; // 00 - Normal Access
         assign m_axi_awcache = 4&apos;b0011;
         assign m_axi_awprot  = 3&apos;d0;
         assign m_axi_wlast   = m_axi_wvalid_int;
         assign m_axi_bready  = 1&apos;b1;
         //AXI Buffer Output signals
         assign m_axi_awaddr = {BE_ADDR_W{1&apos;b0}} + {addr[FE_ADDR_W-1 - BE_BYTE_W : (BE_BYTE_W - FE_BYTE_W)], {BE_BYTE_W{1&apos;b0}}};
                  
         if(BE_DATA_W == FE_DATA_W)
           begin
              assign m_axi_wstrb = wstrb;
              assign m_axi_wdata = reg_wdata;

           end
         else
           begin
              wire [BE_BYTE_W - FE_BYTE_W -1 :0] word_align = reg_addr[0 +: (BE_BYTE_W - FE_BYTE_W)];
              assign m_axi_wstrb = wstrb &lt;&lt; (word_align * FE_NBYTES);

              for (i = 0; i &lt; BE_DATA_W/FE_DATA_W; i = i +1) begin : wdata_block
                assign m_axi_wdata[(i+1)*FE_DATA_W-1:i*FE_DATA_W] = reg_wdata;
              end
           end
    
           always @(posedge clock 1RESET_EDGE) begin
               if(1RESET_VALUE) begin
                   aw_state &lt;= aw_idle;
                   w_state &lt;= w_idle;
               end else begin
                 case(aw_state) 
                   aw_idle: begin
                       if(valid) begin
                           aw_state &lt;= aw_address;
                       end else
                           aw_state  &lt;= aw_idle;
                   end
                   aw_address: begin
                       if(m_axi_awready &amp;&amp; w_state == w_idle) begin
                           aw_state &lt;= aw_idle;                /* Address written, can write data */
                           w_state &lt;= w_active;
                           reg_addr &lt;= addr;
                           reg_wdata &lt;= wdata;
                       end else if (m_axi_awready)     
                           aw_state &lt;= aw_wait;                /* Address written, but data channel busy */
                       else
                           aw_state &lt;= aw_address;             /* Address not written yet */
                   end
                   aw_wait : begin
                       if(w_state == w_idle) begin
                           aw_state &lt;= aw_idle;
                           w_state &lt;= w_active;
                           reg_addr &lt;= addr;
                           reg_wdata &lt;= wdata;
                       end else
                           aw_state &lt;= aw_wait;
                   end
                   default : begin
                       aw_state &lt;= aw_idle;
                       w_state &lt;= w_idle;
                   end
                 endcase
                 
                 if(w_state == w_active &amp;&amp; m_axi_wready)
                   w_state &lt;= w_idle;
               end  
           end
      end else begin // if (WRITE_POL == `WRITE_BACK)
         if(LINE2MEM_W &gt; 0) begin

            //Constant AXI signals
            assign m_axi_awid    = AXI_ID;
            assign m_axi_awlock  = 1&apos;b0;
            assign m_axi_awcache = 4&apos;b0011;
            assign m_axi_awprot  = 3&apos;d0;

            //Burst parameters
            assign m_axi_awlen   = 2**LINE2MEM_W -1; //will choose the burst lenght depending on the cache&apos;s and slave&apos;s data width
            assign m_axi_awsize  = BE_BYTE_W; //each word will be the width of the memory for maximum bandwidth
            assign m_axi_awburst = 2&apos;b01; //incremental burst

            assign m_axi_bready  = 1&apos;b1;

            //memory address
            assign m_axi_awaddr  = {BE_ADDR_W{1&apos;b0}} + {addr, {(FE_BYTE_W+WORD_OFF_W){1&apos;b0}}}; //base address for the burst, with width extension

            // memory write-data
            reg [LINE2MEM_W-1:0] word_counter = &apos;b0;
            assign m_axi_wdata = reg_wdata >> (word_counter*BE_DATA_W);
            assign m_axi_wstrb = {BE_NBYTES{1&apos;b1}};
            assign m_axi_wlast = &amp;word_counter &amp; m_axi_wvalid;     
           
      
            always @(posedge clock 1RESET_EDGE) begin
                if(1RESET_VALUE) begin
                    aw_state &lt;= aw_idle;
                    w_state &lt;= w_idle;
                end else begin
                  case(aw_state) 
                    aw_idle: begin
                        if(valid) begin
                            aw_state &lt;= aw_address;
                        end else
                            aw_state  &lt;= aw_idle;
                    end
                    aw_address: begin
                        if(m_axi_awready &amp;&amp; w_state == w_idle) begin
                            aw_state &lt;= aw_idle;                /* Address written, can write data */
                            w_state &lt;= w_active;
                            reg_wdata &lt;= wdata;
                        end else if (m_axi_awready)     
                            aw_state &lt;= aw_wait;                /* Address written, but data channel busy */
                        else
                            aw_state &lt;= aw_address;             /* Address not written yet */
                    end
                    aw_wait : begin
                        if(w_state == w_idle) begin
                            aw_state &lt;= aw_idle;
                            w_state &lt;= w_active;
                            reg_wdata &lt;= wdata;
                        end else
                            aw_state &lt;= aw_wait;
                    end
                    default : begin
                        aw_state &lt;= aw_idle;
                        w_state &lt;= w_idle;
                    end
                  endcase
                  
                  if(w_state == w_active) begin
                      if(m_axi_wready &amp;&amp; (&amp;word_counter)) begin
                          w_state &lt;= w_idle;
                          word_counter &lt;= &apos;b0;
                      end else if(m_axi_wready) begin
                          word_counter &lt;= word_counter + 1;
                          w_state &lt;= w_active;
                      end
                  end
                end  
            end
           end // if (LINE2MEM_W > 0)
           else  begin // if (LINE2MEM_W == 0)
              //Constant AXI signals
              assign m_axi_awid    = AXI_ID;
              assign m_axi_awlock  = 1&apos;b0;
              assign m_axi_awcache = 4&apos;b0011;
              assign m_axi_awprot  = 3&apos;d0;
  
              //Burst parameters - single
              assign m_axi_awlen   = 8&apos;d0; //A single burst of Memory data width word
              assign m_axi_awsize  = BE_BYTE_W; //each word will be the width of the memory for maximum bandwidth
              assign m_axi_awburst = 2&apos;b00;
              assign m_axi_bready  = 1&apos;b1;
 
              //memory address
              assign m_axi_awaddr  = {BE_ADDR_W{1&apos;b0}} + {addr, {BE_BYTE_W{1&apos;b0}}}; //base address for the burst, with width extension

              //memory write-data
              assign m_axi_wdata = reg_wdata;
              assign m_axi_wstrb = {BE_NBYTES{1&apos;b1}}; //uses entire bandwidth
              assign m_axi_wlast = m_axi_wvalid;

              always @(posedge clock 1RESET_EDGE) begin
                if(1RESET_VALUE) begin
                  aw_state &lt;= aw_idle;
                  w_state &lt;= w_idle;
                end else begin
                  case(aw_state) 
                    aw_idle: begin
                      if(valid) begin
                        aw_state &lt;= aw_address;
                      end else
                        aw_state  &lt;= aw_idle;
                    end
                    aw_address: begin
                      if(m_axi_awready &amp;&amp; w_state == w_idle) begin
                        aw_state &lt;= aw_idle;                /* Address written, can write data */
                        w_state &lt;= w_active;
                        reg_wdata &lt;= wdata;
                      end else if (m_axi_awready)     
                        aw_state &lt;= aw_wait;                /* Address written, but data channel busy */
                      else
                        aw_state &lt;= aw_address;             /* Address not written yet */
                    end
                    aw_wait : begin
                      if(w_state == w_idle) begin
                        aw_state &lt;= aw_idle;
                        w_state &lt;= w_active;
                        reg_wdata &lt;= wdata;
                      end else
                        aw_state &lt;= aw_wait;
                    end
                    default : begin
                      aw_state &lt;= aw_idle;
                      w_state &lt;= w_idle;
                    end
                  endcase
                  
                  if(w_state == w_active) begin
                    if(m_axi_wready) begin
                      w_state &lt;= w_idle;
                    end
                  end
                end 
              end    
           end // else: !if(LINE2MEM_W &gt; 0)
      end // else: !if(WRITE_POL == `WRITE_THROUGH)
   endgenerate
   
   always @* begin
     m_axi_awvalid_int = 1&apos;b0;
     m_axi_wvalid_int  = 1&apos;b0;
     ready = 1&apos;b0;
     case(aw_state)
       aw_idle:
         ready = 1&apos;b1;
       aw_address:
         m_axi_awvalid_int = 1&apos;b1;
     endcase
     if(w_state == w_active) begin
       m_axi_wvalid_int = 1&apos;b1;
     end
   end
     


   `undef WRITE_THROUGH
   `undef WRITE_BACK
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_back_end_axi</name>
      <circuit>
        <component_o id="IOB_back_end_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_back_end_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_NBYTES"> 4 </parameter>
          <parameter name="BE_BYTE_W"> 32 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_fail" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_back_end_axi FE_ADDR_W FE_DATA_W WORD_OFF_W BE_ADDR_W WRITE_POL AXI_ID write_addr write_wdata write_wstrb replace_addr read_addr read_rdata m_axi_awid m_axi_awaddr m_axi_awlen m_axi_wdata m_axi_wstrb m_axi_bid m_axi_arid m_axi_araddr m_axi_arlen m_axi_rid m_axi_rdata" IP_COMPONENT="IOB_read_channel_axi,IOB_write_channel_axi" VERILOG_PROVIDED="
   localparam FE_NBYTES = FE_DATA_W / 8;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   localparam BE_DATA_W = BITSIZE_read_rdata;
   localparam BE_NBYTES = BE_DATA_W / 8;
   localparam BE_BYTE_W = $clog2(BE_NBYTES);
   localparam AXI_ID_W = BITSIZE_m_axi_awid;
   localparam AXI_ADDR_W = BITSIZE_m_axi_awaddr;
   localparam AXI_DATA_W = BITSIZE_m_axi_wdata;
   localparam AXI_LEN_W = BITSIZE_m_axi_awlen;

   IOB_read_channel_axi
     #(
       .FE_ADDR_W(FE_ADDR_W),
       .FE_DATA_W(FE_DATA_W),  
       .WORD_OFF_W(WORD_OFF_W),
       .BE_ADDR_W (BE_ADDR_W),
       .AXI_ID  (AXI_ID),
       .BITSIZE_replace_addr(FE_ADDR_W - ($clog2(BE_DATA_W/8) + (WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W)))),
       .BITSIZE_read_addr(WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W)),
       .BITSIZE_read_rdata(BE_DATA_W),
       .BITSIZE_m_axi_arid(AXI_ID_W),
       .BITSIZE_m_axi_araddr(AXI_ADDR_W),
       .BITSIZE_m_axi_arlen(AXI_LEN_W),
       .BITSIZE_m_axi_rid(AXI_ID_W),
       .BITSIZE_m_axi_rdata(AXI_DATA_W)
       )
   read_fsm
     (
      .replace_valid (replace_valid),
      .replace_addr (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr (read_addr),
      .read_rdata (read_rdata),
      .m_axi_arid(m_axi_arid), //Address read channel ID
      .m_axi_araddr(m_axi_araddr), //Address read channel address
      .m_axi_arlen(m_axi_arlen), //Address read channel burst length
      .m_axi_arsize(m_axi_arsize), //Address read channel burst size. This signal indicates the size of each transfer in the burst
      .m_axi_arburst(m_axi_arburst), //Address read channel burst type
      .m_axi_arlock(m_axi_arlock), //Address read channel lock type
      .m_axi_arcache(m_axi_arcache), //Address read channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
      .m_axi_arprot(m_axi_arprot), //Address read channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
      .m_axi_arqos(m_axi_arqos), //Address read channel quality of service
      .m_axi_arvalid(m_axi_arvalid), //Address read channel valid
      .m_axi_arready(m_axi_arready), //Address read channel ready
      .m_axi_rid(m_axi_rid), //Read channel ID
      .m_axi_rdata(m_axi_rdata), //Read channel data
      .m_axi_rresp(m_axi_rresp), //Read channel response
      .m_axi_rlast(m_axi_rlast), //Read channel last word
      .m_axi_rvalid(m_axi_rvalid), //Read channel valid
      .m_axi_rready(m_axi_rready), //Read channel ready
      .clock(clock),
      .reset(reset)
      );

   IOB_write_channel_axi
     #(
       .FE_ADDR_W(FE_ADDR_W),
       .FE_DATA_W(FE_DATA_W),
       .BE_ADDR_W (BE_ADDR_W),
       .BE_DATA_W (BE_DATA_W),
       .WRITE_POL (WRITE_POL),
       .WORD_OFF_W(WORD_OFF_W),
       .AXI_ID(AXI_ID),
       .BITSIZE_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_wstrb(FE_NBYTES),
       .BITSIZE_m_axi_awid(AXI_ID_W),
       .BITSIZE_m_axi_awaddr(AXI_ADDR_W),
       .BITSIZE_m_axi_awlen(AXI_LEN_W),
       .BITSIZE_m_axi_wdata(AXI_DATA_W),
       .BITSIZE_m_axi_wstrb(AXI_DATA_W / 8),
       .BITSIZE_m_axi_bid(AXI_ID_W)
       )
   write_fsm
     (
      .valid (write_valid),
      .addr (write_addr),
      .wstrb (write_wstrb),
      .wdata (write_wdata),
      .ready (write_ready),
      .b_fail(write_fail),
      .b_done(write_done),
      /* BEGIN m_axi_write_portmap.vh */
      .m_axi_awid(m_axi_awid), //Address write channel ID
      .m_axi_awaddr(m_axi_awaddr), //Address write channel address
      .m_axi_awlen(m_axi_awlen), //Address write channel burst length
      .m_axi_awsize(m_axi_awsize), //Address write channel burst size. This signal indicates the size of each transfer in the burst
      .m_axi_awburst(m_axi_awburst), //Address write channel burst type
      .m_axi_awlock(m_axi_awlock), //Address write channel lock type
      .m_axi_awcache(m_axi_awcache), //Address write channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
      .m_axi_awprot(m_axi_awprot), //Address write channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
      .m_axi_awqos(m_axi_awqos), //Address write channel quality of service
      .m_axi_awvalid(m_axi_awvalid), //Address write channel valid
      .m_axi_awready(m_axi_awready), //Address write channel ready
      .m_axi_wdata(m_axi_wdata), //Write channel data
      .m_axi_wstrb(m_axi_wstrb), //Write channel write strobe
      .m_axi_wlast(m_axi_wlast), //Write channel last word flag
      .m_axi_wvalid(m_axi_wvalid), //Write channel valid
      .m_axi_wready(m_axi_wready), //Write channel ready
      .m_axi_bid(m_axi_bid), //Write response channel ID
      .m_axi_bresp(m_axi_bresp), //Write response channel response
      .m_axi_bvalid(m_axi_bvalid), //Write response channel valid
      .m_axi_bready(m_axi_bready), //Write response channel ready
      /* END m_axi_write_portmap */
      .clock(clock),
      .reset(reset)
      );
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_ram_2p</name>
      <circuit>
        <component_o id="IOB_ram_2p">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_ram_2p"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="r_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_ram_2p w_addr w_data r_addr r_data" VERILOG_PROVIDED="
   reg [BITSIZE_r_data - 1 : 0] r_data;
   localparam DATA_W = BITSIZE_w_data;
   localparam ADDR_W = BITSIZE_w_addr;

   // Declare the RAM
   reg [DATA_W-1:0]         mem [(2**ADDR_W)-1:0];

   integer index;
   // Initialize the RAM
   initial
   begin
     for(index=0; index&lt;(2**ADDR_W); index=index+1)
     begin
       mem[index] = 0;
     end
   end


   //read port
   always @(posedge clock)
      if(r_en)
        r_data &lt;= mem[r_addr];

   //write port
   always @(posedge clock)
     if(w_en)
       mem[w_addr] &lt;= w_data;
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_ram_2p_asym</name>
      <circuit>
        <component_o id="IOB_ram_2p_asym">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_ram_2p_asym"/>
          <parameter name="W_DATA_W"> 0 </parameter>
          <parameter name="R_DATA_W"> 0 </parameter>
          <parameter name="ADDR_W"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ext_mem_w_en" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_w_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_w_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_r_en" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ext_mem_r_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_r_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="r_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_ram_2p_asym W_DATA_W R_DATA_W ADDR_W ext_mem_w_en ext_mem_w_data ext_mem_w_addr ext_mem_r_addr ext_mem_r_data w_data w_addr r_addr r_data" VERILOG_PROVIDED="
   `define IOB_MAX(a,b) {((a) &gt; (b)) ? (a) : (b)}
   `define IOB_MIN(a,b) {((a) &lt; (b)) ? (a) : (b)}
   
   reg [BITSIZE_r_data - 1 : 0] r_data;

   localparam MAXDATA_W = `IOB_MAX(W_DATA_W, R_DATA_W);
   localparam MINDATA_W = `IOB_MIN(W_DATA_W, R_DATA_W);
   localparam MINADDR_W = ADDR_W-$clog2(MAXDATA_W/MINDATA_W);//lower ADDR_W (higher DATA_W)
   localparam W_ADDR_W = (W_DATA_W == MAXDATA_W) ? MINADDR_W : ADDR_W;
   localparam R_ADDR_W = (R_DATA_W == MAXDATA_W) ? MINADDR_W : ADDR_W;
   //determine the number of blocks N
   localparam N = MAXDATA_W/MINDATA_W;
   
   //symmetric memory block buses
   //write buses
   reg [N-1:0]                en_wr;
   reg [MINDATA_W-1:0]        data_wr [N-1:0];
   reg [MINADDR_W-1:0]        addr_wr [N-1:0];

   //read buses
   wire [MINDATA_W-1:0]       data_rd [N-1:0];
   reg [MINADDR_W-1:0]        addr_rd [N-1:0];

   wire [MINDATA_W-1:0]   data_rd_0 = data_rd[0];

   //connect the buses
   integer j,k,l;
   generate

      if (W_DATA_W &gt; R_DATA_W) begin

         //write parallel
         always @* begin
            for (j=0; j &lt; N; j= j+1) begin
               en_wr[j] = w_en;
               data_wr[j] = w_data[j*MINDATA_W +: MINDATA_W];
               addr_wr[j] = w_addr;
            end
         end

         //read serial
         always @* begin
            for (k=0; k &lt; N; k= k+1) begin
               addr_rd[k] = r_addr[R_ADDR_W-1-:W_ADDR_W];
            end
         end

         //read address register
         reg [(R_ADDR_W-W_ADDR_W)-1:0] r_addr_lsbs_reg;
         always @(posedge clock)
           if (r_en)
             r_addr_lsbs_reg &lt;= r_addr[(R_ADDR_W-W_ADDR_W)-1:0];

         //read mux
         always @* begin
            r_data = 1&apos;b0;
            for (l=0; l &lt; N; l= l+1) begin
               r_data = data_rd[r_addr_lsbs_reg];
            end
         end

      end else  if (W_DATA_W &lt; R_DATA_W) begin
         //write serial
         always @* begin
            for (j=0; j &lt; N; j= j+1) begin
               en_wr[j] = w_en &amp; (w_addr[(W_ADDR_W-R_ADDR_W)-1:0] == j);
               data_wr[j] = w_data;
               addr_wr[j] = w_addr[W_ADDR_W-1 -: R_ADDR_W];
            end
         end
         //read parallel
         always @* begin
            r_data = 1&apos;b0;
            for (k=0; k &lt; N; k= k+1) begin
               addr_rd[k] = r_addr;
               r_data[k*MINDATA_W +: MINDATA_W] = data_rd[k];
            end
         end

      end else begin //W_DATA_W = R_DATA_W
         //write serial
         always @* begin
            en_wr[0] = w_en;
            data_wr[0] = w_data;
            addr_wr[0] = w_addr;
         end
         //read parallel
         always @* begin
            addr_rd[0] = r_addr;
            r_data = data_rd_0;
         end
      end
   endgenerate

   genvar  p;
   generate
      for(p=0; p &lt; N; p= p+1) begin : ext_mem_interface_gen
         assign ext_mem_w_en[p] = en_wr[p];
         assign ext_mem_w_addr[p*MINADDR_W+:MINADDR_W] = addr_wr[p];
         assign ext_mem_w_data[p*MINDATA_W+:MINDATA_W] = data_wr[p];
         assign ext_mem_r_addr[p*MINADDR_W+:MINADDR_W] = addr_rd[p];
         assign data_rd[p] = ext_mem_r_data[p*MINDATA_W+:MINDATA_W];
      end
   endgenerate
   assign ext_mem_r_en = r_en;

   `undef IOB_MAX
   `undef IOB_MIN
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_fifo_sync</name>
      <circuit>
        <component_o id="IOB_fifo_sync">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_fifo_sync"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ext_mem_w_en" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_w_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_w_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_r_en" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ext_mem_r_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_r_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_empty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="dirty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_fail" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_full" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="level" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_fifo_sync ext_mem_w_en ext_mem_w_data ext_mem_w_addr ext_mem_r_addr ext_mem_r_data r_data w_data level" IP_COMPONENT="IOB_ram_2p_asym" VERILOG_PROVIDED="
   //COMMON UTILS
   `define IOB_MAX(a,b) {((a) &gt; (b)) ? (a) : (b)}
   `define IOB_MIN(a,b) {((a) &lt; (b)) ? (a) : (b)}
   `define IOB_COMB always @*


   //IO
   `define IOB_INPUT(NAME, WIDTH) input [WIDTH-1:0] NAME
   `define IOB_OUTPUT(NAME, WIDTH) output [WIDTH-1:0] NAME
   `define IOB_OUTPUT_VAR(NAME, WIDTH) output reg [WIDTH-1:0] NAME

   //WIRES AND VARIABLES
   `define IOB_WIRE(NAME, WIDTH) wire [WIDTH-1:0] NAME;
   `define IOB_VAR(NAME, WIDTH) reg [WIDTH-1:0] NAME;


   //IOB_REGISTER
   `define IOB_REG_AR(CLK, RST_VAL, OUT, IN) always @(posedge CLK 1RESET_EDGE) if (1RESET_VALUE) OUT &lt;= RST_VAL; else OUT &lt;= IN;
   `define IOB_REG_ARE(CLK, RST_VAL, EN, OUT, IN) always @(posedge CLK 1RESET_EDGE) if (1RESET_VALUE) OUT &lt;= RST_VAL; \
           else if (EN) OUT &lt;= IN;


   //IOB_COUNTER
   `define IOB_COUNTER_ARE(CLK, EN, NAME) \
     `IOB_REG_ARE(CLK, 1&apos;b0, EN, NAME, NAME+1&apos;b1)
   localparam W_DATA_W = BITSIZE_w_data;
   localparam R_DATA_W = BITSIZE_r_data;
   localparam ADDR_W = BITSIZE_level - 1;
   localparam MAXDATA_W = `IOB_MAX(W_DATA_W, R_DATA_W);
   localparam MINDATA_W = `IOB_MIN(W_DATA_W, R_DATA_W);
   localparam N = MAXDATA_W/MINDATA_W;
   localparam MINADDR_W = ADDR_W-$clog2(N);//lower ADDR_W (higher DATA_W)
   localparam W_ADDR_W = (W_DATA_W == MAXDATA_W) ? MINADDR_W : ADDR_W;
   localparam R_ADDR_W = (R_DATA_W == MAXDATA_W) ? MINADDR_W : ADDR_W;

   localparam ADDR_W_DIFF = $clog2(N);
   localparam [ADDR_W:0] FIFO_SIZE = (1 &lt;&lt; ADDR_W); //in bytes

   reg [BITSIZE_level - 1 : 0] level;
   reg r_empty;
   reg w_full;

   reg error, next_error;
   reg w_full_nxt = 0;
   reg write_fail_reg;

   //effective write enable
   wire                   w_en_int = (w_en &amp; ~w_full) || write_fail_reg;

   //write address
   `IOB_VAR(w_addr, W_ADDR_W)
   `IOB_COUNTER_ARE(clock, w_en_int, w_addr)

   //effective read enable
   wire                   r_en_int  = (r_en &amp; ~r_empty) || write_fail;

   //backup address (to read in case of write fail)
   `IOB_VAR(b_addr, R_ADDR_W)
   `IOB_COUNTER_ARE(clock, write_done, b_addr)
   
   //read address
   `IOB_VAR(r_addr, R_ADDR_W)
   `IOB_COUNTER_ARE(clock, r_en_int, r_addr)

    assign dirty = w_full || r_addr != b_addr; 

   //assign according to assymetry type
   localparam [ADDR_W:0] w_incr = (W_DATA_W > R_DATA_W) ? 1 &lt;&lt; ADDR_W_DIFF : 1 ;
   localparam [ADDR_W:0] r_incr = (R_DATA_W > W_DATA_W) ? 1 &lt;&lt; ADDR_W_DIFF : 1 ;
   
   //FIFO level
   reg [ADDR_W+1:0]         level_nxt;
   `IOB_REG_AR(clock, 1&apos;b0, level, level_nxt[0+:ADDR_W+1])
   
   reg [W_ADDR_W - 1:0] w_addr_next;

   `IOB_COMB begin
      level_nxt = {1&apos;d0,level};
      if(r_en_int &amp;&amp; w_en_int)
        level_nxt = (level + w_incr) - r_incr;
      else if(w_en_int)
        level_nxt = level + w_incr;
      else if (r_en_int) // (!w_en_int) &amp;&amp; r_en_int
        level_nxt = level -r_incr;
   end
   
   `IOB_COMB begin
       next_error = error;
       if(write_fail)
        next_error = 1&apos;b1;
       else if(r_en_int)
        next_error = 1&apos;b0;
       w_addr_next = w_addr;
       w_full_nxt = w_full;
       if(write_fail)
        w_full_nxt = 1&apos;b1;
       else if(w_en_int &amp;&amp; write_done)
        w_full_nxt = w_addr == b_addr;
       else if(write_done)
        w_full_nxt = 1&apos;b0;
       else if(w_en_int) begin
        w_addr_next = (w_addr + 1);
        w_full_nxt = w_addr_next == b_addr;
       end
   end
   
always @(posedge clock) 
begin
  if(1RESET_VALUE)
  begin
    write_fail_reg &lt;= 0;
    error &lt;= 0;
  end
  else
  begin
    write_fail_reg &lt;= write_fail;
    error &lt;= next_error;
  end 
end

   //FIFO empty
   `IOB_WIRE(r_empty_nxt, 1)
   assign r_empty_nxt = (level_nxt[0+:ADDR_W+1] &lt; r_incr) &amp;&amp; (next_error == 0);
   `IOB_REG_AR(clock, 1&apos;d1, r_empty, r_empty_nxt)

   //FIFO full
  `IOB_REG_AR(clock, 1&apos;d0, w_full, w_full_nxt)

   //FIFO memory
   IOB_ram_2p_asym
     #(
       .W_DATA_W  (W_DATA_W),
       .R_DATA_W  (R_DATA_W),
       .ADDR_W    (ADDR_W),
       .BITSIZE_ext_mem_w_en(BITSIZE_ext_mem_w_en),
       .BITSIZE_ext_mem_w_data(BITSIZE_ext_mem_w_data),
       .BITSIZE_ext_mem_w_addr(BITSIZE_ext_mem_w_addr),
       .BITSIZE_ext_mem_r_addr(BITSIZE_ext_mem_r_addr),
       .BITSIZE_ext_mem_r_data(BITSIZE_ext_mem_r_data),
       .BITSIZE_w_data(BITSIZE_w_data),
       .BITSIZE_w_addr(W_ADDR_W),
       .BITSIZE_r_addr(R_ADDR_W),
       .BITSIZE_r_data(BITSIZE_r_data)
       )
    iob_ram_2p_asym0
     (
      .clock           (clock),
      
      .ext_mem_w_en  (ext_mem_w_en),
      .ext_mem_w_data(ext_mem_w_data),
      .ext_mem_w_addr(ext_mem_w_addr),
      .ext_mem_r_en  (ext_mem_r_en),
      .ext_mem_r_addr(ext_mem_r_addr),
      .ext_mem_r_data(ext_mem_r_data),

      .w_en          (w_en_int),
      .w_data        (write_fail_reg ? r_data : w_data),
      .w_addr        (w_addr),

      .r_en          (next_error || r_en_int),
      .r_addr        (next_error ? b_addr : r_addr),
      .r_data        (r_data)
      );
   `undef IOB_MAX
   `undef IOB_MIN
   `undef IOB_COMB
   `undef IOB_INPUT
   `undef IOB_OUTPUT
   `undef IOB_OUTPUT_VAR
   `undef IOB_WIRE
   `undef IOB_VAR
   `undef IOB_REG_AR
   `undef IOB_REG_ARE
   `undef IOB_COUNTER_ARE
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_ram_sp</name>
      <circuit>
        <component_o id="IOB_ram_sp">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_ram_sp"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_ram_sp addr dout din" VERILOG_PROVIDED="
   localparam DATA_W = BITSIZE_dout;
   localparam ADDR_W = BITSIZE_addr;
   
   reg [BITSIZE_dout - 1 : 0] dout;

   // Declare the RAM
   reg [DATA_W-1:0]         ram[2**ADDR_W-1:0];

   integer index;
   // Initialize the RAM
   initial
   begin
     for(index=0; index&lt;(2**ADDR_W); index=index+1)
     begin
       ram[index] = 0;
     end
   end

   // Operate the RAM
   always @ (posedge clock)
     if(en)
       if (we)
         ram[addr] &lt;= din;
       else
         dout &lt;= ram[addr];

  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_ram_sp_no_addr</name>
      <circuit>
        <component_o id="IOB_ram_sp_no_addr">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_ram_sp_no_addr"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="dout" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_ram_sp_no_addr dout din" VERILOG_PROVIDED="
   localparam DATA_W = BITSIZE_dout;

   reg [BITSIZE_dout - 1 : 0] dout;

   // Declare the RAM
   reg [DATA_W-1:0]         ram;

   // Operate the RAM
   always @ (posedge clock)
     if(en)
       if (we)
         ram &lt;= din;
       else
         dout &lt;= ram;
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_gen_sp_ram</name>
      <circuit>
        <component_o id="IOB_gen_sp_ram">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_gen_sp_ram"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_gen_sp_ram we addr data_out data_in" IP_COMPONENT="IOB_ram_sp" VERILOG_PROVIDED="
   localparam ADDR_W = BITSIZE_addr;
   localparam DATA_W = BITSIZE_data_out;
   genvar                                i;
   generate
      for (i = 0; i &lt; (DATA_W/8); i = i + 1)
        begin : ram
           IOB_ram_sp
               #(
                 .BITSIZE_addr(ADDR_W),
                 .BITSIZE_dout(8),
                 .BITSIZE_din(8)
                 )
           iob_cache_mem
               (
                .clock (clock),
                .en  (en),
                .we  (we[i]),
                .addr(addr),
                .dout(data_out[8*i +: 8]),
                .din (data_in [8*i +: 8])
                );
        end
   endgenerate
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_gen_sp_ram_no_addr</name>
      <circuit>
        <component_o id="IOB_gen_sp_ram_no_addr">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_gen_sp_ram_no_addr"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_gen_sp_ram_no_addr we data_out data_in" IP_COMPONENT="IOB_ram_sp_no_addr" VERILOG_PROVIDED="
   localparam DATA_W = BITSIZE_data_out;
   genvar                                i;
   generate
      for (i = 0; i &lt; (DATA_W/8); i = i + 1)
        begin : ram
           IOB_ram_sp_no_addr
               #(
                 .BITSIZE_dout(8),
                 .BITSIZE_din(8)
                 )
           iob_cache_mem
               (
                .clock (clock),
                .en  (en),
                .we  (we[i]),
                .dout(data_out[8*i +: 8]),
                .din (data_in [8*i +: 8])
                );
        end
   endgenerate
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_onehot_to_bin</name>
      <circuit>
        <component_o id="IOB_onehot_to_bin">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_onehot_to_bin"/>
          <port_o id="onehot" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="bin" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_onehot_to_bin onehot bin" VERILOG_PROVIDED="
   localparam BIN_W = BITSIZE_bin;

   reg [BITSIZE_bin - 1 : 0] bin;

   always @ (onehot) begin: onehot_to_binary_encoder
      integer i;
      reg [BIN_W-1:0] bin_cnt ;
      bin_cnt = 0;
      for (i=1; i&lt;2**BIN_W; i=i+1)
        if (onehot[i - 1]) bin_cnt = bin_cnt|i;
      bin = bin_cnt;    
   end
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_regfile_sp</name>
      <circuit>
        <component_o id="IOB_regfile_sp">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_regfile_sp"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="rst" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_regfile_sp addr w_data r_data" VERILOG_PROVIDED="

   localparam ADDR_W = BITSIZE_addr;
   localparam DATA_W = BITSIZE_w_data;
   
   reg [DATA_W-1:0]     reg_file [2**ADDR_W-1:0];

   //read
   assign r_data = reg_file[addr];

   //write
   genvar               i;
   generate
      for (i=0; i &lt; 2**ADDR_W; i=i+1) begin: register_file
         always @(posedge clock)
           if (rst)
             reg_file[i] &lt;= {DATA_W{1&apos;b0}};
           else if (we)
             if (addr == i)
               reg_file[i] &lt;= w_data;
        end
   endgenerate
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_regfile_sp_no_addr</name>
      <circuit>
        <component_o id="IOB_regfile_sp_no_addr">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_regfile_sp_no_addr"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="rst" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_regfile_sp_no_addr w_data r_data" VERILOG_PROVIDED="

   localparam DATA_W = BITSIZE_w_data;
   
   reg [DATA_W-1:0]     reg_file;

   //read
   assign r_data = reg_file;

   //write
    always @(posedge clock)
      if (rst)
        reg_file &lt;= {DATA_W{1&apos;b0}};
      else if (we)
        reg_file &lt;= w_data;
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_replacement_policy</name>
      <circuit>
        <component_o id="IOB_replacement_policy">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_replacement_policy"/>
          <parameter name="REP_POLICY"> 2 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="way_hit" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="line_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="way_select" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="way_select_bin" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_replacement_policy REP_POLICY way_hit line_addr way_select way_select_bin" IP_COMPONENT="IOB_onehot_to_bin,IOB_regfile_sp,IOB_regfile_sp_no_addr" VERILOG_PROVIDED="
   //Replacement Policy
   `define LRU       0 // Least Recently Used -- more resources intensive - N*log2(N) bits per cache line - Uses counters
   `define PLRU_mru  1 // bit-based Pseudo-Least-Recently-Used, a simpler replacement policy than LRU, using a much lower complexity (lower resources) - N bits per cache line
   `define PLRU_tree 2 // tree-based Pseudo-Least-Recently-Used, uses a tree that updates after any way received an hit, and points towards the oposing one. Uses less resources than bit-pseudo-lru - N-1 bits per cache line

   localparam N_WAYS = BITSIZE_way_hit;
   localparam LINE_OFF_W = BITSIZE_line_addr;
   localparam NWAY_W = $clog2(N_WAYS);
   
   genvar                  i, j, k;

   generate
      if (REP_POLICY == `LRU)
        begin
           wire [N_WAYS*NWAY_W -1:0] mru_out, mru_in;
           wire [N_WAYS*NWAY_W -1:0] mru; //Initial MRU values of the LRU algorithm, also initialized them in case it&apos;s the first access or was invalidated
           wire [N_WAYS*NWAY_W -1:0] mru_cnt; //updates the MRU line, the way used will be the highest value, while the others are decremented
           //wire [NWAY_W -1:0]        mru_index [N_WAYS :0]; //Index value of the MRU way
           wire [NWAY_W-1:0]         mru_index, way_hit_bin;

           IOB_onehot_to_bin #(
                           .BITSIZE_onehot(2**NWAY_W - 1),
                           .BITSIZE_bin(NWAY_W)
                           )
           way_hit_binary
             (
                  .onehot(way_hit[N_WAYS-1:1]),
                  .bin(way_hit_bin)
                  );


           assign mru_index [NWAY_W-1:0] = mru_out &gt;&gt; (NWAY_W*way_hit_bin);

           //assign mru_index [0] [NWAY_W -1:0] = {NWAY_W{1&apos;b0}};

           for (i = 0; i &lt; N_WAYS; i=i+1)
       begin : encoder_decoder
                //LRU - Encoder
          assign mru [i*NWAY_W +: NWAY_W] = (|mru_out)? mru_out [i*NWAY_W +: NWAY_W] : i; //verifies if the mru line has been initialized (if any bit in mru_output is HIGH), otherwise applies the priority values
                //assign mru_index [i+1][NWAY_W -1:0]  = mru_index[i][NWAY_W-1:0] | ({NWAY_W{way_hit[i]}} &amp; mru[(i+1)*NWAY_W -1: i*NWAY_W]); //stores the  index-value of the MRU way
                //assign mru_cnt [i*NWAY_W +: NWAY_W] = (way_hit[i])? {NWAY_W{1&apos;b1}} : (mru[i*NWAY_W +: NWAY_W] &gt; mru_index [N_WAYS]) ? mru[i*NWAY_W +: NWAY_W] - 1 : mru[i*NWAY_W +: NWAY_W];// the MRU way gets updated to the the highest value; the remaining, if their value was bigger than the MRU index previous value (mru_index), they get decremented
                assign mru_cnt [i*NWAY_W +: NWAY_W] = (way_hit[i])? {NWAY_W{1&apos;b1}} : (mru[i*NWAY_W +: NWAY_W] &gt; mru_index) ? mru[i*NWAY_W +: NWAY_W] - 1 : mru[i*NWAY_W +: NWAY_W];// the MRU way gets updated to the the highest value; the remaining, if their value was bigger than the MRU index previous value (mru_index), they get decremented

                //LRU - Decoder (checks every index in search for the lowest (0)
                assign way_select [i] = ~(|mru[i*NWAY_W +: NWAY_W]); //selects the way that has the lowest priority (mru = 0)
             end


           assign mru_in = (|way_hit)? mru_cnt : mru_out; //If an hit occured, then it updates, to avoid updating during a (write) miss (mru_cnt would decrement every way besides the lowest)

           if(LINE_OFF_W &gt; 0) begin
              IOB_regfile_sp
                 #(
                    .BITSIZE_addr(LINE_OFF_W),
                    .BITSIZE_w_data(N_WAYS * NWAY_W),
                    .BITSIZE_r_data(N_WAYS * NWAY_W)
                  )
              mru_memory //simply uses the same format as valid memory
                 (
                    .clock    (clock      ),
                    .rst    (reset    ),
      
                    .we     (write_en ),
                    .addr   (line_addr),
                    .w_data (mru_in   ),
                    .r_data (mru_out  )
                 );
           end else begin
              IOB_regfile_sp_no_addr
                 #(
                    .BITSIZE_w_data(N_WAYS * NWAY_W),
                    .BITSIZE_r_data(N_WAYS * NWAY_W)
                  )
              mru_memory //simply uses the same format as valid memory
                 (
                    .clock    (clock      ),
                    .rst    (reset    ),
      
                    .we     (write_en ),
                    .w_data (mru_in   ),
                    .r_data (mru_out  )
                 );
           end

           IOB_onehot_to_bin #(
              .BITSIZE_onehot(2**NWAY_W - 1),
              .BITSIZE_bin(NWAY_W)
              )
           onehot_bin
             (
                  .onehot(way_select[N_WAYS-1:1]),
                  .bin(way_select_bin)
                  );

        end // if (REP_POLICU == `LRU)
      else if (REP_POLICY == `PLRU_mru)
        begin

           wire [N_WAYS -1:0]      mru_in, mru_out;

           //pseudo LRU MRU based Encoder (More Recenty-Used bits):
           assign mru_in = (&amp;(mru_out | way_hit))? way_hit : mru_out | way_hit;//When the cache access results in a hi, it will update the MRU signal, if all ways were used, it resets and only updated the Most Recent

          // pseudo LRU MRU based Decoder:
          for (i = 1; i &lt; N_WAYS; i=i+1) begin : way_select_block
            assign way_select [i] = ~mru_out[i] &amp; (&amp;mru_out[i-1:0]); //verifies priority (lower index)
          end
          assign way_select[0] = ~mru_out[0];

           if(LINE_OFF_W &gt; 0) begin
              //Most Recently Used (MRU) memory
              IOB_regfile_sp
                 #(
                    .BITSIZE_addr(LINE_OFF_W),
                    .BITSIZE_w_data(N_WAYS - 1),
                    .BITSIZE_r_data(N_WAYS - 1)
                  )
              mru_memory //simply uses the same format as valid memory
                 (
                    .clock    (clock      ),
                    .rst    (reset    ),
      
                    .we     (write_en ),
                    .addr   (line_addr),
                    .w_data (mru_in   ),
                    .r_data (mru_out  )
                 );
           end else begin
              //Most Recently Used (MRU) memory
              IOB_regfile_sp_no_addr
                 #(
                    .BITSIZE_w_data(N_WAYS - 1),
                    .BITSIZE_r_data(N_WAYS - 1)
                  )
              mru_memory //simply uses the same format as valid memory
                 (
                    .clock    (clock      ),
                    .rst    (reset    ),
      
                    .we     (write_en ),
                    .w_data (mru_in   ),
                    .r_data (mru_out  )
                 );
           end

           IOB_onehot_to_bin #(
                           .BITSIZE_onehot(2**NWAY_W - 1),
                           .BITSIZE_bin(NWAY_W)
                           )
           onehot_bin
             (
                  .onehot(way_select[N_WAYS-1:1]),
                  .bin(way_select_bin)
                  );

        end // if (REP_POLICY == PLRU_mru)
      else // (REP_POLICY == PLRU_tree)
        begin
           /*
            i: tree level, start from 1, i &lt;= NWAY_W
            j: tree node id @ i level, start from 0, j &lt; (1&lt;&lt;(i-1))
            (((1&lt;&lt;(i-1))+j)*2)*(1&lt;&lt;(NWAY_W-i))   ==&gt; start node id of left tree @ the lowest level node pointed to
            (((1&lt;&lt;(i-1))+j)*2+1)*(1&lt;&lt;(NWAY_W-i)) ==&gt; start node id of right tree @ the lowest level node pointed to

            way_hit[(((1&lt;&lt;(i-1))+j)*2)*(1&lt;&lt;(NWAY_W-i))-N_WAYS +: (N_WAYS&gt;&gt;i)]   ==&gt; way hit range of left tree
            way_hit[(((1&lt;&lt;(i-1))+j)*2+1)*(1&lt;&lt;(NWAY_W-i))-N_WAYS +: (N_WAYS&gt;&gt;i)] ==&gt; way hit range of right tree


            == tree traverse ==

                         &lt;--0     1--&gt;                 traverse direction
                              [1]                      node id @ level1
                    [2]                 [3]            node id @ level2 ==&gt; which to traverse? from node_id[1]
               [4]       [5]       [6]       [7]       node id @ level3 ==&gt; which to traverse? from node_id[2]
            [08] [09] [10] [11] [12] [13] [14] [15]    node id @ level4 ==&gt; which to traverse? from node_id[3]
            (00) (01) (02) (03) (04) (05) (06) (07)    way idx

            node value is 0 -&gt; left tree traverse
            node value is 1 -&gt; right tree traverse

            node id mapping to way idx: node_id[NWAY_W]-N_WAYS
            */

           // wire [N_WAYS-1:1] t_plru, t_plru_output;
           wire [N_WAYS -1: 1] tree_in, tree_out;
           wire [NWAY_W:0]     node_id[NWAY_W:1];
           assign node_id[1] = tree_out[1] ? 3 : 2; // next node id @ level2 to traverse
           for (i = 2; i &lt;= NWAY_W; i = i + 1) begin : traverse_tree_level
              // next node id @ level3, level4, ..., to traverse
              assign node_id[i] = tree_out[node_id[i-1]] ? ((node_id[i-1]&lt;&lt;1)+1) : (node_id[i-1]&lt;&lt;1);
           end

           for (i = 1; i &lt;= NWAY_W; i = i + 1) begin : tree_level
              for (j = 0; j &lt; (1&lt;&lt;(i-1)); j = j + 1) begin : tree_level_node
                 assign tree_in[(1&lt;&lt;(i-1))+j] = ~(|way_hit) ? tree_out[(1&lt;&lt;(i-1))+j] :
                                                (|way_hit[((((1&lt;&lt;(i-1))+j)*2)*(1&lt;&lt;(NWAY_W-i)))-N_WAYS +: (N_WAYS&gt;&gt;i)]) ||
                                                (tree_out[(1&lt;&lt;(i-1))+j] &amp;&amp; (~(|way_hit[((((1&lt;&lt;(i-1))+j)*2+1)*(1&lt;&lt;(NWAY_W-i)))-N_WAYS +: (N_WAYS&gt;&gt;i)])));
              end
           end

           assign way_select_bin = node_id[NWAY_W]-N_WAYS;
           assign way_select = (1 &lt;&lt; way_select_bin);

           if(LINE_OFF_W &gt; 0) begin
              //Most Recently Used (MRU) memory
              IOB_regfile_sp
                 #(
                    .BITSIZE_addr(LINE_OFF_W),
                    .BITSIZE_w_data(N_WAYS - 1),
                    .BITSIZE_r_data(N_WAYS - 1)
                  )
              mru_memory //simply uses the same format as valid memory
                 (
                    .clock    (clock          ),
                    .rst    (reset        ),
      
                    .we     (write_en     ),
                    .addr   (line_addr    ),
                    .w_data (tree_in      ),
                    .r_data (tree_out     )
                 );
           end else begin
              //Most Recently Used (MRU) memory
              IOB_regfile_sp_no_addr
                 #(
                    .BITSIZE_w_data(N_WAYS - 1),
                    .BITSIZE_r_data(N_WAYS - 1)
                  )
              mru_memory //simply uses the same format as valid memory
                 (
                    .clock    (clock          ),
                    .rst    (reset        ),
      
                    .we     (write_en     ),
                    .w_data (tree_in      ),
                    .r_data (tree_out     )
                 );
           end
        end
   endgenerate

   `undef LRU
   `undef PLRU_mru
   `undef PLRU_tree
     "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_memory</name>
      <circuit>
        <component_o id="IOB_cache_memory">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_memory"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="N_WAYS"> 2 </parameter>
          <parameter name="LINE_OFF_W"> 10 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <parameter name="WTBUF_DEPTH_W"> 3 </parameter>
          <parameter name="REP_POLICY"> 2 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>

          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="flush" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="dirty_mem" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid_reg" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_reg" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wdata_reg" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb_reg" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_fail" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="invalidate" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wtbuf_full" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wtbuf_empty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_hit" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_miss" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_hit" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_miss" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_memory FE_ADDR_W N_WAYS LINE_OFF_W WORD_OFF_W WTBUF_DEPTH_W REP_POLICY CTRL_CACHE CTRL_CNT WRITE_POL addr rdata addr_reg wdata_reg wstrb_reg write_addr write_wdata write_wstrb replace_addr read_addr read_rdata" IP_COMPONENT="IOB_ram_2p,IOB_fifo_sync,IOB_gen_sp_ram,IOB_gen_sp_ram_no_addr,IOB_ram_sp,IOB_ram_sp_no_addr,IOB_replacement_policy,IOB_onehot_to_bin" VERILOG_PROVIDED="
   //Write Policy
   `define WRITE_THROUGH 0 //write-through not allocate: implements a write-through buffer
   `define WRITE_BACK 1    //write-back allocate: implementes a dirty-memory

   `define IOB_MAX(a,b) {((a) &gt; (b)) ? (a) : (b)}
   `define IOB_MIN(a,b) {((a) &lt; (b)) ? (a) : (b)}

     
   localparam FE_DATA_W = BITSIZE_rdata;
   localparam BE_DATA_W = BITSIZE_read_rdata;
   localparam NWAY_W = $clog2(N_WAYS);
   localparam FE_NBYTES  = FE_DATA_W/8;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   localparam BE_NBYTES = BE_DATA_W/8;
   localparam BE_BYTE_W = $clog2(BE_NBYTES);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);
   /* To avoid 0 size when using fully associative cache. Signals are ignored if the size should be 0  */
   localparam INDEX_W = LINE_OFF_W &gt; 0 ? LINE_OFF_W : 1;

   localparam TAG_W = FE_ADDR_W - (FE_BYTE_W + WORD_OFF_W + LINE_OFF_W);
   localparam BUF_DATA_SIZE = WRITE_POL == `WRITE_THROUGH ? FE_NBYTES+(FE_ADDR_W-FE_BYTE_W)+(FE_DATA_W) : FE_ADDR_W-FE_BYTE_W + (2**WORD_OFF_W)*FE_DATA_W;

   wire                                                                        hit;

   //cache-memory internal signals
   wire [N_WAYS-1:0]                                                           way_hit, way_select;

   wire [TAG_W-1:0]                                                            tag       = addr_reg[FE_ADDR_W-1 - (FE_BYTE_W) -:TAG_W]; //so the tag doesnt update during ready on a read-access, losing the current hit status (can take the 1 clock-cycle delay)
   wire [INDEX_W-1:0]                                                          index;
   wire [INDEX_W-1:0]                                                          index_reg;
   wire [WORD_OFF_W-1:0]                                                       offset    = addr_reg[FE_BYTE_W - (FE_BYTE_W) +:WORD_OFF_W]; //so the offset doesnt update during ready on a read-access (can take the 1 clock-cycle delay)


   wire [N_WAYS*(2**WORD_OFF_W)*FE_DATA_W-1:0]                                 line_rdata;
   wire [N_WAYS*TAG_W-1:0]                                                     line_tag;
   reg [N_WAYS*(2**LINE_OFF_W)-1:0]                                            v_reg;
   reg [N_WAYS-1:0]                                                            v;



   reg [(2**WORD_OFF_W)*FE_NBYTES-1:0]                                         line_wstrb;

   wire                                                                        write_access = |wstrb_reg &amp; valid_reg;
   wire                                                                        read_access = ~|wstrb_reg &amp; valid_reg;//signal mantains the access 1 addition clock-cycle after ready is asserted


   //back-end write channel
   wire                                                                        buffer_empty, buffer_full;
   wire [BUF_DATA_SIZE - 1 : 0]                                                buffer_dout;
   wire [BUF_DATA_SIZE - 1 : 0]                                                buf_w_data;
   wire                                                                        buf_w_en;

   //for write-back write-allocate only
   reg [N_WAYS-1:0]                                                            dirty;
   reg [N_WAYS*(2**LINE_OFF_W)-1:0]                                            dirty_reg;


   localparam S_IDLE = 2&apos;b00, S_ADDR = 2&apos;b01, S_WRITE = 2&apos;b10;
   reg [1:0]                                                                        flush_state = S_IDLE, next_flush_state;
   reg [(LINE_OFF_W + NWAY_W) - 1: 0]                                               flush_addr, next_flush_addr;


   generate
      if(LINE_OFF_W &gt; 0) begin
         assign index     = addr    [FE_ADDR_W-TAG_W-1 - (BE_BYTE_W + LINE2MEM_W) -:LINE_OFF_W];//cant wait, doesnt update during a write-access
         assign index_reg = addr_reg[FE_ADDR_W-TAG_W-1 - (FE_BYTE_W) -:INDEX_W];//cant wait, doesnt update during a write-access
      end
   endgenerate

   generate
      if(WRITE_POL == `WRITE_THROUGH) begin

         localparam FIFO_DATA_W = FE_ADDR_W-FE_BYTE_W + FE_DATA_W + FE_NBYTES;
         localparam FIFO_ADDR_W = WTBUF_DEPTH_W;

         localparam MAXDATA_W = `IOB_MAX(FIFO_DATA_W, FIFO_DATA_W);
         localparam MINDATA_W = `IOB_MIN(FIFO_DATA_W, FIFO_DATA_W);
         localparam N = MAXDATA_W/MINDATA_W;
         localparam MINADDR_W = FIFO_ADDR_W-$clog2(N);

         wire mem_w_en;
         wire [FIFO_ADDR_W-1:0] mem_w_addr;
         wire [FIFO_DATA_W-1:0] mem_w_data;

         wire mem_r_en;
         wire [FIFO_ADDR_W-1:0] mem_r_addr;
         wire [FIFO_DATA_W-1:0] mem_r_data;

         // FIFO memory
         IOB_ram_2p
           #(
             .BITSIZE_w_addr(FIFO_ADDR_W),
             .BITSIZE_w_data(FIFO_DATA_W),
             .BITSIZE_r_addr(FIFO_ADDR_W),
             .BITSIZE_r_data(FIFO_DATA_W)
             )
         iob_ram_2p0
           (
            .clock    (clock),

            .w_en   (mem_w_en),
            .w_addr (mem_w_addr),
            .w_data (mem_w_data),

            .r_en   (mem_r_en),
            .r_addr (mem_r_addr),
            .r_data (mem_r_data)
            );
         IOB_fifo_sync 
           #(
             .BITSIZE_ext_mem_w_en  (N),
             .BITSIZE_ext_mem_w_data(MINDATA_W * N),
             .BITSIZE_ext_mem_w_addr(MINADDR_W * N),
             .BITSIZE_ext_mem_r_addr(MINADDR_W * N),
             .BITSIZE_ext_mem_r_data(MINDATA_W * N),
             .BITSIZE_r_data        (FIFO_DATA_W),
             .BITSIZE_w_data        (FIFO_DATA_W),
             .BITSIZE_level         (FIFO_ADDR_W + 1)
             )
         write_buffer
           (
            .clock     (clock),
            .reset   (reset),

            .ext_mem_w_en   (mem_w_en),
            .ext_mem_w_addr (mem_w_addr),
            .ext_mem_w_data (mem_w_data),

            .ext_mem_r_en   (mem_r_en),
            .ext_mem_r_addr (mem_r_addr),
            .ext_mem_r_data (mem_r_data),

            .level   (),

            .r_data  (buffer_dout),
            .r_empty (buffer_empty),
            .r_en    (write_ready),
            .dirty   (dirty_mem),

            .w_data  (buf_w_data),
            .w_full  (buffer_full),
            .w_en    (buf_w_en),
            .write_fail(write_fail),
            .write_done(write_done)
            );

         assign buf_w_data = {addr_reg,wdata_reg,wstrb_reg};
         assign buf_w_en = write_access &amp; ready;

         //buffer status
         assign wtbuf_full = buffer_full;
         assign wtbuf_empty = buffer_empty &amp; write_ready &amp; ~write_valid;

         //back-end write channel
         assign write_valid = ~buffer_empty || write_fail;
         assign write_addr  = buffer_dout[FE_NBYTES + FE_DATA_W +: FE_ADDR_W - FE_BYTE_W];
         assign write_wdata = buffer_dout[FE_NBYTES             +: FE_DATA_W            ];
         assign write_wstrb = buffer_dout[0                     +: FE_NBYTES            ];


         //back-end read channel
         assign replace_valid = (~hit &amp; read_access &amp; ~replace) &amp; (buffer_empty &amp; write_ready);
         assign replace_addr  = addr[FE_ADDR_W -1 - (BE_BYTE_W + LINE2MEM_W):BE_BYTE_W+LINE2MEM_W - (BE_BYTE_W + LINE2MEM_W)];

      end
      else begin // if (WRITE_POL == WRITE_BACK)
         localparam FIFO_ADDR_W = WTBUF_DEPTH_W;
         localparam FIFO_DATA_W = FE_ADDR_W-FE_BYTE_W + (2**WORD_OFF_W)*FE_DATA_W;

         wire mem_w_en;
         wire [FIFO_ADDR_W-1:0] mem_w_addr;
         wire [FIFO_DATA_W-1:0] mem_w_data;

         wire mem_r_en;
         wire [FIFO_ADDR_W-1:0] mem_r_addr;
         wire [FIFO_DATA_W-1:0] mem_r_data;
         wire buf_dirty;
        // FIFO memory
        IOB_ram_2p
        #(
          .BITSIZE_w_addr(FIFO_ADDR_W),
          .BITSIZE_w_data(FIFO_DATA_W),
          .BITSIZE_r_addr(FIFO_ADDR_W),
          .BITSIZE_r_data(FIFO_DATA_W)
        )
        iob_ram_2p0
        (
          .clock    (clock),
          .w_en   (mem_w_en),
          .w_addr (mem_w_addr),
          .w_data (mem_w_data),
          .r_en   (mem_r_en),
          .r_addr (mem_r_addr),
          .r_data (mem_r_data)
        );
        IOB_fifo_sync 
        #(
          .BITSIZE_ext_mem_w_en  (1),
          .BITSIZE_ext_mem_w_data(FIFO_DATA_W),
          .BITSIZE_ext_mem_w_addr(FIFO_ADDR_W),
          .BITSIZE_ext_mem_r_addr(FIFO_ADDR_W),
          .BITSIZE_ext_mem_r_data(FIFO_DATA_W),
          .BITSIZE_r_data        (FIFO_DATA_W),
          .BITSIZE_w_data        (FIFO_DATA_W),
          .BITSIZE_level         (FIFO_ADDR_W + 1)
        )
        write_buffer
        (
          .clock     (clock),
          .reset   (reset),
          .ext_mem_w_en   (mem_w_en),
          .ext_mem_w_addr (mem_w_addr),
          .ext_mem_w_data (mem_w_data),
          .ext_mem_r_en   (mem_r_en),
          .ext_mem_r_addr (mem_r_addr),
          .ext_mem_r_data (mem_r_data),
          .level   (),
          .r_data  (buffer_dout),
          .r_empty (buffer_empty),
          .r_en    (write_ready),
          .dirty   (buf_dirty),
          .w_data  (buf_w_data),
          .w_full  (buffer_full),
          .w_en    (buf_w_en),
          .write_fail(write_fail),
          .write_done(write_done)
        );

        //buffer status
        assign write_valid = !buffer_empty || write_fail;
        assign wtbuf_full = buffer_full;
        assign wtbuf_empty = buffer_empty &amp; write_ready &amp; ~write_valid;

        assign dirty_mem = |dirty_reg || buf_dirty;
       //back-end read channel
       assign replace_valid = (~|way_hit) &amp; (write_ready) &amp; valid_reg &amp; ~replace;

       assign replace_addr = addr[FE_ADDR_W -1 - (BE_BYTE_W + LINE2MEM_W):BE_BYTE_W+LINE2MEM_W - (BE_BYTE_W + LINE2MEM_W)];
      
       //back-end write channel
       assign write_wstrb = {FE_NBYTES{1&apos;bx}};
       assign write_addr = buffer_dout[FIFO_DATA_W - 1 -: (FE_ADDR_W - FE_BYTE_W)];
       assign write_wdata = buffer_dout[(2**WORD_OFF_W)*FE_DATA_W - 1 : 0];        
      end
   endgenerate


   //////////////////////////////////////////////////////
   // Read-After-Write (RAW) Hazard (pipeline) control
   //////////////////////////////////////////////////////
  wire                                                     raw;
  reg                                                      write_hit_prev;
  reg [WORD_OFF_W-1:0]                                     offset_prev;
  reg [N_WAYS-1:0]                                         way_hit_prev;

  generate
    if (WRITE_POL == `WRITE_THROUGH) begin
      always @(posedge clock) begin
        write_hit_prev &lt;= write_access &amp; (|way_hit);
        //previous write position
        offset_prev &lt;= offset;
        way_hit_prev &lt;= way_hit;
      end
      assign raw = write_hit_prev &amp; (way_hit_prev == way_hit) &amp; (offset_prev == offset);
    end
    else begin //// if (WRITE_POL == WRITE_BACK)
      always @(posedge clock) begin
        write_hit_prev &lt;= write_access; //all writes will have the data in cache in the end
        //previous write position
        offset_prev &lt;= offset;
        way_hit_prev &lt;= way_hit;
      end
      assign raw = write_hit_prev &amp; (way_hit_prev == way_hit) &amp; (offset_prev == offset) &amp; read_access; //without read_access it is an infinite replacement loop
    end
  endgenerate


   ///////////////////////////////////////////////////////////////
   // Hit signal: data available and in the memory&apos;s output
   ///////////////////////////////////////////////////////////////
   assign hit = |way_hit &amp; ~replace &amp; (~raw);


   /////////////////////////////////
   //front-end READY signal
   /////////////////////////////////
   generate
      if (WRITE_POL == `WRITE_THROUGH)
        assign ready = (hit &amp; read_access) | (~buffer_full &amp; !(write_fail &amp;&amp; write_done) &amp; write_access);
      else // if (WRITE_POL == WRITE_BACK)
        assign ready = hit &amp; valid_reg;
   endgenerate

   //cache-control hit-miss counters enables
   generate
      if(CTRL_CACHE &amp; CTRL_CNT)
        begin
           //cache-control hit-miss counters enables
           assign write_hit  = ready &amp; ( hit &amp; write_access);
           assign write_miss = replace_valid &amp; write_access;
           assign read_hit   = ready &amp; ( hit &amp;  read_access);
           assign read_miss  = replace_valid &amp; read_access;
        end
      else
        begin
           assign write_hit  = 1&apos;bx;
           assign write_miss = 1&apos;bx;
           assign read_hit   = 1&apos;bx;
           assign read_miss  = 1&apos;bx;
        end // else: !if(CACHE_CTRL &amp; CTRL_CNT)
   endgenerate


   ////////////////////////////////////////
   //Memories implementation configurations
   ////////////////////////////////////////
   genvar                                                   i,j,k;
   generate

      if(LINE_OFF_W &gt; 0) begin
            //Data-Memory
            for (k = 0; k &lt; N_WAYS; k=k+1) begin : n_ways_block
              for(j = 0; j &lt; 2**LINE2MEM_W; j=j+1) begin : line2mem_block
                for(i = 0; i &lt; BE_DATA_W/FE_DATA_W; i=i+1) begin : BE_FE_block
                  IOB_gen_sp_ram
                  #(
                    .BITSIZE_we(FE_DATA_W / 8),
                    .BITSIZE_addr(LINE_OFF_W),
                    .BITSIZE_data_out(FE_DATA_W),
                    .BITSIZE_data_in(FE_DATA_W)
                  ) cache_memory (
                    .clock (clock),
                    .en  (valid || flush),
                    .we ({FE_NBYTES{way_hit[k]}} &amp; line_wstrb[(j*(BE_DATA_W/FE_DATA_W)+i)*FE_NBYTES +: FE_NBYTES]),
                    .addr(flush ? flush_addr[LINE_OFF_W - 1 : 0] : (write_access &amp; way_hit[k] &amp; ((j*(BE_DATA_W/FE_DATA_W)+i) == offset))? index_reg : index),
                    .data_in ((replace)? read_rdata[i*FE_DATA_W +: FE_DATA_W] : wdata_reg),
                    .data_out(line_rdata[(k*(2**WORD_OFF_W)+j*(BE_DATA_W/FE_DATA_W)+i)*FE_DATA_W +: FE_DATA_W])
                  );
                end
              end
            end
        end else begin
            //Data-Memory
            for (k = 0; k &lt; N_WAYS; k=k+1) begin : n_ways_block
              for(j = 0; j &lt; 2**LINE2MEM_W; j=j+1) begin : line2mem_block
                for(i = 0; i &lt; BE_DATA_W/FE_DATA_W; i=i+1) begin : BE_FE_block
                  IOB_gen_sp_ram_no_addr
                  #(
                    .BITSIZE_we(FE_DATA_W / 8),
                    .BITSIZE_data_out(FE_DATA_W),
                    .BITSIZE_data_in(FE_DATA_W)
                  ) cache_memory (
                    .clock (clock),
                    .en  (valid || flush),
                    .we ({FE_NBYTES{way_hit[k]}} &amp; line_wstrb[(j*(BE_DATA_W/FE_DATA_W)+i)*FE_NBYTES +: FE_NBYTES]),
                    .data_in ((replace)? read_rdata[i*FE_DATA_W +: FE_DATA_W] : wdata_reg),
                    .data_out(line_rdata[(k*(2**WORD_OFF_W)+j*(BE_DATA_W/FE_DATA_W)+i)*FE_DATA_W +: FE_DATA_W])
                  );
                end
              end
            end
        end

      //Cache Line Write Strobe
      if(LINE2MEM_W &gt; 0)
        begin
           always @*
             if(replace)
               line_wstrb = {BE_NBYTES{read_valid}} &lt;&lt; (read_addr*BE_NBYTES); //line-replacement: read_addr indexes the words in cache-line
             else
               line_wstrb = (wstrb_reg &amp; {FE_NBYTES{write_access}}) &lt;&lt; (offset*FE_NBYTES);
        end
      else
        begin
           always @*
             if(replace)
               line_wstrb = {BE_NBYTES{read_valid}}; //line-replacement: mem&apos;s word replaces entire line
             else
               line_wstrb = (wstrb_reg &amp; {FE_NBYTES{write_access}}) &lt;&lt; (offset*FE_NBYTES);
        end // else: !if(LINE2MEM_W &lt; 0)


      // Valid-Tag memories &amp; replacement-policy
      if(N_WAYS &gt; 1)
        begin

           wire [NWAY_W-1:0] way_hit_bin, way_select_bin;//reason for the 2 generates for single vs multiple ways
           
           if(LINE_OFF_W &gt; 0) begin
              //valid-memory
              always @ (posedge clock 1RESET_EDGE) begin
                 if (1RESET_VALUE)
                    v_reg &lt;= 0;
                 else if (invalidate)
                    v_reg &lt;= 0;
                 else if(replace_valid)
                    v_reg &lt;= v_reg | (1&lt;&lt;(way_select_bin*(2**LINE_OFF_W) + index_reg));
                 else
                    v_reg &lt;= v_reg;
              end
                 
              for(k = 0; k &lt; N_WAYS; k = k+1) begin : tag_mem_block
                 //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
                 always @(posedge clock)
                    if(invalidate)
                       v[k] &lt;= 0;
                    else
                       v[k] &lt;= v_reg [(2**LINE_OFF_W)*k + index];
      
                 //tag-memory
                 IOB_ram_sp
                    #(
                       .BITSIZE_addr(LINE_OFF_W),
                       .BITSIZE_dout(TAG_W),
                       .BITSIZE_din(TAG_W)
                     )
                 tag_memory
                    (
                       .clock (clock                                                           ),
                       .en  (valid || flush_state == S_ADDR                               ),
                       .we  (way_select[k] &amp; replace_valid                                 ),
                       .addr(flush_state == S_ADDR ? flush_addr[LINE_OFF_W - 1 : 0] : index),
                       .din (tag                                                           ),
                       .dout(line_tag[TAG_W*k +: TAG_W]                                    )
                    );
      
      
                 //Way hit signal - hit or replacement
                 assign way_hit[k] = flush ? (flush_addr[LINE_OFF_W +: NWAY_W] == k) : (tag == line_tag[TAG_W*k +: TAG_W]) &amp; v[k];
              end
           end else begin
              //valid-memory
              always @ (posedge clock 1RESET_EDGE) begin
                 if (1RESET_VALUE)
                    v_reg &lt;= 0;
                 else if (invalidate)
                    v_reg &lt;= 0;
                 else if(replace_valid)
                    v_reg &lt;= v_reg | (1&lt;&lt;way_select_bin);
                 else
                    v_reg &lt;= v_reg;
              end
                 
              for(k = 0; k &lt; N_WAYS; k = k+1) begin : tag_mem_block
                 //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
                 always @(posedge clock)
                    if(invalidate)
                       v[k] &lt;= 0;
                    else
                       v[k] &lt;= v_reg [k];
      
                 //tag-memory
                 IOB_ram_sp_no_addr
                    #(
                       .BITSIZE_dout(TAG_W),
                       .BITSIZE_din(TAG_W)
                    )
                 tag_memory
                    (
                       .clock (clock                                                           ),
                       .en  (valid || flush_state == S_ADDR                               ),
                       .we  (way_select[k] &amp; replace_valid                                 ),
                       .din (tag                                                           ),
                       .dout(line_tag[TAG_W*k +: TAG_W]                                    )
                    );
      
      
                  //Way hit signal - hit or replacement
                  assign way_hit[k] = flush ? (flush_addr[LINE_OFF_W +: NWAY_W] == k) : (tag == line_tag[TAG_W*k +: TAG_W]) &amp; v[k];
              end
           end
  

           //Read Data Multiplexer
           assign rdata [FE_DATA_W-1:0] = line_rdata &gt;&gt; FE_DATA_W*(offset + (2**WORD_OFF_W)*way_hit_bin);


           //replacement-policy module
           IOB_replacement_policy #(
                          .BITSIZE_way_hit(N_WAYS),
                          .BITSIZE_line_addr(LINE_OFF_W),
                          .BITSIZE_way_select(N_WAYS),
                          .BITSIZE_way_select_bin(NWAY_W),
                          .REP_POLICY(REP_POLICY)
                          )
           replacement_policy_algorithm
             (
              .clock       (clock             ),
              .reset     (1RESET_VALUE|invalidate),
              .write_en  (ready           ),
              .way_hit   (way_hit         ),
              .line_addr (index_reg       ),
              .way_select(way_select      ),
              .way_select_bin(way_select_bin)
              );

           //onehot-to-binary for way-hit
           IOB_onehot_to_bin #(
                           .BITSIZE_onehot(2**NWAY_W - 1),
                           .BITSIZE_bin(NWAY_W)
                           )
           way_hit_encoder
             (
              .onehot(way_hit[N_WAYS-1:1]),
              .bin   (way_hit_bin)
              );

           //dirty-memory
           if(WRITE_POL == `WRITE_BACK)
             begin
                if(LINE_OFF_W &gt; 0) begin
                   always @ (posedge clock 1RESET_EDGE) begin
                      if (1RESET_VALUE)
                        dirty_reg &lt;= 0;
                      else if (flush_state == S_WRITE &amp;&amp; !buffer_full) begin
                        dirty_reg &lt;= dirty_reg &amp; ~(1&lt;&lt;flush_addr);
                      end else if(write_access &amp; hit)
                        dirty_reg &lt;= dirty_reg |  (1&lt;&lt;(way_hit_bin*(2**LINE_OFF_W) + index_reg));//updates position with 1
                      else
                        dirty_reg &lt;= dirty_reg;
                   end

                   for(k = 0; k &lt; N_WAYS; k = k+1) begin : dirty_block
                     //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
                     always @(posedge clock)
                       dirty[k] &lt;= dirty_reg [(2**LINE_OFF_W)*k + index];
                   end
                end else begin
                   always @ (posedge clock 1RESET_EDGE) begin
                      if (1RESET_VALUE)
                        dirty_reg &lt;= 0;
                      else if (flush_state == S_WRITE &amp;&amp; !buffer_full) begin
                        dirty_reg &lt;= dirty_reg &amp; ~(1&lt;&lt;flush_addr);
                      end else if(write_access &amp; hit)
                        dirty_reg &lt;= dirty_reg |  (1&lt;&lt;(way_hit_bin*(2**LINE_OFF_W)));//updates position with 1
                      else
                        dirty_reg &lt;= dirty_reg;
                   end
                   
                   for(k = 0; k &lt; N_WAYS; k = k+1) begin : dirty_block
                      //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
                      always @(posedge clock)
                         dirty[k] &lt;= dirty_reg [k];
                   end
                end

                //flush line
                wire [TAG_W-1:0] tag_flush = line_tag &gt;&gt; ((flush? way_hit_bin : way_select_bin)*TAG_W);      //auxiliary wire
                assign buf_w_en = (valid_reg &amp;&amp; (way_hit == &apos;b0) &amp;&amp; (way_select &amp; dirty) &amp;&amp; replace_valid) || flush_state == S_WRITE;
                wire [FE_DATA_W*(2**WORD_OFF_W) - 1 : 0] data_flush = line_rdata &gt;&gt; ((flush ? way_hit_bin : way_select_bin) *FE_DATA_W*(2**WORD_OFF_W));
                if(LINE_OFF_W &gt; 0) begin
                   assign buf_w_data = {{tag_flush, flush ? flush_addr[LINE_OFF_W - 1 : 0] : index_reg}, data_flush}; 
                end else begin
                   assign buf_w_data = {tag_flush, data_flush}; 
                end
             end // if (WRITE_POL == WRITE_BACK)
        end
      else // (N_WAYS = 1)
        begin
           //valid-memory
           always @ (posedge clock 1RESET_EDGE)
             begin
                if (1RESET_VALUE)
                  v_reg &lt;= 0;
                else if (invalidate)
                  v_reg &lt;= 0;
                else if(replace_valid)
                  v_reg &lt;= v_reg | (1 &lt;&lt; index);
                else
                  v_reg &lt;= v_reg;
             end

           //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
           always @(posedge clock)
             if(invalidate)
               v &lt;= 0;
             else
               v &lt;= v_reg [index];

           //tag-memory
           IOB_ram_sp
             #(
               .BITSIZE_addr(LINE_OFF_W),
               .BITSIZE_dout(TAG_W),
               .BITSIZE_din(TAG_W)
               )
           tag_memory
             (
              .clock (clock),
              .en  (valid || flush_state == S_ADDR),
              .we  (replace_valid),
              .addr(flush_state == S_ADDR ? flush_addr[LINE_OFF_W - 1 : 0] : index),
              .din (tag),
              .dout(line_tag)
              );


           //Cache hit signal that indicates which way has had the hit (also during replacement)
           assign way_hit = (tag == line_tag) &amp; v;

           //Read Data Multiplexer
           assign rdata [FE_DATA_W-1:0] = line_rdata &gt;&gt; FE_DATA_W*offset;

           //dirty-memory
           if(WRITE_POL == `WRITE_BACK)
             begin
                //dirty-memory
                always @ (posedge clock 1RESET_EDGE) begin
                   if (1RESET_VALUE)
                     dirty_reg &lt;= 0;
                   else if(flush_state == S_WRITE &amp;&amp; !buffer_full) begin
                     dirty_reg &lt;= dirty_reg &amp; ~(1 &lt;&lt; flush_addr);
                   end else if(!flush) begin
                    if(write_access &amp; hit)
                      dirty_reg &lt;= dirty_reg | (1&lt;&lt;(index_reg)); //updates position with 1 (needs to be index_reg otherwise updates the new index if the previous access was a write)
                   end else
                      dirty_reg &lt;= dirty_reg;
                end

                always @(posedge clock)
                  dirty &lt;= dirty_reg [index];

                  assign buf_w_en = ((write_access || read_access) &amp;&amp; (~(way_hit) &amp; dirty) &amp;&amp; replace_valid) || flush_state == S_WRITE;
                  assign buf_w_data = {{line_tag, flush_state == S_WRITE ? flush_addr[LINE_OFF_W - 1 : 0] : index_reg}, line_rdata};
             end // if (WRITE_POL == WRITE_BACK)
        end // else: !if(N_WAYS &gt; 1)
   endgenerate

   generate
    if(WRITE_POL == `WRITE_BACK) begin
      always @(*) begin
        next_flush_state = flush_state;
        next_flush_addr = &apos;b0;
        case(flush_state)
          S_IDLE: begin
            if(flush) begin
              next_flush_state = S_ADDR;
            end
          end
          S_ADDR: begin
            if(dirty_reg[flush_addr]) begin
              next_flush_addr = flush_addr;
              next_flush_state = S_WRITE;
            end else if (|dirty_reg) begin
              next_flush_addr = flush_addr + 1;
              next_flush_state = S_ADDR;
            end else begin
              next_flush_state = S_IDLE;
            end
          end
          S_WRITE: begin
            if(!buffer_full) begin
              next_flush_addr = flush_addr + 1;
              next_flush_state = S_ADDR;
            end else begin
              next_flush_addr = flush_addr;
              next_flush_state = S_WRITE;
            end
          end
          default: begin
            next_flush_state = S_IDLE;
          end
        endcase
      end
      
      always @(posedge clock) begin
        flush_state &lt;= next_flush_state;
        flush_addr &lt;= next_flush_addr;
        if(1RESET_VALUE) begin
          flush_state &lt;= S_IDLE;
        end 
      end  
    end
  endgenerate
   `undef WRITE_THROUGH
   `undef WRITE_BACK
   `undef IOB_MIN
   `undef IOB_MAX
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_control</name>
      <circuit>
        <component_o id="IOB_cache_control">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_control"/>
          <parameter name="CTRL_CNT"> 1 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="wtbuf_full" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wtbuf_empty" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_hit" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_miss" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_hit" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_miss" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="invalidate" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_control CTRL_CNT rdata" VERILOG_PROVIDED="
   `define CTRL_ADDR_W 4
    //Addresses for cache controller&apos;s task
   `define ADDR_BUFFER_EMPTY          (`CTRL_ADDR_W&apos;d1)
   `define ADDR_BUFFER_FULL           (`CTRL_ADDR_W&apos;d2) 
   `define ADDR_CACHE_HIT             (`CTRL_ADDR_W&apos;d3) 
   `define ADDR_CACHE_MISS            (`CTRL_ADDR_W&apos;d4) 
   `define ADDR_CACHE_READ_ACCESS     (`CTRL_ADDR_W&apos;d5) 
   `define ADDR_CACHE_READ_MISS       (`CTRL_ADDR_W&apos;d6) 
   `define ADDR_CACHE_WRITE_ACCESS    (`CTRL_ADDR_W&apos;d7) 
   `define ADDR_CACHE_WRITE_MISS      (`CTRL_ADDR_W&apos;d8) 
   `define ADDR_RESET_COUNTER         (`CTRL_ADDR_W&apos;d9) 
   `define ADDR_CACHE_INVALIDATE      (`CTRL_ADDR_W&apos;d10)

   localparam FE_DATA_W = BITSIZE_rdata;

   reg [BITSIZE_rdata - 1 : 0] rdata;
   reg invalidate;
   reg ready;

   generate
      if(CTRL_CNT)
        begin : cnt
           
           reg [FE_DATA_W-1:0]             read_access_cnt, read_miss_cnt, write_access_cnt, write_miss_cnt;
           wire [FE_DATA_W-1:0]            hit_cnt, miss_cnt;
           reg                             counter_reset;

           assign hit_cnt  = read_access_cnt  + write_access_cnt;
           assign miss_cnt = read_miss_cnt + write_miss_cnt;
           
           always @ (posedge clock 1RESET_EDGE)
             begin
	        if (1RESET_VALUE) 
	          begin
                     read_access_cnt  &lt;= {FE_DATA_W{1&apos;b0}};
               read_miss_cnt &lt;= {FE_DATA_W{1&apos;b0}};
               write_access_cnt  &lt;= {FE_DATA_W{1&apos;b0}};
               write_miss_cnt &lt;= {FE_DATA_W{1&apos;b0}};
                  end
                else
                  begin
                     if (counter_reset) 
                 begin
                          read_access_cnt  &lt;= {FE_DATA_W{1&apos;b0}};
                    read_miss_cnt &lt;= {FE_DATA_W{1&apos;b0}};
                    write_access_cnt  &lt;= {FE_DATA_W{1&apos;b0}};
                    write_miss_cnt &lt;= {FE_DATA_W{1&apos;b0}};
                       end
                     else
                 if (read_hit)
                   begin
                read_access_cnt &lt;= read_access_cnt + 1; 
                   end
                 else if (write_hit)
                   begin
                write_access_cnt &lt;= write_access_cnt + 1;
                   end
                 else if (read_miss)
                   begin
                read_miss_cnt &lt;= read_miss_cnt + 1;
                         end
                 else if (write_miss)
                   begin
                write_miss_cnt &lt;= write_miss_cnt + 1;
                   end
                 else
                   begin
                read_access_cnt &lt;= read_access_cnt;
                read_miss_cnt &lt;= read_miss_cnt;
                write_access_cnt &lt;= write_access_cnt;
                write_miss_cnt &lt;= write_miss_cnt;
                   end
            end // else: !if(ctrl_arst)   
             end // always @ (posedge clock, posedge ctrl_arst)
           
           always @ (posedge clock)
             begin
          rdata &lt;= {FE_DATA_W{1&apos;b0}};
          invalidate &lt;= 1&apos;b0;
          counter_reset &lt;= 1&apos;b0;
          ready &lt;= valid; // Sends acknowlege the next clock cycle after request (handshake)               
          if(valid)
            if (addr == `ADDR_CACHE_HIT)
              rdata &lt;= hit_cnt;
            else if (addr == `ADDR_CACHE_MISS)
              rdata &lt;= miss_cnt;
            else if (addr == `ADDR_CACHE_READ_ACCESS)
              rdata &lt;= read_access_cnt;
            else if (addr == `ADDR_CACHE_READ_MISS)
              rdata &lt;= read_miss_cnt;
            else if (addr == `ADDR_CACHE_WRITE_ACCESS)
              rdata &lt;= write_access_cnt;
            else if (addr == `ADDR_CACHE_WRITE_MISS)
              rdata &lt;= write_miss_cnt;
            else if (addr == `ADDR_RESET_COUNTER)
              counter_reset &lt;= 1&apos;b1;
            else if (addr == `ADDR_CACHE_INVALIDATE)
              invalidate &lt;= 1&apos;b1;  
            else if (addr == `ADDR_BUFFER_EMPTY)
              rdata &lt;= wtbuf_empty;
            else if (addr == `ADDR_BUFFER_FULL)
              rdata &lt;= wtbuf_full;
             end // always @ (posedge clock)
        end // if (CTRL_CNT)
      else
        begin
           
           always @ (posedge clock)
             begin
          rdata &lt;= {FE_DATA_W{1&apos;b0}};
          invalidate &lt;= 1&apos;b0;
          ready &lt;= valid; // Sends acknowlege the next clock cycle after request (handshake)               
          if(valid)
            if (addr == `ADDR_CACHE_INVALIDATE)
              invalidate &lt;= 1&apos;b1;  
            else if (addr == `ADDR_BUFFER_EMPTY)
                    rdata &lt;= wtbuf_empty;
                  else if (addr == `ADDR_BUFFER_FULL)
                    rdata &lt;= wtbuf_full;         
             end // always @ (posedge clock)
        end // else: !if(CTRL_CNT)  
   endgenerate                
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_axi</name>
      <circuit>
        <component_o id="IOB_cache_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_DATA_W"> 32 </parameter>
          <parameter name="N_WAYS"> 1 </parameter>
          <parameter name="LINE_OFF_W"> 8 </parameter>
          <parameter name="WORD_OFF_W"> 4 </parameter>
          <parameter name="WTBUF_DEPTH_W"> 5 </parameter>
          <parameter name="REP_POLICY"> 2 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>

          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="flush" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="dirty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_axi FE_ADDR_W BE_ADDR_W BE_DATA_W N_WAYS LINE_OFF_W WORD_OFF_W WTBUF_DEPTH_W REP_POLICY WRITE_POL AXI_ID CTRL_CACHE CTRL_CNT addr wdata wstrb rdata m_axi_awid m_axi_awaddr m_axi_awlen m_axi_wdata m_axi_wstrb m_axi_bid m_axi_arid m_axi_araddr m_axi_arlen m_axi_rid m_axi_rdata" IP_COMPONENT="IOB_front_end,IOB_cache_memory,IOB_back_end_axi,IOB_cache_control" VERILOG_PROVIDED="
   //Cache-Control
   `define CTRL_ADDR_W 4
   //Address-port
   `define WORD_ADDR // Word-addressable, (BE) addr becomes word-addressable (doesn&apos;t receive the byte-offset).

   
   localparam FE_DATA_W = BITSIZE_wdata;
   localparam NWAY_W = $clog2(N_WAYS);
   localparam FE_NBYTES = FE_DATA_W / 8;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   localparam BE_NBYTES = BE_DATA_W / 8;
   localparam BE_BYTE_W = $clog2(BE_NBYTES);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);
   localparam AXI_ADDR_W = BE_ADDR_W;
   localparam AXI_DATA_W = BE_DATA_W;
   localparam AXI_ID_W = 1;
   localparam AXI_LEN_W = 8;

   wire                                         data_valid, data_ready;
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr; 
   wire [FE_DATA_W-1 : 0]                       data_wdata, data_rdata;
   wire [FE_NBYTES-1: 0]                        data_wstrb;
   
   //stored signals
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr_reg; 
   wire [FE_DATA_W-1 : 0]                       data_wdata_reg;
   wire [FE_NBYTES-1: 0]                        data_wstrb_reg;
   wire                                         data_valid_reg;

   //back-end write-channel
   wire                                         write_valid, write_ready;
   wire [FE_ADDR_W-1:FE_BYTE_W + WRITE_POL*WORD_OFF_W] write_addr;
   wire [FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)-1 :0] write_wdata;
   wire [FE_NBYTES-1:0]                                                    write_wstrb;
   wire                                                                    write_fail;
   wire                                                                    write_done;
   
   //back-end read-channel
   wire                                                                    replace_valid, replace;
   wire [FE_ADDR_W -1:BE_BYTE_W+LINE2MEM_W]                                replace_addr; 
   wire                                                                    read_valid;
   wire [LINE2MEM_W-1:0]                                                   read_addr;
   wire [BE_DATA_W-1:0]                                                    read_rdata;
   
   //cache-control
   wire                                                                    ctrl_valid, ctrl_ready;   
   wire [`CTRL_ADDR_W-1:0]                                                 ctrl_addr;
   wire                                                                    wtbuf_full, wtbuf_empty;
   wire                                                                    write_hit, write_miss, read_hit, read_miss;
   wire [CTRL_CACHE*(FE_DATA_W-1):0]                                       ctrl_rdata;
   wire                                                                    invalidate;
   
   IOB_front_end
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT(CTRL_CNT),
       .BITSIZE_addr(CTRL_CACHE + FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata(FE_DATA_W),
       .BITSIZE_wstrb(FE_NBYTES),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_data_addr(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_rdata(FE_DATA_W),
       .BITSIZE_data_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_wdata_reg(FE_DATA_W),
       .BITSIZE_data_wstrb_reg(FE_NBYTES),
       .BITSIZE_ctrl_addr(`CTRL_ADDR_W),
       .BITSIZE_ctrl_rdata(CTRL_CACHE * (FE_DATA_W - 1) + 1)
       )
   front_end
     (
      .clock   (clock),
      .reset (reset),
      //front-end port
      .valid (valid),
      .addr  ({{CTRL_CACHE{1&apos;b0}}, addr}),
      .wdata (wdata),
      .wstrb (wstrb),
      .rdata (rdata),
      .ready (ready),
      //cache-memory input signals
      .data_valid (data_valid),
      .data_addr  (data_addr),
      //cache-memory output
      .data_rdata (data_rdata),
      .data_ready (data_ready),
      //stored input signals
      .data_valid_reg (data_valid_reg),
      .data_addr_reg  (data_addr_reg),
      .data_wdata_reg (data_wdata_reg),
      .data_wstrb_reg (data_wstrb_reg),
      //cache-control
      .ctrl_valid (ctrl_valid),
      .ctrl_addr  (ctrl_addr),
      .ctrl_rdata (ctrl_rdata),
      .ctrl_ready (ctrl_ready)
      );

   IOB_cache_memory
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .N_WAYS     (N_WAYS),
       .LINE_OFF_W (LINE_OFF_W),
       .WORD_OFF_W (WORD_OFF_W),
       .REP_POLICY (REP_POLICY),    
       .WTBUF_DEPTH_W (WTBUF_DEPTH_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT  (CTRL_CNT),
       .WRITE_POL (WRITE_POL),
       .BITSIZE_addr(FE_ADDR_W - (BE_BYTE_W + LINE2MEM_W)),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata_reg(FE_DATA_W),
       .BITSIZE_wstrb_reg(FE_NBYTES),
       .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_write_wstrb(FE_NBYTES),
       .BITSIZE_replace_addr(FE_ADDR_W - (BE_BYTE_W+LINE2MEM_W)),
       .BITSIZE_read_addr(LINE2MEM_W),
       .BITSIZE_read_rdata(BE_DATA_W)
       )
   cache_memory
     (
      .clock   (clock),
      .reset (reset),
      //front-end
      //internal data signals
      .valid (data_valid),
      .addr  (data_addr[FE_ADDR_W-1:BE_BYTE_W + LINE2MEM_W]),
      //.wdata (data_wdata),
      // .wstrb (data_wstrb),
      .rdata (data_rdata),
      .ready (data_ready),
      .dirty_mem (dirty),
      //stored data signals
      .valid_reg (data_valid_reg),   
      .addr_reg  (data_addr_reg),
      .wdata_reg (data_wdata_reg),
      .wstrb_reg (data_wstrb_reg),
      //back-end
      //write-through-buffer (write-channel)
      .write_valid (write_valid),
      .write_addr  (write_addr),
      .write_wdata (write_wdata),
      .write_wstrb (write_wstrb),
      .write_ready (write_ready),
      .write_fail  (write_fail),
      .write_done  (write_done),
      //cache-line replacement (read-channel)
      .replace_valid (replace_valid),
      .replace_addr  (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr  (read_addr),
      .read_rdata (read_rdata),
      //control&apos;s signals
      .wtbuf_empty (wtbuf_empty),
      .wtbuf_full  (wtbuf_full),
      .write_hit   (write_hit),
      .write_miss  (write_miss),
      .read_hit    (read_hit),
      .read_miss   (read_miss),
      .invalidate  (invalidate),
      .flush(flush)
      );


   IOB_back_end_axi
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .FE_DATA_W (FE_DATA_W),  
       .BE_ADDR_W (BE_ADDR_W),
       .WORD_OFF_W(WORD_OFF_W),
       .WRITE_POL (WRITE_POL),
       .AXI_ID(AXI_ID),
       .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_write_wstrb(FE_NBYTES),
       .BITSIZE_replace_addr(FE_ADDR_W - (FE_BYTE_W + WORD_OFF_W)),
       .BITSIZE_read_addr(LINE2MEM_W),
       .BITSIZE_read_rdata(BE_DATA_W),
       .BITSIZE_m_axi_awid(AXI_ID_W),
       .BITSIZE_m_axi_awaddr(AXI_ADDR_W),
       .BITSIZE_m_axi_awlen(AXI_LEN_W),
       .BITSIZE_m_axi_wdata(AXI_DATA_W),
       .BITSIZE_m_axi_wstrb(AXI_DATA_W / 8),
       .BITSIZE_m_axi_bid(AXI_ID_W),
       .BITSIZE_m_axi_arid(AXI_ID_W),
       .BITSIZE_m_axi_araddr(AXI_ADDR_W),
       .BITSIZE_m_axi_arlen(AXI_LEN_W),
       .BITSIZE_m_axi_rid(AXI_ID_W),
       .BITSIZE_m_axi_rdata(AXI_DATA_W)       
              )
   back_end
     (
       //write-through-buffer (write-channel)
      .write_valid (write_valid),
      .write_addr  (write_addr),
      .write_wdata (write_wdata),
      .write_wstrb (write_wstrb),
      .write_ready (write_ready),
      .write_fail  (write_fail),
      .write_done  (write_done),
      //cache-line replacement (read-channel)
      .replace_valid (replace_valid),
      .replace_addr  (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr  (read_addr),
      .read_rdata (read_rdata),
      .m_axi_awid(m_axi_awid), //Address write channel ID
      .m_axi_awaddr(m_axi_awaddr), //Address write channel address
      .m_axi_awlen(m_axi_awlen), //Address write channel burst length
      .m_axi_awsize(m_axi_awsize), //Address write channel burst size. This signal indicates the size of each transfer in the burst
      .m_axi_awburst(m_axi_awburst), //Address write channel burst type
      .m_axi_awlock(m_axi_awlock), //Address write channel lock type
      .m_axi_awcache(m_axi_awcache), //Address write channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
      .m_axi_awprot(m_axi_awprot), //Address write channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
      .m_axi_awqos(m_axi_awqos), //Address write channel quality of service
      .m_axi_awvalid(m_axi_awvalid), //Address write channel valid
      .m_axi_awready(m_axi_awready), //Address write channel ready
      .m_axi_wdata(m_axi_wdata), //Write channel data
      .m_axi_wstrb(m_axi_wstrb), //Write channel write strobe
      .m_axi_wlast(m_axi_wlast), //Write channel last word flag
      .m_axi_wvalid(m_axi_wvalid), //Write channel valid
      .m_axi_wready(m_axi_wready), //Write channel ready
      .m_axi_bid(m_axi_bid), //Write response channel ID
      .m_axi_bresp(m_axi_bresp), //Write response channel response
      .m_axi_bvalid(m_axi_bvalid), //Write response channel valid
      .m_axi_bready(m_axi_bready), //Write response channel ready
      .m_axi_arid(m_axi_arid), //Address read channel ID
      .m_axi_araddr(m_axi_araddr), //Address read channel address
      .m_axi_arlen(m_axi_arlen), //Address read channel burst length
      .m_axi_arsize(m_axi_arsize), //Address read channel burst size. This signal indicates the size of each transfer in the burst
      .m_axi_arburst(m_axi_arburst), //Address read channel burst type
      .m_axi_arlock(m_axi_arlock), //Address read channel lock type
      .m_axi_arcache(m_axi_arcache), //Address read channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
      .m_axi_arprot(m_axi_arprot), //Address read channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
      .m_axi_arqos(m_axi_arqos), //Address read channel quality of service
      .m_axi_arvalid(m_axi_arvalid), //Address read channel valid
      .m_axi_arready(m_axi_arready), //Address read channel ready
      .m_axi_rid(m_axi_rid), //Read channel ID
      .m_axi_rdata(m_axi_rdata), //Read channel data
      .m_axi_rresp(m_axi_rresp), //Read channel response
      .m_axi_rlast(m_axi_rlast), //Read channel last word
      .m_axi_rvalid(m_axi_rvalid), //Read channel valid
      .m_axi_rready(m_axi_rready), //Read channel addr
      .clock(clock),
      .reset(reset)
      );
   
   
   generate
      if (CTRL_CACHE) begin : ctrl
        IOB_cache_control
          #(
            .CTRL_CNT   (CTRL_CNT),
            .BITSIZE_rdata(CTRL_CNT * FE_DATA_W)
            )
      cache_control
        (
         .clock   (clock),
         .reset (reset),
         //control&apos;s signals
         .valid (ctrl_valid),
         .addr  (ctrl_addr),
         //write data
         .wtbuf_full (wtbuf_full),
         .wtbuf_empty (wtbuf_empty), 
         .write_hit  (write_hit),
         .write_miss (write_miss),
         .read_hit   (read_hit),
         .read_miss  (read_miss),
         ////////////
         .rdata (ctrl_rdata),
         .ready (ctrl_ready),
         .invalidate (invalidate)
         );
      end else
        begin
           assign ctrl_rdata = 1&apos;bx;
           assign ctrl_ready = 1&apos;bx;
           assign invalidate = 1&apos;b0;
        end // else: !if(CTRL_CACHE)
      
   endgenerate
   `undef CTRL_ADDR_W
   `undef WORD_ADDR
     "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_minimal_axi</name>
      <circuit>
        <component_o id="IOB_cache_minimal_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_minimal_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_DATA_W"> 32 </parameter>
          <parameter name="N_WAYS"> 1 </parameter>
          <parameter name="LINE_OFF_W"> 8 </parameter>
          <parameter name="WORD_OFF_W"> 4 </parameter>
          <parameter name="WTBUF_DEPTH_W"> 5 </parameter>
          <parameter name="REP_POLICY"> 2 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_input" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="32"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="32"/>
          </port_o>
          <port_o id="Min_data_size_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="5"/>
          </port_o>
          <port_o id="Min_accelerator_context_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_back_pressure" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_datardy" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_Rdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="32"/>
          </port_o>
          <port_o id="Min_accelerator_context" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_back_pressure_in" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_minimal_axi FE_ADDR_W BE_ADDR_W BE_DATA_W N_WAYS LINE_OFF_W WORD_OFF_W WTBUF_DEPTH_W REP_POLICY WRITE_POL AXI_ID CTRL_CACHE CTRL_CNT Min_addr_ram Min_Wdata_ram Min_Rdata_ram Min_data_size_ram Min_accelerator_context_in Min_accelerator_context m_axi_awid m_axi_awaddr m_axi_awlen m_axi_wdata m_axi_wstrb m_axi_bid m_axi_arid m_axi_araddr m_axi_arlen m_axi_rid m_axi_rdata" IP_COMPONENT="IOB_front_end,IOB_cache_memory,IOB_back_end_axi,IOB_cache_control" VERILOG_PROVIDED="
   //Cache-Control
   `define CTRL_ADDR_W 4
   //Address-port
   `define WORD_ADDR // Word-addressable, (BE) addr becomes word-addressable (doesn&apos;t receive the byte-offset).

   
   localparam FE_DATA_W = BITSIZE_Min_Wdata_ram;
   localparam NWAY_W = $clog2(N_WAYS);
   localparam FE_NBYTES = FE_DATA_W / 8;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   localparam BE_NBYTES = BE_DATA_W / 8;
   localparam BE_BYTE_W = $clog2(BE_NBYTES);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);
   localparam AXI_ADDR_W = BE_ADDR_W;
   localparam AXI_DATA_W = BE_DATA_W;
   localparam AXI_ID_W = 1;
   localparam AXI_LEN_W = 8;

   wire                                         data_valid, data_ready;
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr; 
   wire [FE_DATA_W-1 : 0]                       data_wdata, data_rdata;
   wire [FE_NBYTES-1: 0]                        data_wstrb;
   
   //stored signals
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr_reg; 
   wire [FE_DATA_W-1 : 0]                       data_wdata_reg;
   wire [FE_NBYTES-1: 0]                        data_wstrb_reg;
   wire                                         data_valid_reg;

   //back-end write-channel
   wire                                         write_valid, write_ready;
   wire [FE_ADDR_W-1:FE_BYTE_W + WRITE_POL*WORD_OFF_W] write_addr;
   wire [FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)-1 :0] write_wdata;
   wire [FE_NBYTES-1:0]                                                    write_wstrb;
   wire                                                                    write_fail;
   wire                                                                    write_done;
   
   //back-end read-channel
   wire                                                                    replace_valid, replace;
   wire [FE_ADDR_W -1:BE_BYTE_W+LINE2MEM_W]                                replace_addr; 
   wire                                                                    read_valid;
   wire [LINE2MEM_W-1:0]                                                   read_addr;
   wire [BE_DATA_W-1:0]                                                    read_rdata;
   
   //cache-control
   wire                                                                    ctrl_valid, ctrl_ready;   
   wire [`CTRL_ADDR_W-1:0]                                                 ctrl_addr;
   wire                                                                    wtbuf_full, wtbuf_empty;
   wire                                                                    write_hit, write_miss, read_hit, read_miss;
   wire [CTRL_CACHE*(FE_DATA_W-1):0]                                       ctrl_rdata;
   wire                                                                    invalidate;
   
   wire                                                                    dirty;
   
   reg [BITSIZE_Min_accelerator_context - 1 : 0]                           acc_ctxt;
   reg                                                                     done_input_reg = 1&apos;b0;

   reg                                                                     done_input_reg = 1&apos;b0, done_input_next;

   reg                                                                     Min_back_pressure_progress;

   reg                                                                     Min_back_pressure;
   reg [BITSIZE_Min_addr_ram - 1 : 0]                                      addr_reg;

   reg                                                                     done;

   always @(*) begin
     done_input_next = done_input ? 1&apos;b1 : done_input_reg;
     if((Min_oe_ram || Min_we_ram) &amp;&amp; !Min_back_pressure_in) begin
       addr_reg = addr;
     end
   end

   always @(posedge clock) begin
     done_input_reg &lt;= done_input_next;
     if((Min_oe_ram || Min_we_ram) &amp;&amp; !data_valid_reg) begin
       acc_ctxt &lt;= Min_accelerator_context_in;
     end
     if(done_input_next) begin
       done &lt;= !dirty;
     end
     Min_back_pressure &lt;= data_valid_reg &amp;&amp; (Min_we_ram || Min_oe_ram) ? Min_back_pressure_progress : 1&apos;b0;
     Min_back_pressure_progress &lt;= data_valid_reg &amp;&amp; !Min_datardy ? 1&apos;b1 : 1&apos;b0;
   end

   assign Min_accelerator_context = acc_ctxt;
   
   IOB_front_end
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT(CTRL_CNT),
       .BITSIZE_addr(CTRL_CACHE + FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata(FE_DATA_W),
       .BITSIZE_wstrb(FE_NBYTES),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_data_addr(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_rdata(FE_DATA_W),
       .BITSIZE_data_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_wdata_reg(FE_DATA_W),
       .BITSIZE_data_wstrb_reg(FE_NBYTES),
       .BITSIZE_ctrl_addr(`CTRL_ADDR_W),
       .BITSIZE_ctrl_rdata(CTRL_CACHE * (FE_DATA_W - 1) + 1)
       )
   front_end
     (
      .clock   (clock),
      .reset (!reset),
      //front-end port
      .valid (Min_oe_ram || Min_we_ram),
      .addr  (addr_reg[FE_ADDR_W - 1 : FE_BYTE_W]),
      .wdata (Min_Wdata_ram),
      .wstrb ({FE_NBYTES{Min_we_ram}}),
      .rdata (Min_Rdata_ram),
      .ready (Min_datardy),
      //cache-memory input signals
      .data_valid (data_valid),
      .data_addr  (data_addr),
      //cache-memory output
      .data_rdata (data_rdata),
      .data_ready (data_ready),
      //stored input signals
      .data_valid_reg (data_valid_reg),
      .data_addr_reg  (data_addr_reg),
      .data_wdata_reg (data_wdata_reg),
      .data_wstrb_reg (data_wstrb_reg),
      //cache-control
      .ctrl_valid (ctrl_valid),
      .ctrl_addr  (ctrl_addr),
      .ctrl_rdata (ctrl_rdata),
      .ctrl_ready (ctrl_ready)
      );

   IOB_cache_memory
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .N_WAYS     (N_WAYS),
       .LINE_OFF_W (LINE_OFF_W),
       .WORD_OFF_W (WORD_OFF_W),
       .REP_POLICY (REP_POLICY),    
       .WTBUF_DEPTH_W (WTBUF_DEPTH_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT  (CTRL_CNT),
       .WRITE_POL (WRITE_POL),
       .BITSIZE_addr(FE_ADDR_W - (BE_BYTE_W + LINE2MEM_W)),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata_reg(FE_DATA_W),
       .BITSIZE_wstrb_reg(FE_NBYTES),
       .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_write_wstrb(FE_NBYTES),
       .BITSIZE_replace_addr(FE_ADDR_W - (BE_BYTE_W+LINE2MEM_W)),
       .BITSIZE_read_addr(LINE2MEM_W),
       .BITSIZE_read_rdata(BE_DATA_W)
       )
   cache_memory
     (
      .clock   (clock),
      .reset (!reset),
      //front-end
      //internal data signals
      .valid (data_valid),
      .addr  (data_addr[FE_ADDR_W-1:BE_BYTE_W + LINE2MEM_W]),
      //.wdata (data_wdata),
      // .wstrb (data_wstrb),
      .rdata (data_rdata),
      .ready (data_ready),
      .dirty_mem (dirty),
      //stored data signals
      .valid_reg (data_valid_reg),   
      .addr_reg  (data_addr_reg),
      .wdata_reg (data_wdata_reg),
      .wstrb_reg (data_wstrb_reg),
      //back-end
      //write-through-buffer (write-channel)
      .write_valid (write_valid),
      .write_addr  (write_addr),
      .write_wdata (write_wdata),
      .write_wstrb (write_wstrb),
      .write_ready (write_ready),
      .write_fail  (write_fail),
      .write_done  (write_done),
      //cache-line replacement (read-channel)
      .replace_valid (replace_valid),
      .replace_addr  (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr  (read_addr),
      .read_rdata (read_rdata),
      //control&apos;s signals
      .wtbuf_empty (wtbuf_empty),
      .wtbuf_full  (wtbuf_full),
      .write_hit   (write_hit),
      .write_miss  (write_miss),
      .read_hit    (read_hit),
      .read_miss   (read_miss),
      .flush(done_input_reg)
      );


   IOB_back_end_axi
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .FE_DATA_W (FE_DATA_W),  
       .BE_ADDR_W (BE_ADDR_W),
       .WORD_OFF_W(WORD_OFF_W),
       .WRITE_POL (WRITE_POL),
       .AXI_ID(AXI_ID),
       .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_write_wstrb(FE_NBYTES),
       .BITSIZE_replace_addr(FE_ADDR_W - (FE_BYTE_W + WORD_OFF_W)),
       .BITSIZE_read_addr(LINE2MEM_W),
       .BITSIZE_read_rdata(BE_DATA_W),
       .BITSIZE_m_axi_awid(AXI_ID_W),
       .BITSIZE_m_axi_awaddr(AXI_ADDR_W),
       .BITSIZE_m_axi_awlen(AXI_LEN_W),
       .BITSIZE_m_axi_wdata(AXI_DATA_W),
       .BITSIZE_m_axi_wstrb(AXI_DATA_W / 8),
       .BITSIZE_m_axi_bid(AXI_ID_W),
       .BITSIZE_m_axi_arid(AXI_ID_W),
       .BITSIZE_m_axi_araddr(AXI_ADDR_W),
       .BITSIZE_m_axi_arlen(AXI_LEN_W),
       .BITSIZE_m_axi_rid(AXI_ID_W),
       .BITSIZE_m_axi_rdata(AXI_DATA_W)       
              )
   back_end
     (
       //write-through-buffer (write-channel)
      .write_valid (write_valid),
      .write_addr  (write_addr),
      .write_wdata (write_wdata),
      .write_wstrb (write_wstrb),
      .write_ready (write_ready),
      .write_fail  (write_fail),
      .write_done  (write_done),
      //cache-line replacement (read-channel)
      .replace_valid (replace_valid),
      .replace_addr  (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr  (read_addr),
      .read_rdata (read_rdata),
      .m_axi_awid(m_axi_awid), //Address write channel ID
      .m_axi_awaddr(m_axi_awaddr), //Address write channel address
      .m_axi_awlen(m_axi_awlen), //Address write channel burst length
      .m_axi_awsize(m_axi_awsize), //Address write channel burst size. This signal indicates the size of each transfer in the burst
      .m_axi_awburst(m_axi_awburst), //Address write channel burst type
      .m_axi_awlock(m_axi_awlock), //Address write channel lock type
      .m_axi_awcache(m_axi_awcache), //Address write channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
      .m_axi_awprot(m_axi_awprot), //Address write channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
      .m_axi_awqos(m_axi_awqos), //Address write channel quality of service
      .m_axi_awvalid(m_axi_awvalid), //Address write channel valid
      .m_axi_awready(m_axi_awready), //Address write channel ready
      .m_axi_wdata(m_axi_wdata), //Write channel data
      .m_axi_wstrb(m_axi_wstrb), //Write channel write strobe
      .m_axi_wlast(m_axi_wlast), //Write channel last word flag
      .m_axi_wvalid(m_axi_wvalid), //Write channel valid
      .m_axi_wready(m_axi_wready), //Write channel ready
      .m_axi_bid(m_axi_bid), //Write response channel ID
      .m_axi_bresp(m_axi_bresp), //Write response channel response
      .m_axi_bvalid(m_axi_bvalid), //Write response channel valid
      .m_axi_bready(m_axi_bready), //Write response channel ready
      .m_axi_arid(m_axi_arid), //Address read channel ID
      .m_axi_araddr(m_axi_araddr), //Address read channel address
      .m_axi_arlen(m_axi_arlen), //Address read channel burst length
      .m_axi_arsize(m_axi_arsize), //Address read channel burst size. This signal indicates the size of each transfer in the burst
      .m_axi_arburst(m_axi_arburst), //Address read channel burst type
      .m_axi_arlock(m_axi_arlock), //Address read channel lock type
      .m_axi_arcache(m_axi_arcache), //Address read channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
      .m_axi_arprot(m_axi_arprot), //Address read channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
      .m_axi_arqos(m_axi_arqos), //Address read channel quality of service
      .m_axi_arvalid(m_axi_arvalid), //Address read channel valid
      .m_axi_arready(m_axi_arready), //Address read channel ready
      .m_axi_rid(m_axi_rid), //Read channel ID
      .m_axi_rdata(m_axi_rdata), //Read channel data
      .m_axi_rresp(m_axi_rresp), //Read channel response
      .m_axi_rlast(m_axi_rlast), //Read channel last word
      .m_axi_rvalid(m_axi_rvalid), //Read channel valid
      .m_axi_rready(m_axi_rready), //Read channel addr
      .clock(clock),
      .reset(!reset))
      );
   
   
   generate
      if (CTRL_CACHE)
        IOB_cache_control
          #(
            .CTRL_CNT   (CTRL_CNT),
            .BITSIZE_rdata(CTRL_CNT * FE_DATA_W)
            )
      cache_control
        (
         .clock   (clock),
         .reset (!reset),
         //control&apos;s signals
         .valid (ctrl_valid),
         .addr  (ctrl_addr),
         //write data
         .wtbuf_full (wtbuf_full),
         .wtbuf_empty (wtbuf_empty), 
         .write_hit  (write_hit),
         .write_miss (write_miss),
         .read_hit   (read_hit),
         .read_miss  (read_miss),
         ////////////
         .rdata (ctrl_rdata),
         .ready (ctrl_ready),
         .invalidate (invalidate)
         );
      else
        begin
           assign ctrl_rdata = 1&apos;bx;
           assign ctrl_ready = 1&apos;bx;
           assign invalidate = 1&apos;b0;
        end // else: !if(CTRL_CACHE)
      
   endgenerate
   `undef CTRL_ADDR_W
   `undef WORD_ADDR
     "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_read_channel_minimal</name>
      <circuit>
        <component_o id="IOB_read_channel_minimal">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_read_channel_minimal"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="mem_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="mem_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_read_channel_minimal FE_ADDR_W FE_DATA_W WORD_OFF_W replace_addr read_addr read_rdata mem_addr mem_rdata" VERILOG_PROVIDED="
   localparam BE_ADDR_W = BITSIZE_mem_addr;
   localparam BE_DATA_W = BITSIZE_read_rdata;
   localparam BE_BYTE_W = $clog2(BE_DATA_W / 8);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);

   reg [BITSIZE_read_addr - 1 : 0] read_addr;
   reg read_valid;
   reg mem_valid;
   reg replace;

   generate
      if (LINE2MEM_W &gt; 0)
        begin

           reg [LINE2MEM_W-1:0] word_counter;
           
           assign mem_addr  = {BE_ADDR_W{1&apos;b0}} + {replace_addr[FE_ADDR_W -1 - (BE_BYTE_W + LINE2MEM_W): 0], word_counter, {BE_BYTE_W{1&apos;b0}}};
           

           // assign read_valid = mem_ready;
           assign read_rdata = mem_rdata;

           localparam
             idle             = 2&apos;d0,
             read             = 2&apos;d1, 
             delay            = 2&apos;d2;

           always @ (posedge clock)
             read_addr &lt;= word_counter;
           
           reg [1:0]            state;

           always @(posedge clock 1RESET_EDGE)
             begin
                if(1RESET_VALUE)
                  begin
                     state &lt;= idle;
                  end
                else
                  begin
                     case(state)

                       idle:
                         begin
                            if(replace_valid) //main_process flag
                              state &lt;= read;                                        
                            else
                              state &lt;= idle;                      
                         end
                       
                       read:
                         begin
                            state &lt;= delay;
                         end
                       
                       delay: 
                         begin
                            if(mem_ready)
                              if(read_addr == {LINE2MEM_W{1&apos;b1}})
                                state &lt;= idle;
                              else
                                begin
                                   state &lt;= read;
                                end
                            else
                              begin
                                 state &lt;= delay;
                              end
                         end
                       
                       default:;
                       
                     endcase                                                     
                  end         
             end
           
           
           always @*
             begin 
                mem_valid     = 1&apos;b0;
                replace       = 1&apos;b1;
                word_counter  = 0;
                read_valid    = 1&apos;b0;
                
                case(state)
                  
                  idle:
                    begin
                       replace = 1&apos;b0;
                    end

                  read:
                    begin
                       mem_valid = 1&apos;b1;
                       word_counter = read_addr;
                    end
                  
                  delay:
                    begin
                       word_counter = read_addr + mem_ready;
                       read_valid = mem_ready;
                    end
                  default:;
                  
                  
                endcase
             end
        end // if (LINE2MEM_W &gt; 0)
      else
        begin
           assign mem_addr  = {BE_ADDR_W{1&apos;b0}} + {replace_addr, {BE_BYTE_W{1&apos;b0}}};
           
           // assign read_valid = mem_valid; //doesn require line_load since when mem_valid is HIGH, so is line_load.
           assign read_rdata = mem_rdata;

           localparam
             idle             = 2&apos;d0,
             read             = 2&apos;d1, 
             delay            = 2&apos;d2;
           
           
           reg [1:0]                                  state;

           always @(posedge clock 1RESET_EDGE)
             begin
                if(1RESET_VALUE)
                  state &lt;= idle;
                else
                  begin
                     case(state)

                       idle:
                         begin
                            
                            if(replace_valid)
                              state &lt;= read;                                        
                            else
                              state &lt;= idle;                      
                         end
                       
                       read:
                         begin
                            state &lt;= delay;
                         end
                       
                       delay:
                         begin
                            if(mem_ready)
                              state &lt;= idle;
                            else
                              state &lt;= delay;
                         end
                       
                       default:;
                       
                     endcase                                                     
                  end         
             end
           
           
           always @*
             begin 
                mem_valid     = 1&apos;b0;
                replace       = 1&apos;b1;
                read_valid    = 1&apos;b0;
                
                case(state)
                  
                  idle:
                    begin
                       replace = 1&apos;b0;
                    end

                  read:
                    begin
                       mem_valid = 1&apos;b1;
                    end
                  
                  delay:
                    begin
                       read_valid = mem_ready;
                    end
                  
                  default:;
                  
                endcase
             end
           
        end // else: !if(MEM_OFF_W &gt; 0)
      endgenerate
        "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_write_channel_minimal</name>
      <circuit>
        <component_o id="IOB_write_channel_minimal">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_write_channel_minimal"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="mem_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_fail" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="mem_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_write_channel_minimal FE_ADDR_W FE_DATA_W WRITE_POL WORD_OFF_W addr wstrb wdata mem_addr mem_wdata mem_wstrb" VERILOG_PROVIDED="
    localparam FE_NBYTES = BITSIZE_wstrb;
    localparam FE_BYTE_W = $clog2(FE_NBYTES);
    localparam BE_ADDR_W = BITSIZE_mem_addr;
    localparam BE_DATA_W = BITSIZE_mem_wdata;
    localparam BE_NBYTES = BE_DATA_W / 8;
    localparam BE_BYTE_W = $clog2(BE_NBYTES);
    localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);

    reg mem_wstrb;
    reg ready;
    reg mem_valid;



    assign write_done=mem_ready;
    assign write_fail = 1&apos;b0;
    
    genvar                                                                   i;

    generate
      if(WRITE_POL == 0) begin

        assign mem_addr = {BE_ADDR_W{1&apos;b0}} + {addr[FE_ADDR_W-1 - (FE_BYTE_W + WRITE_POL*WORD_OFF_W) :BE_BYTE_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)], {BE_BYTE_W{1&apos;b0}}};

        localparam
          idle  = 2&apos;d0,
          write = 2&apos;d1,
          delay  = 2&apos;d2;

          reg [1:0] state;
          if(BE_DATA_W == FE_DATA_W) begin
            assign mem_wdata = wdata;
            always @* begin
              mem_wstrb = 0;
              case(state)
                write: mem_wstrb = wstrb;
                default:;
              endcase // case (state)
            end // always @ *
          end
          else begin
            wire [BE_BYTE_W-FE_BYTE_W -1 :0] word_align = addr[FE_BYTE_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W) +: (BE_BYTE_W - FE_BYTE_W)];

            for (i = 0; i &lt; BE_DATA_W/FE_DATA_W; i = i +1) begin : wdata_block
              assign mem_wdata[(i+1)*FE_DATA_W-1:i*FE_DATA_W] = wdata;
            end

            always @* begin
              mem_wstrb = 0;
              case(state)
                write: mem_wstrb = wstrb &lt;&lt; word_align * FE_NBYTES;
                default:;
              endcase // case (state)
            end // always @ *
          end

          always @(posedge clock 1RESET_EDGE) begin
            if(1RESET_VALUE)
              state &lt;= idle;
            else
              case(state)
                idle: begin
                  if(valid)
                    state &lt;= write;
                  else
                    state &lt;= idle;
                end
                write: begin
                    state &lt;= delay;
                end
                default: begin /* delay */
                  if(mem_ready &amp; ~valid)
                    state &lt;= idle;
                  else
                    if(mem_ready &amp; valid) //still has data to write
                      state &lt;= write;
                    else
                      state &lt;= delay;
                end
              endcase // case (state)
          end // always @ (posedge clock 1RESET_EDGE)

         always @*
           begin
              ready = 1&apos;b0;
              mem_valid = 1&apos;b0;
              case(state)
                idle:
                  ready = 1&apos;b1;
                write:
                  mem_valid = ~mem_ready;
                default: /* delay */
                  begin
                     ready = mem_ready;
                  end
              endcase // case (state)
           end
      end // if (WRITE_POL == WRITE_THROUGH)
      //////////////////////////////////////////////////////////////////////////////////////////////
      else begin // if (WRITE_POL == WRITE_BACK)

         if (LINE2MEM_W &gt; 0) begin

            reg [LINE2MEM_W-1:0] word_counter, word_counter_reg;
            always @(posedge clock) word_counter_reg &lt;= word_counter;

            // memory address
            assign mem_addr  = {BE_ADDR_W{1&apos;b0}} + {addr[FE_ADDR_W-1 - (FE_BYTE_W + WRITE_POL*WORD_OFF_W) : BE_BYTE_W + LINE2MEM_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)], word_counter, {BE_BYTE_W{1&apos;b0}}};
            // memory write-data
            assign mem_wdata = wdata&gt;&gt;(BE_DATA_W*word_counter);

            localparam
              idle  = 2&apos;d0,
              write = 2&apos;d1,
              delay = 2&apos;d2;

            reg [1:0]            state;

            always @(posedge clock 1RESET_EDGE)
              begin
                 if(1RESET_VALUE)
                   state &lt;= idle;
                 else
                   case(state)

                     idle:
                       begin
                          if(valid)
                            state &lt;= write;
                          else
                            state &lt;= idle;
                       end

                     write:
                       state &lt;= delay;
                     default: /* delay */
                       begin
                          if(mem_ready &amp; (&amp;word_counter_reg))
                            state &lt;= idle;
                          else if(mem_ready)
                            state &lt;= write;
                          else
                            state &lt;= delay;
                       end
                   endcase // case (state)
              end // always @ (posedge clock 1RESET_EDGE)

            always @*
              begin
                 ready        = 1&apos;b0;
                 mem_valid    = 1&apos;b0;
                 mem_wstrb    = 0;
                 word_counter = 0;

                 case(state)
                   idle:
                     begin
                        ready = ~valid;
                        if(valid) mem_wstrb = {BE_NBYTES{1&apos;b1}};
                        else mem_wstrb =0;
                     end

                   write:
                     begin
                        mem_valid = ~(mem_ready &amp; (&amp;word_counter));
                        mem_wstrb = {BE_NBYTES{1&apos;b1}};
                        word_counter = word_counter_reg;
                     end
                   default: /* delay */
                     begin
                        ready = mem_ready &amp; (&amp;word_counter); //last word transfered
                        word_counter = word_counter_reg + mem_ready;
                     end
                 endcase // case (state)
              end

         end // if (LINE2MEM_W &gt; 0)
         else begin // if (LINE2MEM_W == 0)

            // memory address
            assign mem_addr  = {BE_ADDR_W{1&apos;b0}} + {addr[FE_ADDR_W-1 - (FE_BYTE_W + WRITE_POL*WORD_OFF_W) : BE_BYTE_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)], {BE_BYTE_W{1&apos;b0}}};
            // memory write-data
            assign mem_wdata = wdata;

            localparam
              idle  = 2&apos;d0,
              write = 2&apos;d1,
              delay = 2&apos;d2;

            reg [1:0]            state;

            always @(posedge clock 1RESET_EDGE)
              begin
                 if(1RESET_VALUE)
                   state &lt;= idle;
                 else
                   case(state)

                     idle:
                       begin
                          if(valid)
                            state &lt;= write;
                          else
                            state &lt;= idle;
                       end

                     write:
                       begin
                         state &lt;= delay;
                       end
                     default:
                       begin
                          if(mem_ready)
                            state &lt;= idle;
                          else
                            state &lt;= delay;
                       end
                   endcase // case (state)
              end // always @ (posedge clock 1RESET_EDGE)

            always @*
              begin
                 ready        = 1&apos;b0;
                 mem_valid    = 1&apos;b0;
                 mem_wstrb    = 0;

                 case(state)
                   idle:
                     begin
                        ready = ~valid;
                        if(valid) mem_wstrb = {BE_NBYTES{1&apos;b1}};
                        else mem_wstrb = 0;
                     end

                   write:
                     begin
                        mem_valid = ~mem_ready;
                        mem_wstrb = {BE_NBYTES{1&apos;b1}};
                     end
                   default: /* delay */
                     begin
                        ready = mem_ready;
                     end
                 endcase // case (state)
              end // always @ *

         end // else: !if(LINE2MEM_W &gt; 0)
      end // else: !if(WRITE_POL == WRITE_THROUGH)
   endgenerate
        "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_back_end_minimal</name>
      <circuit>
        <component_o id="IOB_back_end_minimal">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_back_end_minimal"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="acc_ctxt" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="back_pressure" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_accelerator_context" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_back_pressure" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_data_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_accelerator_context" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_back_pressure" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_fail" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_back_end_minimal FE_ADDR_W FE_DATA_W WORD_OFF_W BE_ADDR_W WRITE_POL write_addr write_wdata write_wstrb replace_addr read_addr read_rdata acc_ctxt Mout_addr_ram Mout_Wdata_ram Mout_data_ram_size Mout_accelerator_context M_Rdata_ram M_accelerator_context" IP_COMPONENT="IOB_read_channel_minimal,IOB_write_channel_minimal" VERILOG_PROVIDED="
   localparam BE_DATA_W = BITSIZE_read_rdata;
   localparam BE_NBYTES = BE_DATA_W / 8;

   wire [BE_ADDR_W-1:0]                                                      mem_addr_read,  mem_addr_write;
   wire                                                                      mem_valid_read, mem_valid_write;
   
   reg                                                                       acc_ctxt_reg;
   
   always @(posedge clock) begin
     if(write_valid || replace_valid) begin
        acc_ctxt_reg &lt;= acc_ctxt;
     end
   end

   assign Mout_addr_ram =  mem_valid_read ? mem_addr_read : mem_valid_write ? mem_addr_write : &apos;b0;
   assign Mout_oe_ram = mem_valid_read;
   assign Mout_we_ram = mem_valid_write;
   assign Mout_data_ram_size = BE_DATA_W;
   assign Mout_accelerator_context = acc_ctxt_reg;
   assign M_back_pressure = back_pressure;
   
   
   IOB_read_channel_minimal
     #(
       .FE_ADDR_W(FE_ADDR_W),
       .FE_DATA_W(FE_DATA_W),  
       .WORD_OFF_W(WORD_OFF_W),
       .BITSIZE_replace_addr(BITSIZE_replace_addr),
       .BITSIZE_read_addr(BITSIZE_read_addr),
       .BITSIZE_read_rdata(BITSIZE_read_rdata),
       .BITSIZE_mem_addr(BE_ADDR_W),
       .BITSIZE_mem_rdata(BITSIZE_M_Rdata_ram)
       )
   read_fsm
     (
      .clock(clock),
      .reset(reset),
      .replace_valid (replace_valid),
      .replace_addr (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr (read_addr),
      .read_rdata (read_rdata),
      .mem_addr(mem_addr_read),
      .mem_valid(mem_valid_read),
      .mem_ready(M_data_ready),
      .mem_rdata(M_Rdata_ram)  
      );

   IOB_write_channel_minimal
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .FE_DATA_W (FE_DATA_W),
       .WRITE_POL (WRITE_POL),
       .WORD_OFF_W(WORD_OFF_W),
       .BITSIZE_addr(BITSIZE_write_addr),
       .BITSIZE_wstrb(BITSIZE_write_wstrb),
       .BITSIZE_wdata(BITSIZE_write_wdata),
       .BITSIZE_mem_addr(BE_ADDR_W),
       .BITSIZE_mem_wdata(BITSIZE_Mout_Wdata_ram),
       .BITSIZE_mem_wstrb(BE_NBYTES)
       )
   write_fsm
     (
      .clock(clock),
      .reset(reset),
      .valid (write_valid),
      .addr (write_addr),
      .wstrb (write_wstrb),
      .wdata (write_wdata),
      .ready (write_ready),
      .mem_addr(mem_addr_write),
      .mem_valid(mem_valid_write),
      .mem_ready(M_data_ready),
      .mem_wdata(Mout_Wdata_ram),
      .mem_wstrb(mem_wstrb),
      .write_done(write_done),
      .write_fail(write_fail)
      );
   
        "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_minimal_minimal</name>
      <circuit>
        <component_o id="IOB_cache_minimal_minimal">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_minimal_minimal"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_DATA_W"> 32 </parameter>
          <parameter name="N_WAYS"> 1 </parameter>
          <parameter name="LINE_OFF_W"> 8 </parameter>
          <parameter name="WORD_OFF_W"> 4 </parameter>
          <parameter name="WTBUF_DEPTH_W"> 5 </parameter>
          <parameter name="REP_POLICY"> 2 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_input" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_data_size_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_accelerator_context_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_back_pressure" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_datardy" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_Rdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_accelerator_context" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_back_pressure_in" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_accelerator_context" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_back_pressure" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_accelerator_context" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_back_pressure" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_minimal_minimal FE_ADDR_W BE_ADDR_W BE_DATA_W N_WAYS LINE_OFF_W WORD_OFF_W WTBUF_DEPTH_W REP_POLICY WRITE_POL CTRL_CACHE CTRL_CNT Min_addr_ram Min_Wdata_ram  Min_data_size_ram Min_accelerator_context_in Min_Rdata_ram Min_accelerator_context Mout_addr_ram Mout_Wdata_ram Mout_data_ram_size Mout_accelerator_context M_Rdata_ram M_accelerator_context" IP_COMPONENT="IOB_front_end,IOB_cache_memory,IOB_back_end_minimal" VERILOG_PROVIDED="
   //Cache-Control
   `define CTRL_ADDR_W 4
   //Address-port
   `define WORD_ADDR // Word-addressable, (BE) addr becomes word-addressable (doesn&apos;t receive the byte-offset).

   
   localparam FE_DATA_W = BITSIZE_Min_Wdata_ram;
   localparam NWAY_W = $clog2(N_WAYS);
   localparam FE_NBYTES = FE_DATA_W / 8;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   localparam BE_NBYTES = BE_DATA_W / 8;
   localparam BE_BYTE_W = $clog2(BE_NBYTES);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);

   wire                                         data_valid, data_ready;
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr; 
   wire [FE_DATA_W-1 : 0]                       data_wdata, data_rdata;
   wire [FE_NBYTES-1: 0]                        data_wstrb;
   
   //stored signals
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr_reg; 
   wire [FE_DATA_W-1 : 0]                       data_wdata_reg;
   wire [FE_NBYTES-1: 0]                        data_wstrb_reg;
   wire                                         data_valid_reg;

   //back-end write-channel
   wire                                         write_valid, write_ready;
   wire [FE_ADDR_W-1:FE_BYTE_W + WRITE_POL*WORD_OFF_W] write_addr;
   wire [FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)-1 :0] write_wdata;
   wire [FE_NBYTES-1:0]                                                    write_wstrb;
   wire                                                                    write_fail;
   wire                                                                    write_done;
   
   //back-end read-channel
   wire                                                                    replace_valid, replace;
   wire [FE_ADDR_W -1:BE_BYTE_W+LINE2MEM_W]                                replace_addr; 
   wire                                                                    read_valid;
   wire [LINE2MEM_W-1:0]                                                   read_addr;
   wire [BE_DATA_W-1:0]                                                    read_rdata;
   
   //cache-control
   wire                                                                    ctrl_valid, ctrl_ready;   
   wire [`CTRL_ADDR_W-1:0]                                                 ctrl_addr;
   wire                                                                    wtbuf_full, wtbuf_empty;
   wire                                                                    write_hit, write_miss, read_hit, read_miss;
   wire [CTRL_CACHE*(FE_DATA_W-1):0]                                       ctrl_rdata;
   wire                                                                    invalidate;
   
   wire                                                                    dirty;
   
   reg [BITSIZE_Min_accelerator_context - 1 : 0]                           acc_ctxt;
   reg                                                                     done_input_reg = 1&apos;b0, done_input_next;

   reg                                                                     Min_back_pressure_progress;

   reg                                                                     Min_back_pressure;

   wire [BITSIZE_Min_addr_ram - 1 : 0]                                     addr_reg_next;
   reg [BITSIZE_Min_addr_ram - 1 : 0]                                      addr_reg;

   reg                                                                     done;
   wire [BITSIZE_Min_Rdata_ram - 1 : 0]                                    rdata;

   always @(*) 
   begin
     done_input_next = done_input ? 1&apos;b1 : done_input_reg;
     addr_reg_next = ((Min_oe_ram || Min_we_ram) &amp;&amp; !Min_back_pressure_in) ? Min_addr_ram : addr_reg;
   end

  always @(posedge clock)
  begin
    if(1RESET_VALUE)
    begin
      addr_reg &lt;= 0;
      done_input_reg &lt;= 0;
    end
    else
    begin
      addr_reg &lt;= addr_reg_next;
      done_input_reg &lt;= done_input_next;
    end
  end

   always @(posedge clock) 
   begin
     if((Min_oe_ram || Min_we_ram) &amp;&amp; !data_valid_reg) 
     begin
       acc_ctxt &lt;= Min_accelerator_context_in;
     end
     if(done_input_next) 
     begin
       done &lt;= !dirty;
     end
     Min_back_pressure &lt;= data_valid_reg &amp;&amp; (Min_we_ram || Min_oe_ram) ? Min_back_pressure_progress : 1&apos;b0;
     Min_back_pressure_progress &lt;= data_valid_reg &amp;&amp; !Min_datardy ? 1&apos;b1 : 1&apos;b0;   
   end

   assign Min_accelerator_context = acc_ctxt;
   assign Min_Rdata_ram = Min_datardy ? rdata : 0;

   IOB_front_end
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT(CTRL_CNT),
       .BITSIZE_addr(CTRL_CACHE + FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata(FE_DATA_W),
       .BITSIZE_wstrb(FE_NBYTES),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_data_addr(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_rdata(FE_DATA_W),
       .BITSIZE_data_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_wdata_reg(FE_DATA_W),
       .BITSIZE_data_wstrb_reg(FE_NBYTES),
       .BITSIZE_ctrl_addr(`CTRL_ADDR_W),
       .BITSIZE_ctrl_rdata(CTRL_CACHE * (FE_DATA_W - 1) + 1)
       )
   front_end
     (
      .clock   (clock),
      .reset (!reset),
      //front-end port
      .valid (Min_oe_ram || Min_we_ram),
      .addr  (addr_reg_next[FE_ADDR_W - 1 : FE_BYTE_W]),
      .wdata (Min_Wdata_ram),
      .wstrb ({FE_NBYTES{Min_we_ram}}),
      .rdata (rdata),
      .ready (Min_datardy),
      //cache-memory input signals
      .data_valid (data_valid),
      .data_addr  (data_addr),
      //cache-memory output
      .data_rdata (data_rdata),
      .data_ready (data_ready),
      //stored input signals
      .data_valid_reg (data_valid_reg),
      .data_addr_reg  (data_addr_reg),
      .data_wdata_reg (data_wdata_reg),
      .data_wstrb_reg (data_wstrb_reg),
      //cache-control
      .ctrl_valid (ctrl_valid),
      .ctrl_addr  (ctrl_addr),
      .ctrl_rdata (ctrl_rdata),
      .ctrl_ready (ctrl_ready)
      );

   IOB_cache_memory
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .N_WAYS     (N_WAYS),
       .LINE_OFF_W (LINE_OFF_W),
       .WORD_OFF_W (WORD_OFF_W),
       .REP_POLICY (REP_POLICY),    
       .WTBUF_DEPTH_W (WTBUF_DEPTH_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT  (CTRL_CNT),
       .WRITE_POL (WRITE_POL),
       .BITSIZE_addr(FE_ADDR_W - (BE_BYTE_W + LINE2MEM_W)),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata_reg(FE_DATA_W),
       .BITSIZE_wstrb_reg(FE_NBYTES),
       .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_write_wstrb(FE_NBYTES),
       .BITSIZE_replace_addr(FE_ADDR_W - (BE_BYTE_W+LINE2MEM_W)),
       .BITSIZE_read_addr(LINE2MEM_W),
       .BITSIZE_read_rdata(BE_DATA_W)
       )
   cache_memory
     (
      .clock   (clock),
      .reset (!reset),
      //front-end
      //internal data signals
      .valid (data_valid),
      .addr  (data_addr[FE_ADDR_W-1:BE_BYTE_W + LINE2MEM_W]),
      //.wdata (data_wdata),
      // .wstrb (data_wstrb),
      .rdata (data_rdata),
      .ready (data_ready),
      .dirty_mem (dirty),
      //stored data signals
      .valid_reg (data_valid_reg),   
      .addr_reg  (data_addr_reg),
      .wdata_reg (data_wdata_reg),
      .wstrb_reg (data_wstrb_reg),
      //back-end
      //write-through-buffer (write-channel)
      .write_valid (write_valid),
      .write_addr  (write_addr),
      .write_wdata (write_wdata),
      .write_wstrb (write_wstrb),
      .write_ready (write_ready),
      .write_fail  (write_fail),
      .write_done  (write_done),
      //cache-line replacement (read-channel)
      .replace_valid (replace_valid),
      .replace_addr  (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr  (read_addr),
      .read_rdata (read_rdata),
      //control&apos;s signals
      .wtbuf_empty (wtbuf_empty),
      .wtbuf_full  (wtbuf_full),
      .write_hit   (write_hit),
      .write_miss  (write_miss),
      .read_hit    (read_hit),
      .read_miss   (read_miss),
      .flush(done_input)
      );

   IOB_back_end_minimal
     #(
        .FE_ADDR_W(FE_ADDR_W),
        .FE_DATA_W(FE_DATA_W),
        .WORD_OFF_W(WORD_OFF_W),
        .BE_ADDR_W(BE_ADDR_W),
        .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL * WORD_OFF_W)),
        .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
        .BITSIZE_write_wstrb(FE_NBYTES),
        .BITSIZE_replace_addr(FE_ADDR_W - (FE_BYTE_W + WORD_OFF_W)),
        .BITSIZE_read_addr(LINE2MEM_W),
        .BITSIZE_read_rdata(BE_DATA_W),
        .BITSIZE_acc_ctxt(BITSIZE_Min_accelerator_context_in),
        .BITSIZE_Mout_addr_ram(BE_ADDR_W),
        .BITSIZE_Mout_Wdata_ram(BE_DATA_W),
        .BITSIZE_Mout_data_ram_size(BITSIZE_Min_data_size_ram),
        .BITSIZE_Mout_accelerator_context(BITSIZE_Mout_accelerator_context),
        .BITSIZE_M_Rdata_ram(BE_DATA_W),
        .BITSIZE_M_accelerator_context(BITSIZE_M_accelerator_context)
     ) 
     back_end (
        .clock(clock),
        .reset(!reset),
        .write_valid (write_valid),
        .write_addr  (write_addr),
        .write_wdata (write_wdata),
        .write_wstrb (write_wstrb),
        .write_ready (write_ready),
        .write_fail  (write_fail),
        .write_done  (write_done),
        .replace_valid (replace_valid),
        .replace_addr  (replace_addr),
        .replace (replace),
        .read_valid (read_valid),
        .read_addr  (read_addr),
        .read_rdata (read_rdata),
        .acc_ctxt   (acc_ctxt),
        .back_pressure(Min_back_pressure_in),
        .Mout_oe_ram(Mout_oe_ram),
        .Mout_we_ram(Mout_we_ram),
        .Mout_addr_ram(Mout_addr_ram),
        .Mout_Wdata_ram(Mout_Wdata_ram),
        .Mout_data_ram_size(Mout_data_ram_size),
        .Mout_accelerator_context(Mout_accelerator_context),
        .Mout_back_pressure(Mout_back_pressure),
        .M_data_ready(M_DataRdy),
        .M_Rdata_ram(M_Rdata_ram),
        .M_accelerator_context(M_accelerator_context),
        .M_back_pressure(M_back_pressure)
     );
   
   
   generate
      if (CTRL_CACHE)
        IOB_cache_control
          #(
            .CTRL_CNT   (CTRL_CNT),
            .BITSIZE_rdata(CTRL_CNT * FE_DATA_W)
            )
      cache_control
        (
         .clock   (clock),
         .reset (!reset),
         //control&apos;s signals
         .valid (ctrl_valid),
         .addr  (ctrl_addr),
         //write data
         .wtbuf_full (wtbuf_full),
         .wtbuf_empty (wtbuf_empty), 
         .write_hit  (write_hit),
         .write_miss (write_miss),
         .read_hit   (read_hit),
         .read_miss  (read_miss),
         ////////////
         .rdata (ctrl_rdata),
         .ready (ctrl_ready),
         .invalidate (invalidate)
         );
      else
        begin
           assign ctrl_rdata = 1&apos;bx;
           assign ctrl_ready = 1&apos;bx;
           assign invalidate = 1&apos;b0;
        end // else: !if(CTRL_CACHE)
      
   endgenerate
   `undef CTRL_ADDR_W
   `undef WORD_ADDR
     
"/>
        </component_o>
      </circuit>
    </cell>
  </library>
</technology>
