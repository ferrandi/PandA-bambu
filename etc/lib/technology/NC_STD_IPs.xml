<?xml version="1.0"?>
<technology>
  <library>
    <name>STD</name>
    <cell>
      <name>if_utils</name>
      <circuit>
        <component_o id="if_utils">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="if_utils"/>
          <parameter name="ID">0</parameter>
          <parameter name="BITSIZE_data">32</parameter>
          <NP_functionality LIBRARY="if_utils ID BITSIZE_data" VERILOG_PROVIDED="
import &quot;DPI-C&quot; function int m_read (input byte unsigned id, output logic [4095:0] data, input shortint unsigned bitsize, input ptr_t addr, input byte unsigned shift);
import &quot;DPI-C&quot; function int m_write (input byte unsigned id, input logic [4095:0] data, input shortint unsigned bitsize, input ptr_t addr, input byte unsigned shift);
import &quot;DPI-C&quot; function int m_state (input byte unsigned id, input int data);

function automatic integer log2;
  input integer value;
  `ifdef _SIM_HAVE_CLOG2
    log2 = $clog2(value);
  `else
    automatic integer temp_value = value-1;
    for (log2=0; temp_value &gt; 0; log2=log2+1)
      temp_value = temp_value &gt;&gt; 1;
  `endif
endfunction

localparam BITSIZE_strobe=log2(BITSIZE_data) &gt; 3 ? (1&lt;&lt;(log2(BITSIZE_data)-3)) : 1;

function automatic [BITSIZE_data-1:0] read();
  automatic reg [4095:0] _data = 0;
  m_read(ID, _data, BITSIZE_data, 0, 0);
  return _data[BITSIZE_data-1:0];
endfunction

function automatic [BITSIZE_data-1:0] read_a(input ptr_t addr);
  automatic reg [4095:0] _data = 0;
  m_read(ID, _data, BITSIZE_data, addr, 0);
  return _data[BITSIZE_data-1:0];
endfunction

function automatic [BITSIZE_data-1:0] read_i(output int info);
  automatic reg [4095:0] _data = 0;
  info = m_read(ID, _data, BITSIZE_data, 0, 0);
  return _data[BITSIZE_data-1:0];
endfunction

function automatic [BITSIZE_data-1:0] read_ai(input ptr_t addr, output int info);
  automatic reg [4095:0] _data = 0;
  info = m_read(ID, _data, BITSIZE_data, addr, 0);
  return _data[BITSIZE_data-1:0];
endfunction

function automatic [BITSIZE_data-1:0] pop(output int info);
  automatic reg [4095:0] _data = 0;
  info = m_read(ID, _data, BITSIZE_data, 0, 1);
  return _data[BITSIZE_data-1:0];
endfunction

function automatic int write(input logic [BITSIZE_data-1:0] data);
  automatic reg [4095:0] _data = 0;
  _data[BITSIZE_data-1:0] = data;
  return m_write(ID, _data, BITSIZE_data, 0, 0);
endfunction

function automatic int write_a(input logic [BITSIZE_data-1:0] data, input ptr_t addr);
  automatic reg [4095:0] _data = 0;
  _data[BITSIZE_data-1:0] = data;
  return m_write(ID, _data, BITSIZE_data, addr, 0);
endfunction

function automatic int write_sa(input logic [BITSIZE_data-1:0] data, input shortint unsigned bitsize, input ptr_t addr);
  automatic reg [4095:0] _data = 0;
  _data[BITSIZE_data-1:0] = data;
  return m_write(ID, _data, bitsize, addr, 0);
endfunction

function automatic int write_strobe(input logic [BITSIZE_data-1:0] data, input logic [BITSIZE_strobe-1:0] strobe, input ptr_t addr);
  automatic shortint unsigned size = 0;
  
  while(strobe != 0 &amp;&amp; !strobe[0])
  begin
    addr = addr + 1;
    strobe = strobe &gt;&gt; 1;
  end
  while(strobe[0])
  begin
    size = size + 8;
    strobe = strobe &gt;&gt; 1;
  end
  if(strobe != 0)
  begin
    $display(&quot;Scattered strobe write operations not supported&quot;);
    $finish;
  end

  return write_sa(data, size, addr);
endfunction

function automatic int push(input logic [BITSIZE_data-1:0] data);
  automatic reg [4095:0] _data = 0;
  _data[BITSIZE_data-1:0] = data;
  return m_write(ID, _data, BITSIZE_data, 0, 1);
endfunction

function automatic int state(input int data);
  return m_state(ID, data);
endfunction"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchDUT</name>
      <circuit>
        <component_o id="TestbenchDUT">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchDUT"/>
          <NP_functionality IP_COMPONENT="join_signal,split_signal" VERILOG_GENERATOR="TestbenchDUTModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>MinimalAXI4Adapter</name>
      <circuit>
        <component_o id="MinimalAXI4Adapter">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Giovanni Gozzi &lt;giovanni.gozzi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <parameter name="BURST_TYPE">0</parameter>
          <structural_type_descriptor id_type="MinimalAXI4Adapter"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="IN" is_memory="1" is_slave="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="IN" is_memory="1" is_slave="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_accelerator_context" dir="IN" is_memory="1" is_slave="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_back_pressure" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_back_pressure" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_accelerator_context" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arregion" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_aruser" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awregion" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awuser" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wuser" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality
            LIBRARY="MinimalAXI4Adapter BURST_TYPE Mout_addr_ram Mout_Wdata_ram Mout_data_ram_size Mout_accelerator_context M_Rdata_ram M_accelerator_context m_axi_arid m_axi_araddr m_axi_arlen m_axi_arsize m_axi_arburst m_axi_arcache m_axi_arprot m_axi_arqos m_axi_arregion m_axi_aruser m_axi_rid m_axi_rdata m_axi_rresp m_axi_awid m_axi_awaddr m_axi_awlen m_axi_awsize m_axi_awburst m_axi_awcache m_axi_awprot m_axi_awqos m_axi_awregion m_axi_awuser m_axi_wdata m_axi_wstrb m_axi_wuser m_axi_bid m_axi_bresp" VERILOG_PROVIDED="
assign m_axi_arlen = 0;
assign m_axi_arburst = BURST_TYPE;
assign m_axi_arlock = 0;
assign m_axi_arcache = 0;
assign m_axi_arprot = 0;
assign m_axi_arqos = 0;
assign m_axi_awlen = 0;
assign m_axi_awburst = BURST_TYPE;
assign m_axi_awlock = 0;
assign m_axi_awcache = 0;
assign m_axi_awprot = 0;
assign m_axi_awqos = 0;
assign m_axi_wlast = 1;

`ifndef _SIM_HAVE_CLOG2
  `define CLOG2(x) \
    (x <= 2) ? 1 : \
    (x <= 4) ? 2 : \
    (x <= 8) ? 3 : \
    (x <= 16) ? 4 : \
    (x <= 32) ? 5 : \
    (x <= 64) ? 6 : \
    (x <= 128) ? 7 : \
    -1
`endif

wire [2:0] size_next;

generate
  `ifdef _SIM_HAVE_CLOG2
    assign size_next = $clog2(Mout_data_ram_size >> 3);
  `else
    assign size_next = `CLOG2(Mout_data_ram_size >> 3);
  `endif
endgenerate

reg Mout_back_pressure_reg;
reg double_answer_first;
wire double_answer_first_next;
reg double_answer_second;
wire double_answer_second_next;

reg m_axi_awvalid_reg, m_axi_awvalid_next;
reg m_axi_wvalid_reg, m_axi_wvalid_next;
reg m_axi_arvalid_reg, m_axi_arvalid_next;

always @(*)
begin
  Mout_back_pressure_reg = 0;
  if(m_axi_awvalid_reg &amp;&amp; !m_axi_awready)
  begin
    Mout_back_pressure_reg = 1;
  end
  else if(m_axi_wvalid_reg &amp;&amp; !m_axi_wready)
  begin
    Mout_back_pressure_reg = 1;
  end
  else if(m_axi_arvalid_reg &amp;&amp; !m_axi_arready)
  begin
    Mout_back_pressure_reg = 1;
  end
end

assign Mout_back_pressure = Mout_back_pressure_reg;

reg M_back_pressure_old;
reg [BITSIZE_M_accelerator_context-1:0] m_axi_bid_reg;
wire [BITSIZE_M_accelerator_context-1:0] m_axi_bid_reg_next;
reg [BITSIZE_M_accelerator_context-1:0] m_axi_rid_reg;
wire [BITSIZE_M_accelerator_context-1:0] m_axi_rid_reg_next;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    M_back_pressure_old &lt;= 0;
  end
  else
  begin
    M_back_pressure_old &lt;= M_back_pressure;
  end
end

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_bid_reg &lt;= 0;
    m_axi_rid_reg &lt;= 0;
  end
  else
  begin
    m_axi_bid_reg &lt;= m_axi_bid_reg_next;
    m_axi_rid_reg &lt;= m_axi_rid_reg_next;
  end
end

assign m_axi_bid_reg_next = (m_axi_bvalid &amp;&amp; m_axi_bready) ? m_axi_bid : m_axi_bid_reg;
assign m_axi_rid_reg_next = (m_axi_rvalid &amp;&amp; m_axi_rready) ? m_axi_rid : m_axi_rid_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_awvalid_reg &lt;= 0;
    m_axi_wvalid_reg &lt;= 0;
  end
  else 
  begin
    m_axi_awvalid_reg &lt;= m_axi_awvalid_next;
    m_axi_wvalid_reg &lt;= m_axi_wvalid_next;
  end 
end

always @(*)
begin
  m_axi_awvalid_next = m_axi_awvalid_reg;
  m_axi_wvalid_next = m_axi_wvalid_reg;
  if(Mout_we_ram &amp;&amp; !Mout_back_pressure_reg)
  begin
    m_axi_awvalid_next = 1;
    m_axi_wvalid_next = 1;
  end
  else
  begin
    if(m_axi_awready)
    begin
      m_axi_awvalid_next = 0;  
    end
    if(m_axi_wready)
    begin
      m_axi_wvalid_next = 0;  
    end
  end
end

assign m_axi_wvalid = m_axi_wvalid_reg;
assign m_axi_awvalid = m_axi_awvalid_reg;

reg [BITSIZE_Mout_Wdata_ram-1:0] m_axi_wdata_reg, m_axi_wdata_next;
reg [BITSIZE_m_axi_wstrb-1:0] m_axi_wstrb_reg, m_axi_wstrb_next;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_wdata_reg &lt;= 0;
    m_axi_wstrb_reg &lt;= 0;
  end
  else
  begin
    m_axi_wdata_reg &lt;= m_axi_wdata_next;
    m_axi_wstrb_reg &lt;= m_axi_wstrb_next;
  end
end

always @(*)
begin
  m_axi_wdata_next = m_axi_wdata_reg;
  m_axi_wstrb_next = m_axi_wstrb_reg;
  if(Mout_we_ram &amp;&amp; (!m_axi_wvalid_reg || m_axi_wready))
  begin
    m_axi_wdata_next = Mout_Wdata_ram;
    m_axi_wstrb_next = ((1 << (Mout_data_ram_size >> 3)) - 1);
  end
end

assign m_axi_wdata = m_axi_wdata_reg; 
assign m_axi_wstrb = m_axi_wstrb_reg;

reg [BITSIZE_m_axi_awaddr-1:0] m_axi_awaddr_reg, m_axi_awaddr_next;
reg [BITSIZE_m_axi_awsize-1:0] m_axi_awsize_reg, m_axi_awsize_next;
reg [BITSIZE_m_axi_awid-1:0] m_axi_awid_reg, m_axi_awid_next;


always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_awaddr_reg &lt;= 0;
    m_axi_awid_reg &lt;= 0;
    m_axi_awsize_reg &lt;= 0;
  end
  else
  begin
    m_axi_awaddr_reg &lt;= m_axi_awaddr_next;
    m_axi_awid_reg &lt;= m_axi_awid_next;
    m_axi_awsize_reg &lt;= m_axi_awsize_next;
  end
end

always @(*)
begin
  if(Mout_we_ram &amp;&amp; (!m_axi_awvalid_reg || m_axi_awready))
  begin
    m_axi_awaddr_next = Mout_addr_ram;
    m_axi_awid_next = Mout_accelerator_context;
    m_axi_awsize_next &lt;= size_next;
  end
  else
  begin
    m_axi_awaddr_next = m_axi_awaddr_reg;
    m_axi_awid_next = m_axi_awid_reg;
    m_axi_awsize_next &lt;= m_axi_awsize_reg;
  end
end

assign m_axi_awaddr = m_axi_awaddr_reg;
assign m_axi_awid = m_axi_awid_reg;
assign m_axi_awsize = m_axi_awsize_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_arvalid_reg &lt;= 0;
  end
  else 
  begin
    m_axi_arvalid_reg &lt;= m_axi_arvalid_next;
  end 
end

always @(*)
begin
  m_axi_arvalid_next = m_axi_arvalid_reg;
  if(Mout_oe_ram &amp;&amp; !Mout_back_pressure_reg)
  begin
    m_axi_arvalid_next = 1;
  end
  else if(m_axi_arready)
  begin
    m_axi_arvalid_next = 0;  
  end
end

assign m_axi_arvalid = m_axi_arvalid_reg;

reg [BITSIZE_m_axi_araddr-1:0] m_axi_araddr_reg, m_axi_araddr_next;
reg [BITSIZE_m_axi_arsize-1:0] m_axi_arsize_reg, m_axi_arsize_next;
reg [BITSIZE_m_axi_awid-1:0] m_axi_arid_reg, m_axi_arid_next;


always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_araddr_reg &lt;= 0;
    m_axi_arid_reg &lt;= 0;
    m_axi_arsize_reg &lt;= 0;
  end
  else
  begin
    m_axi_araddr_reg &lt;= m_axi_araddr_next;
    m_axi_arid_reg &lt;= m_axi_arid_next;
    m_axi_arsize_reg &lt;= m_axi_arsize_next;
  end
end

always @(*)
begin
  m_axi_araddr_next = m_axi_araddr_reg;
  m_axi_arid_next = m_axi_arid_reg;
  m_axi_arsize_next = m_axi_arsize_reg;
  if(Mout_oe_ram &amp;&amp; (!m_axi_arvalid_reg || m_axi_arready))
  begin
    m_axi_araddr_next = Mout_addr_ram;
    m_axi_arid_next = Mout_accelerator_context;
    m_axi_arsize_next = size_next;
  end
end

assign m_axi_araddr = m_axi_araddr_reg;
assign m_axi_arid = m_axi_arid_reg;
assign m_axi_arsize = m_axi_arsize_reg;

reg M_DataRdy_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    M_DataRdy_reg &lt;= 0;
  end
  else
  begin
    M_DataRdy_reg &lt;= M_back_pressure || double_answer_first_next || double_answer_second_next;
  end
end

assign M_DataRdy = (m_axi_bvalid &amp;&amp; m_axi_bready) || (m_axi_rvalid &amp;&amp; m_axi_rready) || M_DataRdy_reg;

reg [BITSIZE_M_Rdata_ram-1:0] M_Rdata_ram_reg, M_Rdata_ram_next;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    M_Rdata_ram_reg &lt;= 0;
  end
  else 
  begin
    M_Rdata_ram_reg &lt;= M_Rdata_ram_next;
  end
end

always @(*)
begin
  if(M_back_pressure_old)
  begin
    M_Rdata_ram_next = M_Rdata_ram_reg;
  end
  else
  begin
    M_Rdata_ram_next = m_axi_rdata;
  end
end

assign M_Rdata_ram = M_Rdata_ram_next;

reg m_axi_bready_reg;
reg m_axi_rready_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_rready_reg &lt;= 0;
    m_axi_bready_reg &lt;= 0;
  end
  else if(M_back_pressure)
  begin
    m_axi_rready_reg &lt;= 0;
    m_axi_bready_reg &lt;= 0;
  end
  else if(double_answer_first_next || double_answer_second_next)
  begin
    m_axi_bready_reg &lt;= 0;
    m_axi_rready_reg &lt;= 0;
  end
  else
  begin
    m_axi_rready_reg &lt;= 1;
    m_axi_bready_reg &lt;= 1;
  end
end

assign m_axi_bready = m_axi_bready_reg;
assign m_axi_rready = m_axi_rready_reg;

reg [BITSIZE_M_accelerator_context-1:0] M_accelerator_context_reg, M_accelerator_context_next;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    M_accelerator_context_reg &lt;= 0;
    double_answer_first &lt;= 0;
    double_answer_second &lt;= 0;
  end
  else
  begin
    M_accelerator_context_reg &lt;= M_accelerator_context_next;
    double_answer_first &lt;= double_answer_first_next; 
    double_answer_second &lt;= double_answer_second_next;   
  end
end

assign double_answer_first_next = (M_back_pressure &amp;&amp; (m_axi_rready &amp;&amp; m_axi_rvalid &amp;&amp; m_axi_bready &amp;&amp; m_axi_bvalid)) || (M_back_pressure &amp;&amp; double_answer_first);
assign double_answer_second_next = (m_axi_rready &amp;&amp; m_axi_rvalid &amp;&amp; m_axi_bready &amp;&amp; m_axi_bvalid) || (!double_answer_first_next &amp;&amp; double_answer_first) || (M_back_pressure &amp;&amp; double_answer_second);

always @(*)
begin
  if(M_back_pressure_old)
  begin
    M_accelerator_context_next = M_accelerator_context_reg;
  end
  else if(double_answer_first)
  begin
    M_accelerator_context_next = m_axi_rid_reg;
  end
  else if(double_answer_second)
  begin
    M_accelerator_context_next = m_axi_bid_reg;
  end
  else if(m_axi_rvalid &amp;&amp; m_axi_rready)
  begin
    M_accelerator_context_next = m_axi_rid;
  end
  else if(m_axi_bvalid &amp;&amp; m_axi_bready)
  begin
    M_accelerator_context_next = m_axi_bid;
  end
  else
  begin
    M_accelerator_context_next = 0;
  end
end

assign M_accelerator_context = M_accelerator_context_next;

// synthesis translate_off
always @(posedge clock)
begin
  if(m_axi_bresp != 0 || m_axi_rresp !=0)
  begin
    $display(&quot;ERROR: Sim: Abort incorret AXI answer from slave &quot;);
    $finish;
  end
end
// synthesis translate_on"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>MinimalAXI4AdapterSingleBeat</name>
      <circuit>
        <component_o id="MinimalAXI4AdapterSingleBeat">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Giovanni Gozzi &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="MinimalAXI4AdapterSingleBeat"/>
          <parameter name="BURST_TYPE">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="IN" is_memory="1" is_slave="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="IN" is_memory="1" is_slave="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arregion" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_aruser" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awregion" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awuser" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wuser" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality
            LIBRARY="MinimalAXI4AdapterSingleBeat BURST_TYPE Mout_addr_ram Mout_Wdata_ram Mout_data_ram_size M_Rdata_ram m_axi_arid m_axi_araddr m_axi_arlen m_axi_arsize m_axi_arburst m_axi_arcache m_axi_arprot m_axi_arqos m_axi_arregion m_axi_aruser m_axi_rid m_axi_rdata m_axi_rresp m_axi_awid m_axi_awaddr m_axi_awlen m_axi_awsize m_axi_awburst m_axi_awcache m_axi_awprot m_axi_awqos m_axi_awregion m_axi_awuser m_axi_wdata m_axi_wstrb m_axi_wuser m_axi_bid m_axi_bresp" VERILOG_PROVIDED="
assign m_axi_arlen = 0;
assign m_axi_arburst = BURST_TYPE;
assign m_axi_arlock = 0;
assign m_axi_arcache = 0;
assign m_axi_arprot = 0;
assign m_axi_arqos = 0;
assign m_axi_arregion = 0;
assign m_axi_aruser = 0;
assign m_axi_arid = 0;
assign m_axi_awlen = 0;
assign m_axi_awburst = BURST_TYPE;
assign m_axi_awlock = 0;
assign m_axi_awcache = 0;
assign m_axi_awprot = 0;
assign m_axi_awqos = 0;
assign m_axi_awregion = 0;
assign m_axi_awuser = 0;
assign m_axi_awid = 0;
assign m_axi_wlast = 1;
assign m_axi_wuser = 0;

`ifndef _SIM_HAVE_CLOG2
  `define CLOG2(x) \
    (x <= 2) ? 1 : \
    (x <= 4) ? 2 : \
    (x <= 8) ? 3 : \
    (x <= 16) ? 4 : \
    (x <= 32) ? 5 : \
    (x <= 64) ? 6 : \
    (x <= 128) ? 7 : \
    -1
`endif

wire [2:0] size_next;

generate
  `ifdef _SIM_HAVE_CLOG2
    assign size_next = $clog2(Mout_data_ram_size >> 3);
  `else
    assign size_next = `CLOG2(Mout_data_ram_size >> 3);
  `endif
endgenerate

reg double_answer_second;
wire double_answer_second_next;

reg m_axi_awvalid_reg, m_axi_awvalid_next;
reg m_axi_wvalid_reg, m_axi_wvalid_next;
reg m_axi_arvalid_reg, m_axi_arvalid_next;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_awvalid_reg &lt;= 0;
    m_axi_wvalid_reg &lt;= 0;
  end
  else 
  begin
    m_axi_awvalid_reg &lt;= m_axi_awvalid_next;
    m_axi_wvalid_reg &lt;= m_axi_wvalid_next;
  end 
end

always @(*)
begin
  m_axi_awvalid_next = m_axi_awvalid_reg;
  m_axi_wvalid_next = m_axi_wvalid_reg;
  if(Mout_we_ram)
  begin
    m_axi_awvalid_next = 1;
    m_axi_wvalid_next = 1;
  end
  else
  begin
    if(m_axi_awready)
    begin
      m_axi_awvalid_next = 0;  
    end
    if(m_axi_wready)
    begin
      m_axi_wvalid_next = 0;  
    end
  end
end

assign m_axi_wvalid = m_axi_wvalid_reg;
assign m_axi_awvalid = m_axi_awvalid_reg;

reg [BITSIZE_Mout_Wdata_ram-1:0] m_axi_wdata_reg;
reg [BITSIZE_m_axi_wstrb-1:0] m_axi_wstrb_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_wdata_reg &lt;= 0;
    m_axi_wstrb_reg &lt;= 0;
  end
  else
  begin
    m_axi_wdata_reg &lt;= Mout_Wdata_ram;
    m_axi_wstrb_reg &lt;= ((1 << (Mout_data_ram_size >> 3)) - 1);
  end
end

assign m_axi_wdata = m_axi_wdata_reg; 
assign m_axi_wstrb = m_axi_wstrb_reg;

reg [BITSIZE_m_axi_awaddr-1:0] m_axi_awaddr_reg;
reg [BITSIZE_m_axi_awsize-1:0] m_axi_awsize_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_awaddr_reg &lt;= 0;
    m_axi_awsize_reg &lt;= 0;
  end
  else
  begin
    m_axi_awaddr_reg &lt;= Mout_addr_ram;
    m_axi_awsize_reg &lt;= size_next;
  end
end

assign m_axi_awsize = m_axi_awsize_reg;
assign m_axi_awaddr = m_axi_awaddr_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_arvalid_reg &lt;= 0;
  end
  else 
  begin
    m_axi_arvalid_reg &lt;= m_axi_arvalid_next;
  end 
end

always @(*)
begin
  m_axi_arvalid_next = m_axi_arvalid_reg;
  if(Mout_oe_ram)
  begin
    m_axi_arvalid_next = 1;
  end
  else if(m_axi_arready)
  begin
    m_axi_arvalid_next = 0;  
  end
end

assign m_axi_arvalid = m_axi_arvalid_reg;

reg [BITSIZE_m_axi_araddr-1:0] m_axi_araddr_reg;
reg [BITSIZE_m_axi_arsize-1:0] m_axi_arsize_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_araddr_reg &lt;= 0;
    m_axi_arsize_reg &lt;= 0;
  end
  else
  begin
    m_axi_araddr_reg &lt;= Mout_addr_ram;
    m_axi_arsize_reg &lt;= size_next;
  end
end

assign m_axi_arsize = m_axi_arsize_reg;
assign m_axi_araddr = m_axi_araddr_reg;

reg M_DataRdy_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    M_DataRdy_reg &lt;= 0;
  end
  else
  begin
    M_DataRdy_reg &lt;= double_answer_second_next;
  end
end

assign M_DataRdy = (m_axi_bvalid &amp;&amp; m_axi_bready) || (m_axi_rvalid &amp;&amp; m_axi_rready) || M_DataRdy_reg;
assign M_Rdata_ram = m_axi_rdata;

reg m_axi_bready_reg;
reg m_axi_rready_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    m_axi_rready_reg &lt;= 0;
    m_axi_bready_reg &lt;= 0;
  end
  else if(double_answer_second_next)
  begin
    m_axi_bready_reg &lt;= 0;
    m_axi_rready_reg &lt;= 0;
  end
  else
  begin
    m_axi_rready_reg &lt;= 1;
    m_axi_bready_reg &lt;= 1;
  end
end

assign m_axi_bready = m_axi_bready_reg;
assign m_axi_rready = m_axi_rready_reg;

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    double_answer_second &lt;= 0;
  end
  else
  begin
    double_answer_second &lt;= double_answer_second_next;   
  end
end

assign double_answer_second_next = (m_axi_rready &amp;&amp; m_axi_rvalid &amp;&amp; m_axi_bready &amp;&amp; m_axi_bvalid);

// synthesis translate_off
always @(posedge clock)
begin
  if(m_axi_bresp != 0 || m_axi_rresp !=0)
  begin
    $display(&quot;ERROR: Sim: Abort incorret AXI answer from slave &quot;);
    $finish;
  end
end
// synthesis translate_on
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchFSM</name>
      <circuit>
        <component_o id="TestbenchFSM">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchFSM"/>
          <parameter name="RESFILE">&quot;&quot;results.txt&quot;&quot;</parameter>
          <parameter name="RESET_ACTIVE">0</parameter>
          <parameter name="RESET_CYCLES">1</parameter>
          <parameter name="CLOCK_PERIOD">2.0</parameter>
          <parameter name="MAX_SIM_CYCLES">200000000</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchFSM RESFILE RESET_ACTIVE RESET_CYCLES CLOCK_PERIOD MAX_SIM_CYCLES" VERILOG_PROVIDED="`ifdef VERILATOR
timeunit 1ps;
timeprecision 1ps;
`endif

import &quot;DPI-C&quot; function int unsigned m_next(input int unsigned state);
import &quot;DPI-C&quot; function int m_fini();

localparam [6:0] 
  STATE_READY   =7&apos;b0000001,
  STATE_SETUP   =7&apos;b0000010,
  STATE_RUNNING =7&apos;b0000100,
  STATE_END     =7&apos;b0001000,
  STATE_ERROR   =7&apos;b0010000,
  STATE_ABORT   =7&apos;b0100000,
  SIM_DONE      =7&apos;b1000000;
reg [$bits(STATE_READY)-1:0] state, state_next, state_succ, state_succ_next;

reg rst, rst_next, setup, setup_next, start, start_next;
integer rst_count, rst_count_next;
time over_time;

initial
begin
  // Open file results will be written
  automatic integer res_file;
  res_file = $fopen(RESFILE, &quot;w&quot;);
  if (res_file == 0)
  begin
    $display(&quot;ERROR - Error opening the res_file&quot;);
    $finish;// Terminate
  end
  $fwrite(res_file, &quot;&quot;);
  $fclose(res_file);
  
  state = STATE_READY;
  state_next = STATE_READY;
  state_succ = STATE_READY;
  state_succ_next = STATE_READY;
  rst = RESET_ACTIVE;
  rst_next = RESET_ACTIVE;
  rst_count = RESET_CYCLES - 1;
  rst_count_next = RESET_CYCLES - 1;
  setup = 0;
  setup_next = 0;
  start = 0;
  start_next = 0;
  over_time = 0;
  
  $display(&quot;Results file: %s&quot;, RESFILE);
  $display(&quot;Reset active: %0s&quot;, RESET_ACTIVE ? &quot;HIGH&quot; : &quot;LOW&quot;);
end

assign reset = rst;
assign setup_port = setup;
assign start_port = start;

always @(posedge clock)
begin
  state &lt;= state_next;
  state_succ &lt;= state_succ_next;
  rst &lt;= rst_next;
  rst_count &lt;= rst_count_next;
  setup &lt;= setup_next;
  start &lt;= start_next;
  case(state_next)
  STATE_READY:
    begin
      automatic integer unsigned next_state = m_next(STATE_READY);
      `ifndef NDEBUG
      $display(&quot;Sim: next state: %0d (retval: %0d)&quot;, next_state[$bits(state_succ)-1:0], next_state[15:8]);
      `endif
      state_succ &lt;= next_state[$bits(state_succ)-1:0];
    end
  STATE_SETUP:
    begin
      automatic time start_time = $time + CLOCK_PERIOD;
      automatic time start_cycle = $rtoi(start_time/CLOCK_PERIOD);
      automatic integer res_file;
      if(setup_next)
      begin
        res_file = $fopen(RESFILE, &quot;a&quot;);
        $fwrite(res_file, &quot;%0d|&quot;, start_time);
        $fclose(res_file);
        `ifndef NDEBUG
        $display(&quot;Sim: Argument setup\nSim: Simulation started at cycle %0d&quot;, start_cycle);
        `endif
      end
      over_time &lt;= start_cycle + MAX_SIM_CYCLES;
    end
  STATE_RUNNING:
    begin
      automatic time curr_cycle = $rtoi($time/CLOCK_PERIOD);
      if(curr_cycle >= over_time)
      begin
        automatic integer res_file;
        res_file = $fopen(RESFILE, &quot;a&quot;);
        $fwrite(res_file, &quot;X&quot;);
        $fclose(res_file);
        $display(&quot;Sim: Simulation exceeds %0d cycles&quot;, MAX_SIM_CYCLES);
        $finish;
      end
    end
  SIM_DONE:
    begin
      automatic time curr_time = $time;
      automatic time curr_cycle = $rtoi(curr_time/CLOCK_PERIOD);
      automatic integer res_file;
      res_file = $fopen(RESFILE, &quot;a&quot;);
      $fwrite(res_file, &quot;%0d,&quot;, curr_time);
      $fclose(res_file);
      `ifndef NDEBUG
      $display(&quot;Sim: DUT port writeback\nSim: Simulation ended at cycle %0d&quot;, curr_cycle);
      `endif
    end
  STATE_END:
    begin
      automatic integer r = m_fini();
      automatic integer res_file;
      res_file = $fopen(RESFILE, &quot;a&quot;);
      $fwrite(res_file, &quot;\n%0d\n&quot;, r[15:8]);
      $display(&quot;Sim: Testbench returned: %0d&quot;, r[15:8]);
      $fclose(res_file);
      $finish;
    end
  STATE_ABORT:
    begin
      automatic integer r = m_fini();
      automatic integer res_file;
      res_file = $fopen(RESFILE, &quot;a&quot;);
      $fwrite(res_file, &quot;\nA\n&quot;);
      $display(&quot;Sim: Testbench aborted&quot;);
      $fclose(res_file);
      $finish;
    end
  default:
    begin
    end
  endcase
end

always @(*)
begin
  rst_next = rst;
  rst_count_next = rst_count;
  setup_next = setup;
  start_next = start;
  state_next = state;
  state_succ_next = state_succ;
  case(state)
  STATE_READY:
    begin
      state_next = state_succ;
      if(state_succ == STATE_SETUP)
      begin
        rst_next = RESET_ACTIVE;
        rst_count_next = RESET_CYCLES - 1;
      end
    end
  STATE_SETUP:
    begin
      if(rst_count >= 0)
      begin
        setup_next = rst_count == 0;
        rst_next = rst_count > 0 ? RESET_ACTIVE : ~RESET_ACTIVE;
        rst_count_next = rst_count - 1;
      end
      else
      begin
        state_next = STATE_RUNNING;
        rst_next = ~RESET_ACTIVE;
        setup_next = 0;
        start_next = 1;
      end
    end
  STATE_RUNNING:
    begin
      start_next = 0;
      if(done_port)
      begin
        state_next = SIM_DONE;
      end
    end
  SIM_DONE:
    begin
      // A clock cycle must pass to allow interface modules 
      // finalization operations
      state_next = STATE_READY;
    end
  STATE_END:
    begin
    end
  STATE_ABORT:
    begin
    end
  default:
    begin
      state_next = STATE_READY;
    end
  endcase
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchMEMMinimal</name>
      <circuit>
        <component_o id="TestbenchMEMMinimal">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchMEMMinimal"/>
          <parameter name="index">0</parameter>
          <parameter name="MEM_DELAY_READ">2</parameter>
          <parameter name="MEM_DELAY_WRITE">1</parameter>
          <parameter name="base_addr">1073741824</parameter>
          <parameter name="MEM_DUMP">0</parameter>
          <parameter name="MEM_DUMP_FILE">&quot;&quot;memdump.csv&quot;&quot;</parameter>
          <parameter name="QUEUE_SIZE">4</parameter>
          <parameter name="QUEUE_BITSIZE">2</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Mout_back_pressure" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_oe_ram" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="OUT" is_memory="1" is_slave="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="OUT" is_memory="1" is_slave="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <NP_functionality
            IP_COMPONENT="if_utils"
            LIBRARY="TestbenchMEMMinimal index MEM_DELAY_READ MEM_DELAY_WRITE base_addr MEM_DUMP MEM_DUMP_FILE QUEUE_SIZE QUEUE_BITSIZE M_DataRdy M_Rdata_ram Mout_oe_ram Mout_we_ram Mout_addr_ram Mout_data_ram_size Mout_Wdata_ram Mout_back_pressure Sout_DataRdy Sout_Rdata_ram S_oe_ram S_we_ram S_addr_ram S_data_ram_size S_Wdata_ram"
            VERILOG_PROVIDED="
localparam MEM_DELAY_MAX= MEM_DELAY_READ &gt; MEM_DELAY_WRITE ? MEM_DELAY_READ : MEM_DELAY_WRITE,
  ACTIVE_READ= MEM_DELAY_READ &gt; 1 ? (MEM_DELAY_READ-2) : 0,
  ACTIVE_WRITE= MEM_DELAY_WRITE &gt; 1 ? (MEM_DELAY_WRITE-2) : 0,
  CHANNELS_NUMBER=BITSIZE_Mout_oe_ram,
  BITSIZE_oe=1,
  BITSIZE_we=1,
  BITSIZE_addr=BITSIZE_Mout_addr_ram/CHANNELS_NUMBER,
  BITSIZE_Wsize=BITSIZE_Mout_data_ram_size/CHANNELS_NUMBER,
  BITSIZE_Wdata=BITSIZE_Mout_Wdata_ram/CHANNELS_NUMBER,
  BITSIZE_ready=1,
  BITSIZE_Rdata=BITSIZE_M_Rdata_ram/CHANNELS_NUMBER,
  BITSIZE_item=BITSIZE_Wdata+BITSIZE_Wsize+BITSIZE_addr+BITSIZE_we+BITSIZE_oe,
  OFFSET_oe=0,
  OFFSET_we=OFFSET_oe+BITSIZE_oe,
  OFFSET_addr=OFFSET_we+BITSIZE_we,
  OFFSET_Wsize=OFFSET_addr+BITSIZE_addr,
  OFFSET_Wdata=OFFSET_Wsize+BITSIZE_Wsize,
  BITSIZE_S_Rdata=BITSIZE_Sout_Rdata_ram/BITSIZE_S_oe_ram,
  BITSIZE_S_ready=1,
  SLAVE_VALID=BITSIZE_Mout_oe_ram == BITSIZE_S_oe_ram;

genvar i;
integer dump_file;
wire [BITSIZE_M_DataRdy-1:0] _M_DataRdy, _M_DataRdy_reg;
wire [BITSIZE_M_Rdata_ram-1:0] _M_Rdata_ram;

assign S_oe_ram = Mout_oe_ram;
assign S_we_ram = Mout_we_ram;
assign S_addr_ram = Mout_addr_ram;
assign S_data_ram_size = Mout_data_ram_size;
assign S_Wdata_ram = Mout_Wdata_ram;
assign M_DataRdy = _M_DataRdy;
assign M_Rdata_ram = _M_Rdata_ram;

generate
  if(MEM_DUMP)
  begin
    initial
    begin
      dump_file = $fopen(MEM_DUMP_FILE, &quot;w&quot;);
      $fwrite(dump_file, &quot;Channel,Operation,Address,Bitwidth,Data\n&quot;);
    end

    always@(posedge clock)
    begin
      if(done_port)
      begin
        $fflush(dump_file);
      end
    end
  end
endgenerate

if_utils #(index, BITSIZE_Rdata) m_utils();

generate
  for(i = 0; i &lt; CHANNELS_NUMBER; i = i + 1)
  begin : channel
    wire [MEM_DELAY_MAX*BITSIZE_item-1:0] queue_next;
    wire [BITSIZE_oe-1:0] oe;
    wire [BITSIZE_we-1:0] we;
    ptr_t Waddr, Raddr;
    shortint unsigned Wsize;
    wire [BITSIZE_Wdata-1:0] Wdata;
    reg [BITSIZE_ready-1:0] Wready, Rready, Wready_reg;
    reg [BITSIZE_Rdata-1:0] Rdata;

    reg [QUEUE_BITSIZE-1:0] queue_counter;
    wire [QUEUE_BITSIZE-1:0] queue_counter_next;

    if(MEM_DELAY_WRITE == 1)
    begin
      always@(posedge clock)
      begin
        Wready_reg &lt;= Wready;
      end
    end
    else
    begin
      assign Wready_reg = Wready;
    end
    if(QUEUE_SIZE > 1)
    begin
      assign Mout_back_pressure[i] = queue_counter == 0 ? 0 : (queue_counter - _M_DataRdy_reg[BITSIZE_ready*i+:BITSIZE_ready]) == (QUEUE_SIZE - 1);
    end
    else
    begin
      assign Mout_back_pressure[i] = queue_counter &amp;&amp; !_M_DataRdy_reg[BITSIZE_ready*i+:BITSIZE_ready];
    end

    always @(posedge clock)
    begin
      if(1RESET_VALUE)
      begin
        queue_counter &lt;= 0;
      end
      else
      begin
        queue_counter &lt;= queue_counter_next;
      end
    end

    if(QUEUE_SIZE > 1)
    begin
      assign queue_counter_next = queue_counter + (((Mout_we_ram[i] || Mout_oe_ram[i]) &amp;&amp; !Mout_back_pressure[i] &amp;&amp; base_addr &lt;= Mout_addr_ram[i*BITSIZE_addr +: BITSIZE_addr]) &amp;&amp; (queue_counter == 0 ? 1 : ((queue_counter  - _M_DataRdy_reg[BITSIZE_ready*i+:BITSIZE_ready]) < (QUEUE_SIZE - 1)))) - _M_DataRdy_reg[BITSIZE_ready*i+:BITSIZE_ready];
    end
    else
    begin
      assign queue_counter_next = ((Mout_we_ram[i] || Mout_oe_ram[i]) &amp;&amp; !Mout_back_pressure[i] &amp;&amp; base_addr &lt;= Mout_addr_ram[i*BITSIZE_addr +: BITSIZE_addr]) || (queue_counter &amp;&amp; !_M_DataRdy_reg[BITSIZE_ready*i+:BITSIZE_ready]);
    end

    
    if(MEM_DELAY_MAX &gt; 1)
    begin : requests_queue
      reg [MEM_DELAY_MAX*BITSIZE_item-1:0] queue;
      wire [BITSIZE_item-1:0] new_elem;

            assign new_elem = Mout_back_pressure[i] ? {BITSIZE_item{1&apos;b0}} : 
                        {Mout_Wdata_ram[BITSIZE_Wdata*i+:BITSIZE_Wdata],
                        Mout_data_ram_size[BITSIZE_Wsize*i+:BITSIZE_Wsize],
                        Mout_addr_ram[BITSIZE_addr*i+:BITSIZE_addr],
                        Mout_we_ram[BITSIZE_we*i+:BITSIZE_we],
                        Mout_oe_ram[BITSIZE_oe*i+:BITSIZE_oe]};

            assign queue_next = {queue[(MEM_DELAY_MAX-1)*BITSIZE_item-1:0],new_elem};

      always@(posedge clock)
      begin
        if(1RESET_VALUE)
        begin
          queue &lt;= 0;
        end
        else
        begin
          queue &lt;= queue_next;
        end
      end
    end
    else
    begin
      assign queue_next = {Mout_Wdata_ram[BITSIZE_Wdata*i+:BITSIZE_Wdata], 
        Mout_data_ram_size[BITSIZE_Wsize*i+:BITSIZE_Wsize],
        Mout_addr_ram[BITSIZE_addr*i+:BITSIZE_addr],
        Mout_we_ram[BITSIZE_we*i+:BITSIZE_we],
        Mout_oe_ram[BITSIZE_oe*i+:BITSIZE_oe]};
    end

    assign oe = queue_next[ACTIVE_READ*BITSIZE_item+OFFSET_oe+:BITSIZE_oe];
    assign Raddr = queue_next[ACTIVE_READ*BITSIZE_item+OFFSET_addr+:BITSIZE_addr];
    assign _M_DataRdy[BITSIZE_ready*i+:BITSIZE_ready] = Wready | Rready | (Sout_DataRdy[BITSIZE_S_ready*i*SLAVE_VALID+:BITSIZE_S_ready] === 1&apos;b1);
    assign _M_DataRdy_reg[BITSIZE_ready*i+:BITSIZE_ready] = Wready_reg | Rready; // Used to update at posedge clock of the queue_counter;
    assign _M_Rdata_ram[BITSIZE_Rdata*i+:BITSIZE_Rdata] = Rdata | (Sout_Rdata_ram[BITSIZE_S_Rdata*i*SLAVE_VALID+:BITSIZE_S_Rdata] &amp; {BITSIZE_S_Rdata{Sout_DataRdy[BITSIZE_S_ready*i*SLAVE_VALID+:BITSIZE_S_ready] === 1&apos;b1}});

    if(MEM_DELAY_READ &gt; 1)
    begin : read_channel
      always@(posedge clock)
      begin : read_channel
        automatic reg [BITSIZE_Rdata-1:0] data;
        Rready &lt;= 0;
        Rdata &lt;= 0;
        if(oe &amp;&amp; base_addr &lt;= Raddr)
        begin
          data = m_utils.read_a(Raddr);
          Rdata &lt;= data;
          Rready &lt;= 1;
          if(MEM_DUMP)
          begin
            $fwrite(dump_file, &quot;%0d,r,%0X,%0d,%0X\n&quot;, i, Raddr, BITSIZE_Rdata, data);
          end
        end
      end
    end
    else
    begin
      always@(negedge clock)
      begin : read_channel
        automatic reg [BITSIZE_Rdata-1:0] data;
        Rready &lt;= 0;
        Rdata &lt;= 0;
        if(oe &amp;&amp; base_addr &lt;= Raddr)
        begin
          data = m_utils.read_a(Raddr);
          Rdata &lt;= data;
          Rready &lt;= 1;
          if(MEM_DUMP)
          begin
            $fwrite(dump_file, &quot;%0d,r,%0X,%0d,%0X\n&quot;, i, Raddr, BITSIZE_Rdata, data);
          end
        end
      end
    end

    assign we = queue_next[ACTIVE_WRITE*BITSIZE_item+OFFSET_we+:BITSIZE_we];
    assign Waddr = queue_next[ACTIVE_WRITE*BITSIZE_item+OFFSET_addr+:BITSIZE_addr];
    assign Wsize = {{16-BITSIZE_Wsize{1&apos;b0}}, queue_next[ACTIVE_WRITE*BITSIZE_item+OFFSET_Wsize+:BITSIZE_Wsize]};
    assign Wdata = queue_next[ACTIVE_WRITE*BITSIZE_item+OFFSET_Wdata+:BITSIZE_Wdata];

    if(MEM_DELAY_WRITE &gt; 1)
    begin : write_channel
      always@(posedge clock)
      begin : write_channel
        Wready &lt;= 0;
        if(we &amp;&amp; base_addr &lt;= Waddr)
        begin
          m_utils.write_sa(Wdata, Wsize, Waddr);
          Wready &lt;= 1;
          if(MEM_DUMP)
          begin
            $fwrite(dump_file, &quot;%0d,w,%0X,%0d,%0X\n&quot;, i, Waddr, Wsize, Wdata);
          end
        end
      end
    end
    else
    begin
      always@(negedge clock)
      begin : write_channel
        Wready &lt;= 0;
        if(we &amp;&amp; base_addr &lt;= Waddr)
        begin
          m_utils.write_sa(Wdata, Wsize, Waddr);
          Wready &lt;= 1;
          if(MEM_DUMP)
          begin
            $fwrite(dump_file, &quot;%0d,w,%0X,%0d,%0X\n&quot;, i, Waddr, Wsize, Wdata);
          end
        end
      end
    end

    always @(posedge clock)
    begin
      if (we &amp; oe)
      begin
        $display(&quot;ERROR - Mout_we_ram and Mout_oe_ram both enabled on channel %0d!&quot;, i);
        $finish;
      end
    end
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchMEMWishboneB4</name>
      <circuit>
        <component_o id="TestbenchMEMWishboneB4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchMEMWishboneB4"/>
          <parameter name="index">0</parameter>
          <parameter name="MEM_DELAY_READ">2</parameter>
          <parameter name="MEM_DELAY_WRITE">1</parameter>
          <parameter name="base_addr">1073741824</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="cyc_om" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="stb_om" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_om" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_om" dir="IN" is_memory="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="32"/>
          </port_o>
          <port_o id="dat_om" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="sel_om" dir="IN" is_memory="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_im" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="stall_im" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ack_im" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="cyc_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="stb_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_is" dir="OUT" is_memory="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_is" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="sel_is" dir="OUT" is_memory="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_os" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="stall_os" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ack_os" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality
            IP_COMPONENT="if_utils"
            LIBRARY="TestbenchMEMWishboneB4 index MEM_DELAY_READ MEM_DELAY_WRITE base_addr addr_om dat_om sel_om dat_im addr_is dat_is sel_is dat_os"
            VERILOG_PROVIDED="localparam MEM_DELAY_MAX= MEM_DELAY_READ > MEM_DELAY_WRITE ? MEM_DELAY_READ : MEM_DELAY_WRITE,
  BITSIZE_item=BITSIZE_dat_im+1+1;
reg cyc, stb, we, stall, ack;
reg [BITSIZE_addr_om-1:0] addr;
reg [BITSIZE_dat_om-1:0] Wdata;
reg [7:0] size;
reg [BITSIZE_dat_im-1:0] Rdata;

reg [MEM_DELAY_MAX*BITSIZE_item-1:0] queue, queue_next;

if_utils #(index, BITSIZE_dat_im) m_utils();

initial
begin
  stall = 0;
  ack = 0;
  Rdata = 0;
  queue = 0;
end

assign cyc_is = 0;
assign stb_is = 0;
assign addr_is = 0;
assign dat_is = 0;
assign sel_is = 0;

assign cyc = cyc_om;
assign stb = stb_om;
assign we = we_om;
assign addr = addr_om;
assign Wdata = dat_om;
assign size = sel_om;
assign stall_im = stall; // &amp; cyc
assign ack_im = ack; // &amp; cyc
assign dat_im = Rdata; // &amp; {BITSIZE_dat_im{cyc}};

always @(posedge clock)
begin
  automatic reg w_ack = queue_next[(MEM_DELAY_WRITE-1)*BITSIZE_item] &amp; queue_next[(MEM_DELAY_WRITE-1)*BITSIZE_item+1];
  automatic reg r_ack = queue_next[(MEM_DELAY_READ-1)*BITSIZE_item] &amp; ~queue_next[(MEM_DELAY_READ-1)*BITSIZE_item+1];
  ack &lt;= w_ack | r_ack;
  Rdata &lt;= queue_next[(MEM_DELAY_READ-1)*BITSIZE_item+2 +:BITSIZE_dat_im];
  queue &lt;= queue_next;
end

always @(*)
begin
  queue_next = {queue[(MEM_DELAY_MAX-1)*BITSIZE_item-1:0], {BITSIZE_dat_im{1&apos;b0}}, 1&apos;b0, 1&apos;b0};
  if(cyc &amp; stb)
  begin
    queue_next[1:0] = {we, 1&apos;b1};
  end
end

always @(negedge clock)
begin
  if(queue_next[0])
  begin
    automatic ptr_t ptr_addr = addr;
    if(queue_next[1])
    begin
      m_utils.write_strobe(Wdata, sel_om, ptr_addr);
    end
    else
    begin
      queue_next[BITSIZE_item-1:2] &lt;= m_utils.read_a(ptr_addr);
    end
  end
end
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IF_PORT_IN</name>
      <circuit>
        <component_o id="IF_PORT_IN">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IF_PORT_IN"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="val_port" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality IP_COMPONENT="if_utils" LIBRARY="IF_PORT_IN index val_port" VERILOG_PROVIDED="if_utils #(index, BITSIZE_val_port) m_utils();
reg [BITSIZE_val_port-1:0] val;
wire [BITSIZE_val_port-1:0] val_next;

initial val = 0;

assign val_port = val;
assign val_next = val;

always @(posedge clock) 
begin
  val &lt;= val_next;
  if(setup_port)
  begin
    val &lt;= m_utils.read();
  end
end
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchArgMapMinimal</name>
      <circuit>
        <component_o id="TestbenchArgMapMinimal">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchArgMapMinimal"/>
          <parameter name="index">0</parameter>
          <parameter name="tgt_addr">1024</parameter>
          <parameter name="bitsize">32</parameter>
          <parameter name="PIPELINED">1</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="i_start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="OUT" is_memory="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="OUT" is_memory="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality IP_COMPONENT="if_utils" LIBRARY="TestbenchArgMapMinimal index tgt_addr bitsize PIPELINED S_oe_ram S_we_ram S_addr_ram S_Wdata_ram S_data_ram_size Sout_Rdata_ram Sout_DataRdy" VERILOG_PROVIDED="localparam HOLD=PIPELINED ? 1&apos;b0 : 1&apos;b1,
  CHANNELS_NUMBER=BITSIZE_S_we_ram,
  BITSIZE_we=1,
  BITSIZE_addr=BITSIZE_S_addr_ram/CHANNELS_NUMBER,
  BITSIZE_Wsize=BITSIZE_S_data_ram_size/CHANNELS_NUMBER,
  BITSIZE_Wdata=BITSIZE_S_Wdata_ram/CHANNELS_NUMBER,
  BITSIZE_ready=1;
reg [bitsize-1:0] val, val_next;
reg we, we_next, waiting, waiting_next, start, start_next;
reg [BITSIZE_addr-1:0] addr, addr_next;
reg [BITSIZE_Wdata-1:0] data, data_next;
reg [BITSIZE_Wsize-1:0] data_size, data_size_next;
wire rdy;

if_utils #(index, bitsize) m_utils();

assign rdy = Sout_DataRdy[0];

assign S_oe_ram = {BITSIZE_S_oe_ram{1&apos;b0}};
assign S_we_ram = {{BITSIZE_S_we_ram-BITSIZE_we{1&apos;b0}}, we_next};
assign S_addr_ram = {{BITSIZE_S_addr_ram-BITSIZE_addr{1&apos;b0}}, addr_next};
assign S_Wdata_ram = {{BITSIZE_S_Wdata_ram-BITSIZE_Wdata{1&apos;b0}}, data_next};
assign S_data_ram_size = {{BITSIZE_S_data_ram_size-BITSIZE_Wsize{1&apos;b0}}, data_size_next};
assign start_port = start;

always @(posedge clock) 
begin
  val &lt;= val_next;
  we &lt;= we_next;
  addr &lt;= addr_next;
  data &lt;= data_next;
  data_size &lt;= data_size_next;
  waiting &lt;= waiting_next;
  start &lt;= start_next;
  if(1RESET_VALUE)
  begin
    val &lt;= 0;
    we &lt;= 0;
    addr &lt;= 0;
    data &lt;= 0;
    data_size &lt;= 0;
    waiting &lt;= 0;
    start &lt;= 0;
  end
  else if(setup_port)
  begin
    val &lt;= m_utils.read();
  end
end

always @(*)
begin
  val_next = val;
  we_next = we &amp; HOLD &amp; waiting &amp; ~rdy;
  addr_next = addr &amp; {BITSIZE_addr{HOLD &amp; waiting &amp; ~rdy}};
  data_next = data &amp; {BITSIZE_Wdata{HOLD &amp; waiting &amp; ~rdy}};
  data_size_next = data_size &amp; {BITSIZE_Wsize{HOLD &amp; waiting &amp; ~rdy}};
  waiting_next = waiting &amp; ~rdy;
  start_next = waiting &amp; rdy;
  if(i_start_port)
  begin
    we_next = 1;
    addr_next = tgt_addr;
    data_next = {{BITSIZE_Wdata-bitsize{1&apos;b0}}, val};
    data_size_next = bitsize;
    waiting_next = ~rdy;
    start_next = rdy;
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchReturnMapMinimal</name>
      <circuit>
        <component_o id="TestbenchReturnMapMinimal">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchReturnMapMinimal"/>
          <parameter name="index">0</parameter>
          <parameter name="tgt_addr">1024</parameter>
          <parameter name="bitsize">32</parameter>
          <parameter name="PIPELINED">1</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="i_start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="i_done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="OUT" is_memory="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="OUT" is_memory="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality IP_COMPONENT="if_utils" LIBRARY="TestbenchReturnMapMinimal index tgt_addr bitsize PIPELINED S_oe_ram S_we_ram S_addr_ram S_Wdata_ram S_data_ram_size Sout_Rdata_ram Sout_DataRdy" VERILOG_PROVIDED="localparam HOLD=PIPELINED ? 1&apos;b0 : 1&apos;b1,
  CHANNELS_NUMBER=BITSIZE_S_oe_ram,
  BITSIZE_oe=1,
  BITSIZE_addr=BITSIZE_S_addr_ram/CHANNELS_NUMBER,
  BITSIZE_ready=1,
  BITSIZE_Rdata=BITSIZE_Sout_Rdata_ram/CHANNELS_NUMBER;
reg oe, oe_next, waiting, waiting_next, done, done_next;
reg [BITSIZE_addr-1:0] addr, addr_next;
wire rdy;

if_utils #(index, bitsize) m_utils();

assign rdy = Sout_DataRdy[0];

assign S_oe_ram = {BITSIZE_S_oe_ram-BITSIZE_oe{1&apos;b0}, oe_next};
assign S_we_ram = {BITSIZE_S_we_ram{1&apos;b0}};
assign S_addr_ram = {{BITSIZE_S_addr_ram-BITSIZE_addr{1&apos;b0}}, addr_next};
assign S_Wdata_ram = {BITSIZE_S_Wdata_ram{1&apos;b0}};
assign S_data_ram_size = {BITSIZE_S_data_ram_size{1&apos;b0}};
assign start_port = i_start_port;
assign done_port = done;

always @(posedge clock) 
begin
  oe &lt;= oe_next;
  addr &lt;= addr_next;
  waiting &lt;= waiting_next;
  done &lt;= done_next;
  if(1RESET_VALUE)
  begin
    oe &lt;= 0;
    addr &lt;= 0;
    waiting &lt;= 0;
    done &lt;= 0;
  end
  else if(done_next)
  begin
    m_utils.write(Sout_Rdata_ram[BITSIZE_Rdata-1:0]);
  end
end

always @(*)
begin
  oe_next = oe &amp; HOLD &amp; waiting &amp; ~rdy;
  addr_next = addr &amp; {BITSIZE_addr{HOLD &amp; waiting &amp; ~rdy}};
  waiting_next = waiting &amp; ~rdy;
  done_next = waiting &amp; rdy;
  if(i_done_port)
  begin
    oe_next = 1;
    addr_next = tgt_addr;
    waiting_next = ~rdy;
    done_next = rdy;
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchStartMapMinimal</name>
      <circuit>
        <component_o id="TestbenchStartMapMinimal">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchStartMapMinimal"/>
          <parameter name="tgt_addr">1024</parameter>
          <parameter name="PIPELINED">1</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="i_start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="OUT" is_memory="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="OUT" is_memory="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchStartMapMinimal tgt_addr PIPELINED S_oe_ram S_we_ram S_addr_ram S_Wdata_ram S_data_ram_size Sout_Rdata_ram Sout_DataRdy" VERILOG_PROVIDED="localparam HOLD=PIPELINED ? 1&apos;b0 : 1&apos;b1,
  CHANNELS_NUMBER=BITSIZE_S_we_ram,
  BITSIZE_we=1,
  BITSIZE_addr=BITSIZE_S_addr_ram/CHANNELS_NUMBER,
  BITSIZE_Wsize=BITSIZE_S_data_ram_size/CHANNELS_NUMBER,
  BITSIZE_Wdata=BITSIZE_S_Wdata_ram/CHANNELS_NUMBER,
  BITSIZE_ready=1;
reg we, we_next, waiting, waiting_next, start, start_next;
reg [BITSIZE_addr-1:0] addr, addr_next;
reg [BITSIZE_Wdata-1:0] data, data_next;
reg [BITSIZE_Wsize-1:0] data_size, data_size_next;
wire rdy;

assign rdy = Sout_DataRdy[0];

assign S_oe_ram = {BITSIZE_S_oe_ram{1&apos;b0}};
assign S_we_ram = {{BITSIZE_S_we_ram-BITSIZE_we{1&apos;b0}}, we_next};
assign S_addr_ram = {{BITSIZE_S_addr_ram-BITSIZE_addr{1&apos;b0}}, addr_next};
assign S_Wdata_ram = {{BITSIZE_S_Wdata_ram-BITSIZE_Wdata{1&apos;b0}}, data_next};
assign S_data_ram_size = {{BITSIZE_S_data_ram_size-BITSIZE_Wsize{1&apos;b0}}, data_size_next};
assign start_port = start;

always @(posedge clock) 
begin
  we &lt;= we_next;
  addr &lt;= addr_next;
  data &lt;= data_next;
  data_size &lt;= data_size_next;
  waiting &lt;= waiting_next;
  start &lt;= start_next;
  if(1RESET_VALUE)
  begin
    we &lt;= 0;
    addr &lt;= 0;
    data &lt;= 0;
    data_size &lt;= 0;
    waiting &lt;= 0;
    start &lt;= 0;
  end
end

always @(*)
begin
  we_next = we &amp; HOLD &amp; waiting &amp; ~rdy;
  addr_next = addr &amp; {BITSIZE_addr{HOLD &amp; waiting &amp; ~rdy}};
  data_next = data &amp; {BITSIZE_Wdata{HOLD &amp; waiting &amp; ~rdy}};
  data_size_next = data_size &amp; {BITSIZE_Wsize{HOLD &amp; waiting &amp; ~rdy}};
  waiting_next = waiting &amp; ~rdy;
  start_next = waiting &amp; rdy;
  if(i_start_port)
  begin
    we_next = 1;
    addr_next = tgt_addr;
    data_next = 1;
    data_size_next = 1;
    waiting_next = ~rdy;
    start_next = rdy;
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchArgMapWishboneB4</name>
      <circuit>
        <component_o id="TestbenchArgMapWishboneB4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchArgMapWishboneB4"/>
          <parameter name="index">0</parameter>
          <parameter name="tgt_addr">1024</parameter>
          <parameter name="bitsize">32</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="i_start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="cyc_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="stb_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_is" dir="OUT" is_memory="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_is" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="sel_is" dir="OUT" is_memory="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_os" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="stall_os" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ack_os" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality IP_COMPONENT="if_utils" LIBRARY="TestbenchArgMapWishboneB4 index tgt_addr bitsize addr_is dat_is sel_is dat_os" VERILOG_PROVIDED="localparam bytesize=((bitsize&gt;&gt;3)&lt;&lt;3) == bitsize ? (bitsize&gt;&gt;3) : ((bitsize&gt;&gt;3) + 1);
reg [bitsize-1:0] val;
wire [bitsize-1:0] val_next;
reg cyc, cyc_next, stb, stb_next, we, we_next, stall, ack, start;
reg [BITSIZE_addr_is-1:0] addr, addr_next;
reg [BITSIZE_dat_is-1:0] data, data_next;
reg [BITSIZE_sel_is-1:0] sel, sel_next;

if_utils #(index, bitsize) m_utils();

initial
begin
  val = 0;
  cyc = 0;
  cyc_next = 0;
  stb = 0;
  stb_next = 0;
  we = 0;
  we_next = 0;
  addr = 0;
  addr_next = 0;
  data = 0;
  data_next = 0;
  sel = 0;
  sel_next = 0;
  start = 0;
end

assign cyc_is = cyc_next;
assign stb_is = stb_next;
assign we_is = we_next;
assign addr_is = addr_next;
assign dat_is = data_next;
assign sel_is = sel_next;
assign stall = ~ack_os; // TODO: this should be stall_os
assign ack = ack_os;
assign start_port = start;

always @(posedge clock) 
begin
  automatic reg active_tx = cyc_next &amp; ~ack;
  automatic reg wait_tx = active_tx &amp; stall;
  val &lt;= val_next;
  cyc &lt;= active_tx;
  stb &lt;= stb_next &amp; wait_tx;
  we &lt;= we_next &amp; wait_tx;
  addr &lt;= addr_next &amp; {BITSIZE_addr_is{wait_tx}};
  data &lt;= data_next &amp; {BITSIZE_dat_is{wait_tx}};
  sel &lt;= sel_next &amp; {BITSIZE_sel_is{wait_tx}};
  start &lt;= ack &amp; cyc_next;
  if(setup_port)
  begin
    val &lt;= m_utils.read();
  end
end

assign val_next = val;

always @(*)
begin
  cyc_next = cyc;
  stb_next = stb;
  we_next = we;
  addr_next = addr;
  data_next = data;
  sel_next = sel;
  if(i_start_port)
  begin
    cyc_next = 1;
    stb_next = 1;
    we_next = 1;
    addr_next = tgt_addr;
    data_next[bitsize-1:0] = val;
    sel_next = {bytesize{1&apos;b1}};
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchReturnMapWishboneB4</name>
      <circuit>
        <component_o id="TestbenchReturnMapWishboneB4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchReturnMapWishboneB4"/>
          <parameter name="index">0</parameter>
          <parameter name="tgt_addr">1024</parameter>
          <parameter name="bitsize">32</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="i_start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="i_done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="cyc_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="stb_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_is" dir="OUT" is_memory="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_is" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="sel_is" dir="OUT" is_memory="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_os" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="stall_os" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ack_os" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality IP_COMPONENT="if_utils" LIBRARY="TestbenchReturnMapWishboneB4 index tgt_addr bitsize addr_is dat_is sel_is dat_os" VERILOG_PROVIDED="localparam bytesize=((bitsize&gt;&gt;3)&lt;&lt;3) == bitsize ? (bitsize&gt;&gt;3) : ((bitsize&gt;&gt;3) + 1);
reg cyc, cyc_next, stb, stb_next, stall, ack, done;
reg [BITSIZE_addr_is-1:0] addr, addr_next;

if_utils #(index, bitsize) m_utils();

initial
begin
  cyc = 0;
  cyc_next = 0;
  stb = 0;
  stb_next = 0;
  addr = 0;
  addr_next = 0;
  done = 0;
end

assign cyc_is = cyc_next;
assign stb_is = stb_next;
assign we_is = 0;
assign addr_is = addr_next;
assign dat_is = 0;
assign sel_is = 0;
assign stall = ~ack_os; // TODO: this should be stall_os
assign ack = ack_os;
assign start_port = i_start_port;
assign done_port = done;

always @(posedge clock) 
begin
  automatic reg active_tx = cyc_next &amp; ~ack;
  automatic reg wait_tx = active_tx &amp; stall;
  cyc &lt;= active_tx;
  stb &lt;= stb_next &amp; wait_tx;
  addr &lt;= addr_next &amp; {BITSIZE_addr_is{wait_tx}};
  done &lt;= ack &amp; cyc_next;
  if(ack &amp; cyc_next)
  begin
    m_utils.write(dat_os);
  end
end

always @(*)
begin
  cyc_next = cyc;
  stb_next = stb;
  addr_next = addr;
  if(i_done_port)
  begin
    cyc_next = 1;
    stb_next = 1;
    addr_next = tgt_addr;
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchStartMapWishboneB4</name>
      <circuit>
        <component_o id="TestbenchStartMapWishboneB4">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchStartMapWishboneB4"/>
          <parameter name="tgt_addr">1024</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="i_start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="cyc_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="stb_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_is" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_is" dir="OUT" is_memory="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_is" dir="OUT" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="sel_is" dir="OUT" is_memory="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_os" dir="IN" is_memory="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="stall_os" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ack_os" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchStartMapWishboneB4 tgt_addr addr_is dat_is sel_is dat_os" VERILOG_PROVIDED="localparam bytesize=1;
reg cyc, cyc_next, stb, stb_next, we, we_next, stall, ack, start;
reg [BITSIZE_addr_is-1:0] addr, addr_next;
reg [BITSIZE_dat_is-1:0] data, data_next;
reg [BITSIZE_sel_is-1:0] sel, sel_next;

initial
begin
  cyc = 0;
  cyc_next = 0;
  stb = 0;
  stb_next = 0;
  we = 0;
  we_next = 0;
  addr = 0;
  addr_next = 0;
  data = 0;
  data_next = 0;
  sel = 0;
  sel_next = 0;
  start = 0;
end

assign cyc_is = cyc_next;
assign stb_is = stb_next;
assign we_is = we_next;
assign addr_is = addr_next;
assign dat_is = data_next;
assign sel_is = sel_next;
assign stall = ~ack_os; // TODO: this should be stall_os
assign ack = ack_os;
assign start_port = start;

always @(posedge clock) 
begin
  automatic reg active_tx = cyc_next &amp; ~ack;
  automatic reg wait_tx = active_tx &amp; stall;
  cyc &lt;= active_tx;
  stb &lt;= stb_next &amp; wait_tx;
  we &lt;= we_next &amp; wait_tx;
  addr &lt;= addr_next &amp; {BITSIZE_addr_is{wait_tx}};
  data &lt;= data_next &amp; {BITSIZE_dat_is{wait_tx}};
  sel &lt;= sel_next &amp; {BITSIZE_sel_is{wait_tx}};
  start &lt;= ack &amp; cyc_next;
end

always @(*)
begin
  cyc_next = cyc;
  stb_next = stb;
  we_next = we;
  addr_next = addr;
  data_next = data;
  sel_next = sel;
  if(i_start_port)
  begin
    cyc_next = 1;
    stb_next = 1;
    we_next = 1;
    addr_next = tgt_addr;
    data_next = 1;
    sel_next = {bytesize{1&apos;b1}};
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IF_PORT_OUT</name>
      <circuit>
        <component_o id="IF_PORT_OUT">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IF_PORT_OUT"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="val_port" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality
            IP_COMPONENT="if_utils"
            LIBRARY="IF_PORT_OUT index val_port"
            VERILOG_PROVIDED="if_utils #(index, BITSIZE_val_port) m_utils();

always @(posedge clock)
begin
  if(done_port)
  begin
    m_utils.write(val_port);
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchArrayImpl</name>
      <circuit>
        <component_o id="TestbenchArrayImpl">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchArrayImpl"/>
          <parameter name="index">0</parameter>
          <parameter name="WRITE_DELAY">1</parameter>
          <parameter name="READ_DELAY">2</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="ce" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="we" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="address" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="d" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="q" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality IP_COMPONENT="if_utils" LIBRARY="TestbenchArrayImpl index WRITE_DELAY READ_DELAY ce we address d q" VERILOG_PROVIDED="
localparam CHANNELS_NUMBER=PORTSIZE_ce,
  BITSIZE_dq=BITSIZE_d &gt; BITSIZE_q ? BITSIZE_d : BITSIZE_q,
  BITSIZE_item=BITSIZE_d+BITSIZE_address+BITSIZE_ce+BITSIZE_we,
  BITSIZE_chunk=BITSIZE_item*CHANNELS_NUMBER,
  OFFSET_ce=0,
  OFFSET_we=OFFSET_ce+BITSIZE_ce,
  OFFSET_address=OFFSET_we+BITSIZE_we,
  OFFSET_data=OFFSET_address+BITSIZE_address,
  LAST_READ_item=READ_DELAY &gt; 1 ? READ_DELAY-2 : 0,
  LAST_READ_size=READ_DELAY &gt; 1 ? READ_DELAY-1 : 1;
genvar i;

if_utils #(index, BITSIZE_dq) m_utils();

wire [BITSIZE_chunk-1:0] current;
reg [BITSIZE_chunk*WRITE_DELAY-1:0] queue = 0, queue_next = 0;
reg [CHANNELS_NUMBER*BITSIZE_q*LAST_READ_size-1:0] _q_next = 0;
reg [CHANNELS_NUMBER*BITSIZE_q*LAST_READ_size-1:0] _q = 0;

generate
  for(i = 0; i &lt; CHANNELS_NUMBER; i = i + 1)
  begin
    assign current[BITSIZE_item*i+:BITSIZE_item] = {d[BITSIZE_d*i+:BITSIZE_d], address[BITSIZE_address*i+:BITSIZE_address], we[BITSIZE_we*i+:BITSIZE_we], ce[BITSIZE_ce*i+:BITSIZE_ce]};
    assign q[BITSIZE_q*i+:BITSIZE_q] = _q[LAST_READ_item*BITSIZE_q*CHANNELS_NUMBER+BITSIZE_q*i+:BITSIZE_q];
  end
endgenerate

generate
  if(WRITE_DELAY &gt; 1)
  begin
    always @(posedge clock)
    begin
      if(setup_port)
      begin
        queue[BITSIZE_chunk*WRITE_DELAY-1:BITSIZE_chunk] &lt;= 0;
        queue[BITSIZE_chunk-1:0] &lt;= current;
      end
      else
      begin
        queue[BITSIZE_chunk*WRITE_DELAY-1:BITSIZE_chunk] &lt;= queue_next[BITSIZE_chunk*WRITE_DELAY-1:BITSIZE_chunk];
        queue[BITSIZE_chunk-1:0] &lt;= current;
      end
    end
    always @(*)
    begin
      queue_next[BITSIZE_chunk*WRITE_DELAY-1:BITSIZE_chunk] = queue[BITSIZE_chunk*(WRITE_DELAY-1)-1:0];
      queue_next[BITSIZE_chunk-1:0] = 0;
    end
  end
endgenerate

generate
  for(i = 0; i &lt; CHANNELS_NUMBER; i = i + 1)
  begin : write_port
    if(WRITE_DELAY &gt; 1)
    begin
      always @(posedge clock)
      begin
        automatic ptr_t address = queue_next[(WRITE_DELAY-1)*BITSIZE_chunk+BITSIZE_item*i+OFFSET_address+:BITSIZE_address];
        automatic reg [BITSIZE_d-1:0] data = queue_next[(WRITE_DELAY-1)*BITSIZE_chunk+BITSIZE_item*i+OFFSET_data+:BITSIZE_d];
        if(queue_next[(WRITE_DELAY-1)*BITSIZE_chunk+BITSIZE_item*i+OFFSET_ce+:BITSIZE_ce] === 1&apos;b1
          &amp;&amp; queue_next[(WRITE_DELAY-1)*BITSIZE_chunk+BITSIZE_item*i+OFFSET_we+:BITSIZE_we] === 1&apos;b1)
        begin
          m_utils.write_a(data, address);
        end
      end
    end
    else
    begin
      always @(posedge clock)
      begin
        automatic ptr_t address = current[BITSIZE_item*i+OFFSET_address+:BITSIZE_address];
        automatic reg [BITSIZE_d-1:0] data = current[BITSIZE_item*i+OFFSET_data+BITSIZE_d-1:BITSIZE_item*i+OFFSET_data];
        if(current[BITSIZE_item*i+OFFSET_ce+:BITSIZE_ce] === 1&apos;b1 &amp;&amp; current[BITSIZE_item*i+OFFSET_we+:BITSIZE_we] === 1&apos;b1)
        begin
          m_utils.write_a(data, address);
        end
      end
    end
  end
endgenerate

generate
  if(READ_DELAY &gt; 2)
  begin : shift_output_queue1
    always @(*)
    begin
      _q_next[(READ_DELAY-1)*CHANNELS_NUMBER*BITSIZE_q-1:BITSIZE_q*CHANNELS_NUMBER] = _q[LAST_READ_item*CHANNELS_NUMBER*BITSIZE_q-1:0];
    end
  end
endgenerate
generate
  if(READ_DELAY &gt; 2)
  begin : shift_output_queue2
    always @(posedge clock)
    begin
      _q[(READ_DELAY-1)*CHANNELS_NUMBER*BITSIZE_q-1:BITSIZE_q*CHANNELS_NUMBER] &lt;= _q_next[(READ_DELAY-1)*CHANNELS_NUMBER*BITSIZE_q-1:BITSIZE_q*CHANNELS_NUMBER];
    end
  end
endgenerate
generate
  for(i = 0; i &lt; CHANNELS_NUMBER; i = i + 1)
  begin : read_port
    if(READ_DELAY &gt; 1)
    begin
      always @(posedge clock)
      begin
        if(current[BITSIZE_item*i+OFFSET_ce+:BITSIZE_ce] === 1&apos;b1
            &amp;&amp; current[BITSIZE_item*i+OFFSET_we+:BITSIZE_we] === 1&apos;b0)
        begin
          automatic ptr_t address = current[BITSIZE_item*i+OFFSET_address+:BITSIZE_address];
          _q[BITSIZE_q*i+:BITSIZE_q] &lt;= m_utils.read_a(address);
        end
        else
        begin
          _q[BITSIZE_q*i+:BITSIZE_q] &lt;= 0;
        end
      end
    end
    else
    begin
      always @(*)
      begin
        if(current[BITSIZE_item*i+OFFSET_ce+:BITSIZE_ce] === 1&apos;b1 &amp;&amp; current[BITSIZE_item*i+OFFSET_we+:BITSIZE_we] === 1&apos;b0)
        begin
          automatic ptr_t address = current[BITSIZE_item*i+OFFSET_address+:BITSIZE_address];
          _q[BITSIZE_q*i+:BITSIZE_q] = m_utils.read_a(address);
        end
      end
    end
  end
endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchArray</name>
      <circuit>
        <component_o id="TestbenchArray">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchArray"/>
          <parameter name="index">0</parameter>
          <parameter name="WRITE_DELAY">1</parameter>
          <parameter name="READ_DELAY">2</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality IP_COMPONENT="TestbenchArrayImpl" LIBRARY="TestbenchArray index WRITE_DELAY READ_DELAY" VERILOG_GENERATOR="TestbenchArrayModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchAcknowledge</name>
      <circuit>
        <component_o id="TestbenchAcknowledge">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchAcknowledge"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="tb_done_port" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchAcknowledge index" VERILOG_GENERATOR="TestbenchAcknowledgeModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchValid</name>
      <circuit>
        <component_o id="TestbenchValid">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchValid"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="tb_done_port" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchValid index" VERILOG_GENERATOR="TestbenchValidModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchOvalid</name>
      <circuit>
        <component_o id="TestbenchOvalid">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchOvalid"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="tb_done_port" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchOvalid index" VERILOG_GENERATOR="TestbenchOvalidModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchHandshake</name>
      <circuit>
        <component_o id="TestbenchHandshake">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchHandshake"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="tb_done_port" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchHandshake index" VERILOG_GENERATOR="TestbenchHandshakeModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchAxis</name>
      <circuit>
        <component_o id="TestbenchAxis">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchAxis"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="tb_done_port" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchAxis index" VERILOG_GENERATOR="TestbenchAxisModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchFifoRead</name>
      <circuit>
        <component_o id="TestbenchFifoRead">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchFifoRead"/>
          <parameter name="index">0</parameter>
          <parameter name="CHECK_ACK">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="empty_n" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="dout" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality IP_COMPONENT="if_utils" LIBRARY="TestbenchFifoRead index CHECK_ACK dout" VERILOG_PROVIDED="
if_utils #(index, BITSIZE_dout) m_utils();

reg enable, enable_next;
reg _empty_n, _empty_n_next;
reg _empty_n_succ, _empty_n_succ_next;
reg [BITSIZE_dout-1:0] val, val_next;

initial
begin
  enable = 0;
  _empty_n = 0;
  _empty_n_succ = 0;
  val = 0;
end

assign dout = val;
assign empty_n = _empty_n;

always @(posedge clock)
begin
  enable &lt;= enable_next;
  _empty_n &lt;= _empty_n_next;
  _empty_n_succ &lt;= _empty_n_succ_next;
  val &lt;= val_next;
  if(setup_port)
  begin
    automatic int data = 0;
    val &lt;= m_utils.read_i(data);
    _empty_n &lt;= data &gt;= 0;
    _empty_n_succ &lt;= data &gt; 0;
    enable &lt;= 1&apos;b1;
  end
  if((enable_next | done_port) &amp; read)
  begin
    automatic int data = 0;
    if(~_empty_n_next)
    begin
      $display(&quot;Too many read requests on interface %0d&quot;, index);
      $finish;
    end
    if(_empty_n_succ_next)
    begin
      val &lt;= m_utils.pop(data);
    end
    _empty_n &lt;= _empty_n_succ_next;
    _empty_n_succ &lt;= data &gt; 0;
  end
end

always @(*)
begin
  enable_next = enable &amp; ~done_port;
  _empty_n_next = _empty_n;
  _empty_n_succ_next = _empty_n_succ;
  val_next = val;
end

generate
  if(CHECK_ACK)
  begin
    reg ack_check, ack_check_next;
    initial ack_check = 0;
    assign ack_check_next = read | ack_check;
    always @(posedge clock)
    begin
      ack_check &lt;= ack_check_next;
      if(setup_port)
      begin
        ack_check &lt;= 0;
      end
      if(done_port &amp; ~ack_check_next)
      begin
        $display(&quot;Acknowledge signal never asserted on interface %0d.&quot;, index);
        $finish;
      end
    end
  end
endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchFifoWrite</name>
      <circuit>
        <component_o id="TestbenchFifoWrite">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchFifoWrite"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="full_n" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="din" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality IP_COMPONENT="if_utils" LIBRARY="TestbenchFifoWrite index din" VERILOG_PROVIDED="
if_utils #(index, BITSIZE_din) m_utils();

reg enable, enable_next;
reg _full_n, _full_n_next;

initial
begin
  enable = 0;
  _full_n = 0;
end

assign full_n = _full_n;

always @(posedge clock)
begin
  enable &lt;= enable_next;
  _full_n &lt;= _full_n_next;
  if(setup_port)
  begin
    automatic int data = 0;
    data = m_utils.state(4);
    _full_n &lt;= data &gt; 0;
    enable &lt;= 1&apos;b1;
  end
  if((enable_next | done_port) &amp; write)
  begin
    automatic int data = 0;
    data = m_utils.push(din);
    _full_n &lt;= data &gt; 0;
    if(data &lt; 0)
    begin
      $display(&quot;Too many write requests on interface %0d&quot;, index);
      $finish;
    end
  end
end

always @(*) 
begin
  enable_next = enable &amp; ~done_port;
  _full_n_next = _full_n;
end
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchFifo</name>
      <circuit>
        <component_o id="TestbenchFifo">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchFifo"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="tb_done_port" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchFifo index" VERILOG_GENERATOR="TestbenchFifoModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchNone</name>
      <circuit>
        <component_o id="TestbenchNone">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchNone"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="setup_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="tb_done_port" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="TestbenchNone index" VERILOG_GENERATOR="TestbenchNoneModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>TestbenchAXIM</name>
      <circuit>
        <component_o id="TestbenchAXIM">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Michele Fiorito &lt;michele.fiorito@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="TestbenchAXIM"/>
          <parameter name="index">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality IP_COMPONENT="if_utils" LIBRARY="TestbenchAXIM" VERILOG_GENERATOR="TestbenchAXIMModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>constant_value</name>
      <attribute name="area" value_type="float64">0</attribute>
      <circuit>
        <component_o id="constant_value">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Christian Pilato &lt;christian.pilato@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="constant_value"/>
          <parameter name="value">&quot;0&quot;</parameter>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="constant_value out1 value" VHDL_PROVIDED="begin
 out1 &lt;= value;" VERILOG_PROVIDED="assign out1 = value;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>entry_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="ENTRY"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
    </cell>
    <cell>
      <name>gimple_goto_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="gimple_goto"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
    </cell>
    <cell>
      <name>gimple_pragma_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="gimple_pragma"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
    </cell>
    <cell>
      <name>gimple_phi_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="gimple_phi"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
    </cell>
    <cell>
      <name>nop_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="NOP"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
    </cell>
    <cell>
      <name>gimple_return_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="gimple_return"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
    </cell>
    <cell>
      <name>gimple_label_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="gimple_label"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
    </cell>
    <cell>
      <name>gimple_nop_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="gimple_nop"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
    </cell>
    <cell>
      <name>gimple_asm_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="gimple_asm" bounded="0"/>
      <operation operation_name="__gimple_asm" bounded="0"/>
      <circuit>
        <component_o id="gimple_asm_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2015-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="gimple_asm_FU"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="var_arg" dir="IN" is_var_args="1">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="sel_gimple_asm" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel___gimple_asm" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="out1" VERILOG_GENERATOR="ASMModuleGenerator" VHDL_GENERATOR="ASMModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>exit_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="EXIT"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
    </cell>
    <cell>
      <name>switch_cond_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="SWITCH_COND" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="switch_cond_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="switch_cond_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="switch_cond_FU in1 out1" VHDL_PROVIDED="begin
  out1 &lt;= in1;" VERILOG_PROVIDED="assign out1 = in1;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>read_cond_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="READ_COND" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="read_cond_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="read_cond_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="read_cond_FU in1" VHDL_PROVIDED="constant zeroes : std_logic_vector(in1&apos;range) := (others =&gt; &apos;0&apos;); 
constant xs : std_logic_vector(in1&apos;range) := (others =&gt; &apos;X&apos;);
 begin out1 &lt;= &apos;X&apos; when in1 = xs else &apos;1&apos; when in1 /= zeroes else &apos;0&apos;;" VERILOG_PROVIDED="assign out1 = in1 != {BITSIZE_in1{1&apos;b0}};"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>multi_read_cond_FU</name>
      <attribute name="area" value_type="float64">0</attribute>
      <operation operation_name="MULTI_READ_COND" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="multi_read_cond_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="multi_read_cond_FU"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="multi_read_cond_FU in1 out1" VHDL_PROVIDED="begin
  out1 &lt;= in1;" VERILOG_PROVIDED="assign out1 = in1;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_1_1_FU</name>
      <operation operation_name="VECT_CONCATENATION_1_1" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_1_1_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_1_1_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_1_1_FU in1 out1" VERILOG_PROVIDED="assign out1 = in1;" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in1,BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_1_1_FU</name>
      <operation operation_name="VECT_CONCATENATION_1_1" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_1_1_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_1_1_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_1_1_FU in1 out1" VERILOG_PROVIDED="assign out1 = in1;" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in1,BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_2_1_FU</name>
      <operation operation_name="VECT_CONCATENATION_2_1" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_2_1_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_2_1_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_2_1_FU in1 out1" VERILOG_PROVIDED="assign out1 = in1;" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_2_2_FU</name>
      <operation operation_name="VECT_CONCATENATION_2_2" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_2_2_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_2_2_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_2_2_FU in1 in2 out1" VERILOG_PROVIDED="wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign out1 = {tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_2_2_FU</name>
      <operation operation_name="VECT_CONCATENATION_2_2" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_2_2_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_2_2_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_2_2_FU in1 in2 out1" VERILOG_PROVIDED="
wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign out1 = {tmp_in2, tmp_in1};" VHDL_PROVIDED="
begin
  out1 &lt;= std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_3_3_FU</name>
      <operation operation_name="VECT_CONCATENATION_3_3" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_3_3_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_3_3_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_3_3_FU in1 in2 in3 out1" VERILOG_PROVIDED="wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign out1 = {tmp_in3, tmp_in2, tmp_in1};"
            VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_3_3_FU</name>
      <operation operation_name="VECT_CONCATENATION_3_3" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_3_3_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_3_3_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_3_3_FU in1 in2 in3 out1" VERILOG_PROVIDED="
wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign out1 = {tmp_in3, tmp_in2, tmp_in1};
" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_4_4_FU</name>
      <operation operation_name="VECT_CONCATENATION_4_4" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_4_4_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_4_4_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_4_4_FU in1 in2 in3 in4 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign out1 = {tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_4_4_FU</name>
      <operation operation_name="VECT_CONCATENATION_4_4" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_4_4_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_4_4_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_4_4_FU in1 in2 in3 in4 out1" VERILOG_PROVIDED="
wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
wire [BITSIZE_out1-1:0] tmp_in4;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign out1 = {tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_4_1_FU</name>
      <operation operation_name="VECT_CONCATENATION_4_1" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_4_1_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_4_1_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_4_1_FU in1 out1" VERILOG_PROVIDED="assign out1 = in1;" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_4_1_FU</name>
      <operation operation_name="VECT_CONCATENATION_4_1" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_4_1_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_4_1_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_4_1_FU in1 out1" VERILOG_PROVIDED="assign out1 = in1;" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_4_2_FU</name>
      <operation operation_name="VECT_CONCATENATION_4_2" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_4_2_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_4_2_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_4_2_FU in1 in2 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign out1 = {tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
   out1 &lt;= std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1));"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_4_2_FU</name>
      <operation operation_name="VECT_CONCATENATION_4_2" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_4_2_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_4_2_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_4_2_FU in1 in2 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign out1 = {tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
   out1 &lt;= std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1));"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_6_3_FU</name>
      <operation operation_name="VECT_CONCATENATION_6_3" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_6_3_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_6_3_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_6_3_FU in1 in2 in3 out1" VERILOG_PROVIDED="
wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign out1 = {tmp_in3, tmp_in2, tmp_in1};"
            VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_8_1_FU</name>
      <operation operation_name="VECT_CONCATENATION_8_1" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_8_1_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_8_1_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_8_1_FU in1 out1" VERILOG_PROVIDED="assign out1 = in1;" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_8_1_FU</name>
      <operation operation_name="VECT_CONCATENATION_8_1" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_8_1_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_8_1_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_8_1_FU in1 out1" VERILOG_PROVIDED="assign out1 = in1;" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_8_2_FU</name>
      <operation operation_name="VECT_CONCATENATION_8_2" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_8_2_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_8_2_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_8_2_FU in1 in2 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign out1 = {tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_8_2_FU</name>
      <operation operation_name="VECT_CONCATENATION_8_2" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_8_2_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_8_2_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_8_2_FU in1 in2 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign out1 = {tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_8_4_FU</name>
      <operation operation_name="VECT_CONCATENATION_8_4" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_8_4_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_8_4_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_8_4_FU in1 in2 in3 in4 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign out1 = {tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_8_4_FU</name>
      <operation operation_name="VECT_CONCATENATION_8_4" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_8_4_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_8_4_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_8_4_FU in1 in2 in3 in4 out1" VERILOG_PROVIDED="
wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
wire [BITSIZE_out1-1:0] tmp_in4;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign out1 = {tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_8_8_FU</name>
      <operation operation_name="VECT_CONCATENATION_8_8" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_8_8_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_8_8_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_8_8_FU in1 in2 in3 in4 in5 in6 in7 in8 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
wire signed [BITSIZE_out1-1:0] tmp_in5;
wire signed [BITSIZE_out1-1:0] tmp_in6;
wire signed [BITSIZE_out1-1:0] tmp_in7;
wire signed [BITSIZE_out1-1:0] tmp_in8;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign out1 = {tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="
begin
  out1 &lt;= std_logic_vector(resize(in8, BITSIZE_out1)) &amp; std_logic_vector(resize(in7, BITSIZE_out1)) &amp; std_logic_vector(resize(in6, BITSIZE_out1)) &amp; std_logic_vector(resize(in5, BITSIZE_out1)) &amp; std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_8_8_FU</name>
      <operation operation_name="VECT_CONCATENATION_8_8" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_8_8_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_8_8_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_8_8_FU in1 in2 in3 in4 in5 in6 in7 in8 out1" VERILOG_PROVIDED="
wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
wire [BITSIZE_out1-1:0] tmp_in4;
wire [BITSIZE_out1-1:0] tmp_in5;
wire [BITSIZE_out1-1:0] tmp_in6;
wire [BITSIZE_out1-1:0] tmp_in7;
wire [BITSIZE_out1-1:0] tmp_in8;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign out1 = {tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="
begin
   out1 &lt;= std_logic_vector(resize(in8, BITSIZE_out1)) &amp; std_logic_vector(resize(in7, BITSIZE_out1)) &amp; std_logic_vector(resize(in6, BITSIZE_out1)) &amp; std_logic_vector(resize(in5, BITSIZE_out1)) &amp; std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_16_16_FU</name>
      <operation operation_name="VECT_CONCATENATION_16_16" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_16_16_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_16_16_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in9" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in10" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in11" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in12" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in13" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in14" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in15" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in16" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_16_16_FU in1 in2 in3 in4 in5 in6 in7 in8 in9 in10 in11 in12 in13 in14 in15 in16 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
wire signed [BITSIZE_out1-1:0] tmp_in5;
wire signed [BITSIZE_out1-1:0] tmp_in6;
wire signed [BITSIZE_out1-1:0] tmp_in7;
wire signed [BITSIZE_out1-1:0] tmp_in8;
wire signed [BITSIZE_out1-1:0] tmp_in9;
wire signed [BITSIZE_out1-1:0] tmp_in10;
wire signed [BITSIZE_out1-1:0] tmp_in11;
wire signed [BITSIZE_out1-1:0] tmp_in12;
wire signed [BITSIZE_out1-1:0] tmp_in13;
wire signed [BITSIZE_out1-1:0] tmp_in14;
wire signed [BITSIZE_out1-1:0] tmp_in15;
wire signed [BITSIZE_out1-1:0] tmp_in16;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign tmp_in9 = in9;
assign tmp_in10 = in10;
assign tmp_in11 = in11;
assign tmp_in12 = in12;
assign tmp_in13 = in13;
assign tmp_in14 = in14;
assign tmp_in15 = in15;
assign tmp_in16 = in16;
assign out1 = {tmp_in16, tmp_in15, tmp_in14, tmp_in13, tmp_in12, tmp_in11, tmp_in10, tmp_in9, tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="
begin
  out1 &lt;= std_logic_vector(in1) &amp; std_logic_vector(in2) &amp; std_logic_vector(in3) &amp; std_logic_vector(in4) &amp; std_logic_vector(in5) &amp; std_logic_vector(in6) &amp; std_logic_vector(in7) &amp; std_logic_vector(in8) &amp; std_logic_vector(in9) &amp; std_logic_vector(in10) &amp; std_logic_vector(in11) &amp; std_logic_vector(in12) &amp; std_logic_vector(in13) &amp; std_logic_vector(in14) &amp; std_logic_vector(in15) &amp; std_logic_vector(in16);
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_16_16_FU</name>
      <operation operation_name="VECT_CONCATENATION_16_16" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_16_16_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_16_16_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in9" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in10" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in11" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in12" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in13" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in14" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in15" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in16" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_16_16_FU in1 in2 in3 in4 in5 in6 in7 in8 in9 in10 in11 in12 in13 in14 in15 in16 out1" VERILOG_PROVIDED="
wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
wire [BITSIZE_out1-1:0] tmp_in4;
wire [BITSIZE_out1-1:0] tmp_in5;
wire [BITSIZE_out1-1:0] tmp_in6;
wire [BITSIZE_out1-1:0] tmp_in7;
wire [BITSIZE_out1-1:0] tmp_in8;
wire [BITSIZE_out1-1:0] tmp_in9;
wire [BITSIZE_out1-1:0] tmp_in10;
wire [BITSIZE_out1-1:0] tmp_in11;
wire [BITSIZE_out1-1:0] tmp_in12;
wire [BITSIZE_out1-1:0] tmp_in13;
wire [BITSIZE_out1-1:0] tmp_in14;
wire [BITSIZE_out1-1:0] tmp_in15;
wire [BITSIZE_out1-1:0] tmp_in16;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign tmp_in9 = in9;
assign tmp_in10 = in10;
assign tmp_in11 = in11;
assign tmp_in12 = in12;
assign tmp_in13 = in13;
assign tmp_in14 = in14;
assign tmp_in15 = in15;
assign tmp_in16 = in16;
assign out1 = {tmp_in16, tmp_in15, tmp_in14, tmp_in13, tmp_in12, tmp_in11, tmp_in10, tmp_in9, tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="
begin
  out1 &lt;= std_logic_vector(in1) &amp; std_logic_vector(in2) &amp; std_logic_vector(in3) &amp; std_logic_vector(in4) &amp; std_logic_vector(in5) &amp; std_logic_vector(in     6) &amp; std_logic_vector(in7) &amp; std_logic_vector(in8) &amp; std_logic_vector(in9) &amp; std_logic_vector(in10) &amp; std_logic_vector(in11) &amp; std_logic_vector(in12) &amp; std_logic_vector(in13) &amp; std_logic_vector(in14) &amp; std_logic_vector(in15) &amp; std_logic_vector(in16);
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_16_8_FU</name>
      <operation operation_name="VECT_CONCATENATION_16_8" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_16_8_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_16_8_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_16_8_FU in1 in2 in3 in4 in5 in6 in7 in8 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
wire signed [BITSIZE_out1-1:0] tmp_in5;
wire signed [BITSIZE_out1-1:0] tmp_in6;
wire signed [BITSIZE_out1-1:0] tmp_in7;
wire signed [BITSIZE_out1-1:0] tmp_in8;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign out1 = {tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
   out1 &lt;= std_logic_vector(resize(in8, BITSIZE_out1)) &amp; std_logic_vector(resize(in7, BITSIZE_out1)) &amp; std_logic_vector(resize(in6, BITSIZE_out1)) &amp; std_logic_vector(resize(in5, BITSIZE_out1)) &amp; std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_16_8_FU</name>
      <operation operation_name="VECT_CONCATENATION_16_8" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_16_8_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_16_8_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_16_8_FU in1 in2 in3 in4 in5 in6 in7 in8 out1" VERILOG_PROVIDED="
wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
wire [BITSIZE_out1-1:0] tmp_in4;
wire [BITSIZE_out1-1:0] tmp_in5;
wire [BITSIZE_out1-1:0] tmp_in6;
wire [BITSIZE_out1-1:0] tmp_in7;
wire [BITSIZE_out1-1:0] tmp_in8;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign out1 = {tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="
begin
   out1 &lt;= std_logic_vector(resize(in8, BITSIZE_out1)) &amp; std_logic_vector(resize(in7, BITSIZE_out1)) &amp; std_logic_vector(resize(in6, BITSIZE_out1)) &amp; std_logic_vector(resize(in5, BITSIZE_out1)) &amp; std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_16_4_FU</name>
      <operation operation_name="VECT_CONCATENATION_16_4" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_16_4_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_16_4_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_16_4_FU in1 in2 in3 in4 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign out1 = {tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="
begin
  out1 &lt;= std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_16_4_FU</name>
      <operation operation_name="VECT_CONCATENATION_16_4" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_16_4_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_16_4_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_16_4_FU in1 in2 in3 in4 out1" VERILOG_PROVIDED="
wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
wire [BITSIZE_out1-1:0] tmp_in4;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign out1 = {tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="
begin
  out1 &lt;= std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_12_3_FU</name>
      <operation operation_name="VECT_CONCATENATION_12_3" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_12_3_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_12_3_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_12_3_FU in1 in2 in3 out1" VERILOG_PROVIDED="
wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign out1 = {tmp_in3, tmp_in2, tmp_in1};"
            VHDL_PROVIDED="
begin
  out1 &lt;= std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_12_3_FU</name>
      <operation operation_name="VECT_CONCATENATION_12_3" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_12_3_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_12_3_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_12_3_FU in1 in2 in3 out1" VERILOG_PROVIDED="wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign out1 = {tmp_in3, tmp_in2, tmp_in1};"
            VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_16_2_FU</name>
      <operation operation_name="VECT_CONCATENATION_16_2" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_16_2_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_16_2_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_16_2_FU in1 in2 out1" VERILOG_PROVIDED="wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign out1 = {tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_16_2_FU</name>
      <operation operation_name="VECT_CONCATENATION_16_2" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_16_2_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_16_2_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_16_2_FU in1 in2 out1" VERILOG_PROVIDED="wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign out1 = {tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_24_3_FU</name>
      <operation operation_name="VECT_CONCATENATION_24_3" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_24_3_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_24_3_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_24_3_FU in1 in2 in3 out1" VERILOG_PROVIDED="wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign out1 = {tmp_in3, tmp_in2, tmp_in1};
" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_24_3_FU</name>
      <operation operation_name="VECT_CONCATENATION_24_3" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_24_3_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2016-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_24_3_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_24_3_FU in1 in2 in3 out1" VERILOG_PROVIDED="wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign out1 = {tmp_in3, tmp_in2, tmp_in1};
" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_32_4_FU</name>
      <operation operation_name="VECT_CONCATENATION_32_4" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_32_4_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_32_4_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_32_4_FU in1 in2 in3 in4 out1" VERILOG_PROVIDED="wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign out1 = {tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
   out1 &lt;= std_logic_vector(resize(in4,BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_32_4_FU</name>
      <operation operation_name="VECT_CONCATENATION_32_4" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_32_4_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2014-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_32_4_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_32_4_FU in1 in2 in3 in4 out1" VERILOG_PROVIDED="wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
wire [BITSIZE_out1-1:0] tmp_in4;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign out1 = {tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
   out1 &lt;= std_logic_vector(resize(in4,BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_32_8_FU</name>
      <operation operation_name="VECT_CONCATENATION_32_8" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_32_8_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_32_8_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_32_8_FU in1 in2 in3 in4 in5 in6 in7 in8 out1" VERILOG_PROVIDED="wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
wire signed [BITSIZE_out1-1:0] tmp_in5;
wire signed [BITSIZE_out1-1:0] tmp_in6;
wire signed [BITSIZE_out1-1:0] tmp_in7;
wire signed [BITSIZE_out1-1:0] tmp_in8;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign out1 = {tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
   out1 &lt;= std_logic_vector(resize(in8, BITSIZE_out1)) &amp; std_logic_vector(resize(in7, BITSIZE_out1)) &amp; std_logic_vector(resize(in6, BITSIZE_out1)) &amp; std_logic_vector(resize(in5, BITSIZE_out1)) &amp; std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_32_8_FU</name>
      <operation operation_name="VECT_CONCATENATION_32_8" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_32_8_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_32_8_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_32_8_FU in1 in2 in3 in4 in5 in6 in7 in8 out1" VERILOG_PROVIDED="wire [BITSIZE_out1-1:0] tmp_in1;
wire [BITSIZE_out1-1:0] tmp_in2;
wire [BITSIZE_out1-1:0] tmp_in3;
wire [BITSIZE_out1-1:0] tmp_in4;
wire [BITSIZE_out1-1:0] tmp_in5;
wire [BITSIZE_out1-1:0] tmp_in6;
wire [BITSIZE_out1-1:0] tmp_in7;
wire [BITSIZE_out1-1:0] tmp_in8;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign out1 = {tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
   out1 &lt;= std_logic_vector(resize(in8, BITSIZE_out1)) &amp; std_logic_vector(resize(in7, BITSIZE_out1)) &amp; std_logic_vector(resize(in6, BITSIZE_out1)) &amp; std_logic_vector(resize(in5, BITSIZE_out1)) &amp; std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>concat_64_8_FU</name>
      <operation operation_name="VECT_CONCATENATION_64_8" supported_types="INT:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="concat_64_8_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="concat_64_8_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_INT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="concat_64_8_FU in1 in2 in3 in4 in5 in6 in7 in8 out1" VERILOG_PROVIDED="wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
wire signed [BITSIZE_out1-1:0] tmp_in5;
wire signed [BITSIZE_out1-1:0] tmp_in6;
wire signed [BITSIZE_out1-1:0] tmp_in7;
wire signed [BITSIZE_out1-1:0] tmp_in8;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign out1 = {tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in8, BITSIZE_out1)) &amp; std_logic_vector(resize(in7, BITSIZE_out1)) &amp; std_logic_vector(resize(in6, BITSIZE_out1)) &amp; std_logic_vector(resize(in5, BITSIZE_out1)) &amp; std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_concat_64_8_FU</name>
      <operation operation_name="VECT_CONCATENATION_64_8" supported_types="UINT:*|VECTOR_BOOL:*|REAL:*" execution_time="0.0000001"/>
      <component_timing_alias>ASSIGN_VECTOR_BOOL_FU</component_timing_alias>
      <circuit>
        <component_o id="ui_concat_64_8_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_concat_64_8_FU"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in5" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in6" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in7" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in8" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_UINT" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_concat_64_8_FU in1 in2 in3 in4 in5 in6 in7 in8 out1" VERILOG_PROVIDED="wire signed [BITSIZE_out1-1:0] tmp_in1;
wire signed [BITSIZE_out1-1:0] tmp_in2;
wire signed [BITSIZE_out1-1:0] tmp_in3;
wire signed [BITSIZE_out1-1:0] tmp_in4;
wire signed [BITSIZE_out1-1:0] tmp_in5;
wire signed [BITSIZE_out1-1:0] tmp_in6;
wire signed [BITSIZE_out1-1:0] tmp_in7;
wire signed [BITSIZE_out1-1:0] tmp_in8;
assign tmp_in1 = in1;
assign tmp_in2 = in2;
assign tmp_in3 = in3;
assign tmp_in4 = in4;
assign tmp_in5 = in5;
assign tmp_in6 = in6;
assign tmp_in7 = in7;
assign tmp_in8 = in8;
assign out1 = {tmp_in8, tmp_in7, tmp_in6, tmp_in5, tmp_in4, tmp_in3, tmp_in2, tmp_in1};" VHDL_PROVIDED="begin
  out1 &lt;= std_logic_vector(resize(in8, BITSIZE_out1)) &amp; std_logic_vector(resize(in7, BITSIZE_out1)) &amp; std_logic_vector(resize(in6, BITSIZE_out1)) &amp; std_logic_vector(resize(in5, BITSIZE_out1)) &amp; std_logic_vector(resize(in4, BITSIZE_out1)) &amp; std_logic_vector(resize(in3, BITSIZE_out1)) &amp; std_logic_vector(resize(in2, BITSIZE_out1)) &amp; std_logic_vector(resize(in1, BITSIZE_out1));
"
          />
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>bus_merger</name>
      <circuit>
        <component_o id="bus_merger">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="bus_merger"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="bus_merger in1 out1" VERILOG_PROVIDED="
function [BITSIZE_out1-1:0] merge;
  input [BITSIZE_in1*PORTSIZE_in1-1:0] m;
  reg [BITSIZE_out1-1:0] res;
  integer i1;
begin
  res={BITSIZE_in1{1&apos;b0}};
  for(i1 = 0; i1 &lt; PORTSIZE_in1; i1 = i1 + 1)
  begin
    res = res | m[i1*BITSIZE_in1 +:BITSIZE_in1];
  end
  merge = res;
end
endfunction

assign out1 = merge(in1);" VHDL_PROVIDED="begin
process(in1)
variable temp_out1 : std_logic_vector(BITSIZE_out1-1 downto 0);
begin
  temp_out1 := (others =&gt; &apos;0&apos;);
  for I in 0 to PORTSIZE_in1-1 loop
    temp_out1 := temp_out1 or in1(((I+1)*BITSIZE_in1)-1 downto (I*BITSIZE_in1));
  end loop;  out1 &lt;= temp_out1;
end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <template>
      <name>DEMUX_GATE</name>
      <circuit>
        <component_o id="DEMUX_GATE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="DEMUX_GATE"/>
          <port_o id="sel" dir="IN">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out2" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="DEMUX_GATE in1 out1 out2" VERILOG_PROVIDED="
reg [BITSIZE_out1-1:0] out1;
reg [BITSIZE_out2-1:0] out2;
always @ (sel or in1)
  case (sel)
    1&apos;b1: {out1, out2} = {{BITSIZE_out1{1&apos;b0}}, in1};
    default: {out1, out2} = {in1, {BITSIZE_out2{1&apos;b0}}};
  endcase"/>
        </component_o>
      </circuit>
    </template>
    <cell>
      <name>flipflop_AR</name>
      <circuit>
        <component_o id="flipflop_AR">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="flipflop_AR"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="flipflop_AR in1 out1" VERILOG_PROVIDED="
reg reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock 1RESET_EDGE_FORCE)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else
    reg_out1 &lt;= in1;" VHDL_PROVIDED="
signal reg_out1 : std_logic 1INIT_ZERO_VALUEb;
begin
  process(clock,reset)
  begin
    if(1RESET_VALUE) then
      reg_out1 &lt;= &apos;0&apos;;
    elsif(clock&apos;event and clock = &apos;1&apos;) then
      reg_out1 &lt;= in1;
    end if;
  end process;
  out1 &lt;= reg_out1;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>flipflop_SR</name>
      <circuit>
        <component_o id="flipflop_SR">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Marco Lattuada &lt;marco.lattuada@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="flipflop_SR"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="flipflop_SR in1 out1" VERILOG_PROVIDED="
reg reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else
    reg_out1 &lt;= in1;
" VHDL_PROVIDED="
signal reg_out1 : std_logic 1INIT_ZERO_VALUEb;
begin
   out1 &lt;= reg_out1;
   process(clock)
   begin
      if(clock&apos;event and clock=&apos;1&apos;) then
         if(1RESET_VALUE) then
            reg_out1 &lt;= &apos;0&apos;;
         else
            reg_out1 &lt;= in1;
         end if;
      end if;
  end process;

"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>join_signal</name>
      <attribute name="area" value_type="float64">0</attribute>
      <circuit>
        <component_o id="join_signal">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="join_signal"/>
          <port_vector_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="join_signal in1 out1" VERILOG_PROVIDED="
generate
genvar i1;
for (i1=0; i1&lt;PORTSIZE_in1; i1=i1+1)
  begin : L1
    assign out1[(i1+1)*(BITSIZE_out1/PORTSIZE_in1)-1:i1*(BITSIZE_out1/PORTSIZE_in1)] = in1[(i1+1)*BITSIZE_in1-1:i1*BITSIZE_in1];
  end
endgenerate" VHDL_PROVIDED="
begin
  process(in1)
  begin
    for i1 in 0 to PORTSIZE_in1-1 loop
    out1((i1+1)*(BITSIZE_out1/PORTSIZE_in1)-1 downto i1*(BITSIZE_out1/PORTSIZE_in1)) &lt;= in1((i1+1)*BITSIZE_in1-1 downto i1*BITSIZE_in1);
     end loop;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_AR</name>
      <circuit>
        <component_o id="register_AR">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_AR"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_AR in1 out1" VERILOG_PROVIDED="
reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock 1RESET_EDGE_FORCE)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else
    reg_out1 &lt;= in1;" VHDL_PROVIDED="
signal reg_out1 : std_logic_vector(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
begin
  out1 &lt;= reg_out1;
  process(clock,reset)
  begin
    if(1RESET_VALUE) then
      reg_out1 &lt;= (others =&gt; &apos;0&apos;);
    elsif(clock&apos;event and clock = &apos;1&apos;) then
      reg_out1 &lt;= in1;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_AR_NORETIME</name>
      <circuit>
        <component_o id="register_AR_NORETIME">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2013-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_AR_NORETIME"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_AR_NORETIME in1 out1" VERILOG_PROVIDED="
(* dont_retime *)(* keep = &quot;true&quot; *)(* syn_keep=1 *)(* DONT_TOUCH = &quot;true&quot; *) reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock 1RESET_EDGE_FORCE)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else
    reg_out1 &lt;= in1;" VHDL_PROVIDED="
signal reg_out1 : std_logic_vector(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
attribute dont_retime : boolean;
attribute dont_retime of reg_out1 : signal is true;
attribute syn_keep: boolean;
attribute syn_keep of reg_out1: signal is true;
attribute DONT_TOUCH : boolean;
attribute DONT_TOUCH of reg_out1 : signal is true;
begin
  out1 &lt;= reg_out1;
  process(clock,reset)
  begin
    if(1RESET_VALUE) then
      reg_out1 &lt;= (others =&gt; &apos;0&apos;);
    elsif(clock&apos;event and clock = &apos;1&apos;) then
      reg_out1 &lt;= in1;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_AR_NORETIME_INT</name>
      <circuit>
        <component_o id="register_AR_NORETIME_INT">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2020-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_AR_NORETIME_INT"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_AR_NORETIME_INT in1 out1" VERILOG_PROVIDED="
(* dont_retime *)(* keep = &quot;true&quot; *)(* syn_keep=1 *)(* DONT_TOUCH = &quot;true&quot; *) reg signed [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock 1RESET_EDGE_FORCE)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else
    reg_out1 &lt;= in1;" VHDL_PROVIDED="
signal reg_out1 : signed(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
attribute dont_retime : boolean;
attribute dont_retime of reg_out1 : signal is true;
attribute syn_keep: boolean;
attribute syn_keep of reg_out1: signal is true;
attribute DONT_TOUCH : boolean;
attribute DONT_TOUCH of reg_out1 : signal is true;
begin
  out1 &lt;= reg_out1;
  process(clock,reset)
  begin
    if(1RESET_VALUE) then
      reg_out1 &lt;= (others =&gt; &apos;0&apos;);
    elsif(clock&apos;event and clock = &apos;1&apos;) then
      reg_out1 &lt;= in1;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_AR_NORETIME_UINT</name>
      <circuit>
        <component_o id="register_AR_NORETIME_UINT">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2020-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_AR_NORETIME_UINT"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_AR_NORETIME_UINT in1 out1" VERILOG_PROVIDED="
(* dont_retime *)(* keep = &quot;true&quot; *)(* syn_keep=1 *)(* DONT_TOUCH = &quot;true&quot; *) reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock 1RESET_EDGE_FORCE)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else
    reg_out1 &lt;= in1;" VHDL_PROVIDED="
signal reg_out1 : unsigned(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
attribute dont_retime : boolean;
attribute dont_retime of reg_out1 : signal is true;
attribute syn_keep: boolean;
attribute syn_keep of reg_out1: signal is true;
attribute DONT_TOUCH : boolean;
attribute DONT_TOUCH of reg_out1 : signal is true;
begin
  out1 &lt;= reg_out1;
  process(clock,reset)
  begin
    if(1RESET_VALUE) then
      reg_out1 &lt;= (others =&gt; &apos;0&apos;);
    elsif(clock&apos;event and clock = &apos;1&apos;) then
      reg_out1 &lt;= in1;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_AR_NORETIME_REAL</name>
      <circuit>
        <component_o id="register_AR_NORETIME_REAL">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2020-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_AR_NORETIME_REAL"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="REAL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="REAL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_AR_NORETIME_REAL in1 out1" VERILOG_PROVIDED="
(* dont_retime *)(* keep = &quot;true&quot; *)(* syn_keep=1 *)(* DONT_TOUCH = &quot;true&quot; *) reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock 1RESET_EDGE_FORCE)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else
    reg_out1 &lt;= in1;" VHDL_PROVIDED="
signal reg_out1 : std_logic_vector(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
attribute dont_retime : boolean;
attribute dont_retime of reg_out1 : signal is true;
attribute syn_keep: boolean;
attribute syn_keep of reg_out1: signal is true;
attribute DONT_TOUCH : boolean;
attribute DONT_TOUCH of reg_out1 : signal is true;
begin
  out1 &lt;= reg_out1;
  process(clock,reset)
  begin
    if(1RESET_VALUE) then
      reg_out1 &lt;= (others =&gt; &apos;0&apos;);
    elsif(clock&apos;event and clock = &apos;1&apos;) then
      reg_out1 &lt;= in1;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_SARSE</name>
      <circuit>
        <component_o id="register_SARSE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_SARSE"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wenable" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_SARSE in1 out1" VERILOG_PROVIDED="
reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock 1RESET_EDGE_FORCE)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else if (wenable)
    reg_out1 &lt;= in1;" VHDL_PROVIDED="
signal reg_out1 : std_logic_vector(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
begin
  out1 &lt;= reg_out1;
  process(clock,reset)
  begin
    if(1RESET_VALUE) then
      reg_out1 &lt;= (others =&gt; &apos;0&apos;);
    elsif(clock&apos;event and clock = &apos;1&apos;) then
      if (wenable = &apos;1&apos;) then
        reg_out1 &lt;= in1;
      end if;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_SE</name>
      <circuit>
        <component_o id="register_SE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_SE"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wenable" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_SE in1 out1" VERILOG_PROVIDED="
reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock)
  if (wenable)
    reg_out1 &lt;= in1;"
            VHDL_PROVIDED="
signal reg_out1 : std_logic_vector(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
begin
  out1 &lt;= reg_out1;
  process(clock)
  begin
    if(clock&apos;event and clock = &apos;1&apos;) then
      if(wenable = &apos;1&apos;) then
        reg_out1 &lt;= in1;
      end if;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_SR</name>
      <circuit>
        <component_o id="register_SR">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_SR"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_SR in1 out1" VERILOG_PROVIDED="
reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else
    reg_out1 &lt;= in1;"
            VHDL_PROVIDED="signal reg_out1 : std_logic_vector(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
begin
  out1 &lt; reg_out1;
  process(clock)
  begin
    if(clock&apos;event and clock = &apos;1&apos;) then
      if(1RESET_VALUE)
        reg_out &lt;= (others =&gt; &apos;0&apos;);
      else
        reg_out1 &lt; in1;
      end if;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_SRSE</name>
      <circuit>
        <component_o id="register_SRSE">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_SRSE"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wenable" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_SRSE in1 out1" VERILOG_PROVIDED="
reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else if (wenable)
    reg_out1 &lt;= in1;" VHDL_PROVIDED="
signal reg_out1 : std_logic_vector(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
begin
  out1 &lt;= reg_out1;
  process(clock)
  begin
    if(clock&apos;event and clock = &apos;1&apos;) then
      if(1RESET_VALUE) then
        reg_out1 &lt;= (others =&gt; &apos;0&apos;);
      elsif (wenable = &apos;1&apos;) then
        reg_out1 &lt;= in1;
      end if;
    end if;
  end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_STD</name>
      <circuit>
        <component_o id="register_STD">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_STD"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wenable" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_STD in1 out1" VERILOG_PROVIDED="reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
always @(posedge clock)
  reg_out1 &lt;= in1;
" VHDL_PROVIDED="
signal reg_out1 : std_logic_vector(BITSIZE_out1-1 downto 0) 1INIT_ZERO_VALUE;
begin
out1 &lt;= reg_out1;
process(clock)
begin
  if(clock&apos;event and clock = &apos;1&apos;) then
    reg_out1 &lt;= in1;
  end if;
end process;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_SHIFT</name>
      <circuit>
        <component_o id="register_SHIFT">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_SHIFT"/>
          <parameter name="CONTROLLER_LENGTH">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wenable" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_SHIFT CONTROLLER_LENGTH" VERILOG_PROVIDED="
generate if (CONTROLLER_LENGTH == 0) 
begin
  assign out1 = in1;
end
else
begin
  reg [CONTROLLER_LENGTH-1:0] reg_out1 1INIT_ZERO_VALUE;
  assign out1 = reg_out1[CONTROLLER_LENGTH-1];
  always @(posedge clock)
    if(1RESET_VALUE)
      reg_out1 &lt;= {CONTROLLER_LENGTH{1&apos;b0}};
    else
      reg_out1 &lt;= (reg_out1 &lt;&lt; 1) | in1;
end
endgenerate
" VHDL_PROVIDED="
begin
zero_case: if CONTROLLER_LENGTH /= 0 generate 
signal reg_out1 : std_logic_vector(CONTROLLER_LENGTH-1 downto 0) 1INIT_ZERO_VALUE;
begin
out1 &lt;= reg_out1(CONTROLLER_LENGTH-1);
process(clock)
begin
  if(clock&apos;event and clock = &apos;1&apos;) then
    if(1RESET_VALUE) then
      reg_out1 &lt;= (others =&gt; &apos;0&apos;);
    else
      reg_out1(CONTROLLER_LENGTH-1 downto 1) &lt;= reg_out1(CONTROLLER_LENGTH-2 downto 0);
      reg_out1(0) &lt;= in1;
    end if;
  end if;
end process;
end generate zero_case;

nonzero_case: if CONTROLLER_LENGTH = 0 generate 
  out1 &lt;= in1;
end generate nonzero_case;

"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>split_signal</name>
      <attribute name="area" value_type="float64">0</attribute>
      <circuit>
        <component_o id="split_signal">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="split_signal"/>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_vector_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="split_signal in1 out1" VERILOG_PROVIDED="assign out1 = in1;" VHDL_PROVIDED="begin
  out1 &lt;= in1;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>Stage_controller</name>
      <circuit>
        <component_o id="Stage_controller">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2024 Politecnico di Milano</copyright>
          <authors>Luca Ezio Pozzoni &lt;lucaezio.pozzoni@mail.polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="Stage_controller"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid_in" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ready_in" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid_out" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ready_out" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="selector_out" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="std_wenable" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="stall_wenable" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="Stage_controller" VERILOG_PROVIDED="localparam [1:0] IDLE = 2&apos;b00;
  localparam [1:0] SEND = 2&apos;b01;
  localparam [1:0] FULL = 2&apos;b10;

  reg selector_out;
  reg std_wenable;
  reg stall_wenable;

  reg [1:0] state, state_next;
  
  always @(posedge in_clk)
  begin
    state &lt;= state_next;
    if(1RESET_VALUE)
    begin
      state &lt;= IDLE;
    end
  end
  
  always @(*)
  begin
    state_next = state;
    std_wenable = 0;
    stall_wenable = 0;
    selector_out = 0;
    case (state)
      IDLE    :
      begin
        if(valid_in)
        begin
          state_next = SEND;
          std_wenable = 1;
        end
      end
      SEND    :
      begin
        if(valid_in ^ ready_in)
        begin
          if(valid_in)
          begin
            state_next = FULL;
            stall_wenable = 1;
          end
          else
          begin
            state_next = IDLE;
          end
        end
        else
        begin
          if(ready_in)
          begin
            std_wenable = 1;
          end
        end
      end
      FULL    :
      begin
        selector_out = 1;
        if((!valid_in) &lt;&lt; (ready_in))
        begin
          state_next = SEND;
          std_wenable = 1;
        end
      end
      default :
      begin
        state_next = IDLE;
      end
    endcase
  end

  assign valid_out = ((state == SEND) || (state == FULL));
  assign ready_out = ((state == IDLE) || (state == SEND));"/>
        </component_o>
      </circuit>
    </cell>
  </library>
  <library>
    <name>STD_FU</name>
    <cell>
      <name>ui_const_mult_expr_FU</name>
      <circuit>
        <component_o id="ui_const_mult_expr_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2014-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_const_mult_expr_FU"/>
          <parameter name="VALUE_PARAMETER">0</parameter>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_const_mult_expr_FU in1 in2 out1 VALUE_PARAMETER" VERILOG_PROVIDED="assign out1 = in1 * VALUE_PARAMETER;" VHDL_PROVIDED="begin
  out1 &lt;= resize(in1 * VALUE_PARAMETER, BITSIZE_out1);
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>ui_align_plus_expr_FU</name>
      <circuit>
        <component_o id="ui_align_plus_expr_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2015-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="ui_align_plus_expr_FU"/>
          <parameter name="VALUE_PARAMETER">0</parameter>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="UINT" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="ui_align_plus_expr_FU in1 in2 out1 VALUE_PARAMETER" VERILOG_PROVIDED="generate if (BITSIZE_out1 &gt; VALUE_PARAMETER) assign out1[BITSIZE_out1-1:VALUE_PARAMETER] = (in1[BITSIZE_in1-1:VALUE_PARAMETER] + in2[BITSIZE_in2-1:VALUE_PARAMETER]); endgenerate
generate if (VALUE_PARAMETER != 0) assign out1[VALUE_PARAMETER-1:0] = 0; endgenerate" VHDL_PROVIDED="begin
  out1 &lt;= resize(in1, BITSIZE_out1) + resize(in2, BITSIZE_out1);"/>
        </component_o>
      </circuit>
    </cell>
  </library>
</technology>