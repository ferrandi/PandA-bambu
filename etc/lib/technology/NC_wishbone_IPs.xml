<?xml version="1.0"?>
<technology>
  <library>
    <name>WBWrapper</name>
    <cell>
      <name>address_range_checker_FU</name>
      <circuit>
        <component_o id="address_range_checker_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="address_range_checker_FU"/>
          <port_o id="address" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="base" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="max_address" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="isInRange" dir="OUT">
            <structural_type_descriptor type="BOOL"/>
          </port_o>
          <NP_functionality LIBRARY="address_range_checker_FU address base max_address" VERILOG_PROVIDED="
reg isInRange;
always @ (address or base or max_address)
   if (address >= base &amp;&amp; address &lt;= max_address)
     isInRange = 1&apos;b1;
   else
     isInRange = 1&apos;b0;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>address_filter_FU</name>
      <circuit>
        <component_o id="address_filter_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="address_filter_FU"/>
          <parameter name="MAX_ADDRESS">0</parameter>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="address_filter_FU in1 out1 MAX_ADDRESS" VERILOG_PROVIDED="`ifndef _SIM_HAVE_CLOG2
  function integer log2;
     input integer value;
     integer temp_value;
    begin
      temp_value = value-1;
      for (log2=0; temp_value&gt;0; log2=log2+1)
        temp_value = temp_value&gt;&gt;1;
    end
  endfunction
`endif
`ifdef _SIM_HAVE_CLOG2
  parameter nbit_addr = MAX_ADDRESS == 1 ? 1 : $clog2(MAX_ADDRESS);
`else
  parameter nbit_addr = MAX_ADDRESS == 1 ? 1 : log2(MAX_ADDRESS);
`endif

generate
if (BITSIZE_out1 &lt;= nbit_addr)
begin
  assign out1 = in1[BITSIZE_out1-1:0];
end
else
begin
  assign out1 = {{(BITSIZE_out1-nbit_addr-1){1&apos;b0}},in1[nbit_addr:0]};
end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>sel_converter_FU</name>
      <circuit>
        <component_o id="sel_converter_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="sel_converter_FU"/>
          <port_o id="sel" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dataRamSize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <NP_functionality LIBRARY="sel_converter_FU sel dataRamSize" VERILOG_PROVIDED="
reg [BITSIZE_dataRamSize - 1:0]    dataRamSize;

generate
   if (BITSIZE_sel == 1)
     begin
        always @ (sel)
            dataRamSize = { {BITSIZE_dataRamSize-4{1&apos;b0}}, 4&apos;d8};
     end // if (BITSIZE_sel == 4)
   if (BITSIZE_sel == 2)
     begin
        always @ (sel)
          case (sel)
            2&apos;h1: dataRamSize = { {BITSIZE_dataRamSize-4{1&apos;b0}}, 4&apos;d8};
            default: dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
          endcase // case (sel)
     end
   if (BITSIZE_sel == 4)
     begin
        if (BITSIZE_dataRamSize > 4)
          begin
             always @ (sel)
               case (sel)
                 4&apos;h1: dataRamSize = { {BITSIZE_dataRamSize-4{1&apos;b0}}, 4&apos;d8};
                 4&apos;h3: dataRamSize = { {BITSIZE_dataRamSize-5{1&apos;b0}}, 5&apos;d16};
                 default: dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
               endcase // case (sel)
          end
        else
          begin
             always @ (sel)
            dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
          end
     end
   if (BITSIZE_sel == 8)
     begin
        if (BITSIZE_dataRamSize > 5)
          begin
             always @ (sel)
               case (sel)
                 8&apos;h1: dataRamSize = { {BITSIZE_dataRamSize-4{1&apos;b0}}, 4&apos;d8};
                 8&apos;h3: dataRamSize = { {BITSIZE_dataRamSize-5{1&apos;b0}}, 5&apos;d16};
                 8&apos;hf: dataRamSize = { {BITSIZE_dataRamSize-6{1&apos;b0}}, 6&apos;d32};
                 default: dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
               endcase // case (sel)
          end
        else if (BITSIZE_dataRamSize == 5)
          begin
             always @ (sel)
               case (sel)
                 8&apos;h1: dataRamSize = { {BITSIZE_dataRamSize-4{1&apos;b0}}, 4&apos;d8};
                 8&apos;h3: dataRamSize = { {BITSIZE_dataRamSize-5{1&apos;b0}}, 5&apos;d16};
                 default: dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
               endcase // case (sel)
          end
        else
          begin
             always @ (sel)
            dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
          end
     end
   if (BITSIZE_sel == 16)
     begin
        if (BITSIZE_dataRamSize > 6)
          begin
             always @ (sel)
               case (sel)
                 16&apos;h1: dataRamSize = { {BITSIZE_dataRamSize-4{1&apos;b0}}, 4&apos;d8};
                 16&apos;h3: dataRamSize = { {BITSIZE_dataRamSize-5{1&apos;b0}}, 5&apos;d16};
                 16&apos;hf: dataRamSize = { {BITSIZE_dataRamSize-6{1&apos;b0}}, 6&apos;d32};
                 16&apos;hff: dataRamSize = { {BITSIZE_dataRamSize-7{1&apos;b0}}, 7&apos;d64};
                 default: dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
               endcase // case (sel)
          end
        else if (BITSIZE_dataRamSize == 6)
          begin
             always @ (sel)
               case (sel)
                 16&apos;h1: dataRamSize = { {BITSIZE_dataRamSize-4{1&apos;b0}}, 4&apos;d8};
                 16&apos;h3: dataRamSize = { {BITSIZE_dataRamSize-5{1&apos;b0}}, 5&apos;d16};
                 16&apos;hf: dataRamSize = { {BITSIZE_dataRamSize-6{1&apos;b0}}, 6&apos;d32};
                 default: dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
               endcase // case (sel)
          end
        else if (BITSIZE_dataRamSize == 5)
          begin
             always @ (sel)
               case (sel)
                 16&apos;h1: dataRamSize = { {BITSIZE_dataRamSize-4{1&apos;b0}}, 4&apos;d8};
                 16&apos;h3: dataRamSize = { {BITSIZE_dataRamSize-5{1&apos;b0}}, 5&apos;d16};
                 default: dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
               endcase // case (sel)
          end
        else
          begin
             always @ (sel)
            dataRamSize = { 1&apos;b1, {BITSIZE_dataRamSize-1{1&apos;b0}}};
          end
     end
endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>dataramsize_converter_FU</name>
      <circuit>
        <component_o id="dataramsize_converter_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="dataramsize_converter_FU"/>
          <port_o id="dataRamSize" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="sel" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="dataramsize_converter_FU dataRamSize sel" VERILOG_PROVIDED="
reg [BITSIZE_sel - 1:0]    sel;

generate
   if (BITSIZE_dataRamSize == 4)
     begin
        always @ (dataRamSize)
          case (dataRamSize)
            4&apos;d8: sel = {{BITSIZE_sel-1{1&apos;b0}}, 1&apos;h1};
            default: sel = {BITSIZE_sel{1&apos;b1}};
          endcase
     end
   if (BITSIZE_dataRamSize == 5)
     begin
        always @ (dataRamSize)
          case (dataRamSize)
            5&apos;d8: sel = {{BITSIZE_sel-1{1&apos;b0}}, 1&apos;h1};
            5&apos;d16: sel = {{BITSIZE_sel-2{1&apos;b0}}, 2&apos;h3};
            default: sel = {BITSIZE_sel{1&apos;b1}};
          endcase
     end
   if (BITSIZE_dataRamSize == 6)
     begin
        always @ (dataRamSize)
          case (dataRamSize)
            6&apos;d8: sel = {{BITSIZE_sel-1{1&apos;b0}}, 1&apos;h1};
            6&apos;d16: sel = {{BITSIZE_sel-2{1&apos;b0}}, 2&apos;h3};
            6&apos;d32: sel = {{BITSIZE_sel-4{1&apos;b0}}, 4&apos;hf};
            default: sel = {BITSIZE_sel{1&apos;b1}};
          endcase
     end
   if (BITSIZE_dataRamSize == 7)
     begin
        always @ (dataRamSize)
          case (dataRamSize)
            7&apos;d8: sel = {{BITSIZE_sel-1{1&apos;b0}}, 1&apos;h1};
            7&apos;d16: sel = {{BITSIZE_sel-2{1&apos;b0}}, 2&apos;h3};
            7&apos;d32: sel = {{BITSIZE_sel-4{1&apos;b0}}, 4&apos;hf};
            7&apos;d64: sel = {{BITSIZE_sel-8{1&apos;b0}}, 8&apos;hff};
            default: sel = {BITSIZE_sel{1&apos;b1}};
          endcase
     end
   if (BITSIZE_dataRamSize == 8)
     begin
        always @ (dataRamSize)
          case (dataRamSize)
            8&apos;d8: sel = {{BITSIZE_sel-1{1&apos;b0}}, 1&apos;h1};
            8&apos;d16: sel = {{BITSIZE_sel-2{1&apos;b0}}, 2&apos;h3};
            8&apos;d32: sel = {{BITSIZE_sel-4{1&apos;b0}}, 4&apos;hf};
            8&apos;d64: sel = {{BITSIZE_sel-8{1&apos;b0}}, 8&apos;hff};
            8&apos;d128: sel = {{BITSIZE_sel-16{1&apos;b0}}, 16&apos;hffff};
            default: sel = {BITSIZE_sel{1&apos;b1}};
          endcase
     end
endgenerate
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_waddress_FU</name>
      <circuit>
        <component_o id="register_waddress_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="register_waddress_FU"/>
          <parameter name="ALLOCATED_ADDRESS">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="address" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wenable" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ack" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_waddress_FU in1 address out1 ALLOCATED_ADDRESS" VERILOG_PROVIDED="
wire ack_temp;
reg [BITSIZE_out1-1:0] reg_out1 1INIT_ZERO_VALUE;
assign out1 = reg_out1;
assign ack_temp = ALLOCATED_ADDRESS == address;
assign ack = ack_temp;
always @(posedge clock 1RESET_EDGE)
  if (1RESET_VALUE)
    reg_out1 &lt;= {BITSIZE_out1{1&apos;b0}};
  else if (wenable &amp;&amp; ack_temp)
    reg_out1 &lt;= in1;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>wishbone_start_controller_FU</name>
      <circuit>
        <component_o id="wishbone_start_controller_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="wishbone_start_controller_FU"/>
          <parameter name="START_REGISTER_ADDRESS">0</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="cyc_is" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="weI_CS" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_is_f" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dat_is" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="start_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ack_startAndWait" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="startAndWaitRead" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="startRegValue" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="wishbone_start_controller_FU addr_is_f dat_is startRegValue START_REGISTER_ADDRESS" VERILOG_PROVIDED="
reg startAndWaitRead;
reg [1:0]                  startAndWait 1INIT_ZERO_VALUE;
reg [1:0]                  startAndWait_next;
reg [BITSIZE_dat_is-1:0]  ackAddress 1INIT_ZERO_VALUE;
reg [BITSIZE_dat_is-1:0]  ackAddress_next;

assign startRegValue = {ackAddress[BITSIZE_dat_is-1:2], startAndWait};

always @ (weI_CS or addr_is_f)
if (!weI_CS &amp;&amp;
addr_is_f == START_REGISTER_ADDRESS)
startAndWaitRead = 1&apos;b1;
else
startAndWaitRead = 1&apos;b0;

assign start_port = startAndWait[0];
assign ack_startAndWait = addr_is_f == START_REGISTER_ADDRESS &amp; cyc_is;

always @ (posedge clock 1RESET_EDGE)
  if (1RESET_VALUE)
  begin
    startAndWait = 2&apos;b00;
    ackAddress = {BITSIZE_dat_is{1&apos;b0}};
  end
else
begin
  startAndWait = startAndWait_next;
  ackAddress = ackAddress_next;
end

always @ (done_port, ack_startAndWait, startAndWait, startAndWaitRead)
if (startAndWait == 2&apos;b00) begin
if (ack_startAndWait &amp; !startAndWaitRead) begin
startAndWait_next = 2&apos;b01;ackAddress_next = dat_is;
end
else begin
startAndWait_next = 2&apos;b00;
ackAddress_next = ackAddress;
end
end else if (startAndWait == 2&apos;b01) begin
ackAddress_next = ackAddress;
if (done_port)
startAndWait_next = 2&apos;b10;
else
startAndWait_next = 2&apos;b01;
end else if (startAndWait == 2&apos;b10) begin
if (ack_startAndWait &amp; startAndWaitRead) begin
startAndWait_next = 2&apos;b00;
ackAddress_next = {BITSIZE_dat_is{1&apos;b0}};
end
else begin
startAndWait_next = 2&apos;b10;
ackAddress_next = ackAddress;
end
end
else begin
startAndWait_next = 2&apos;b00;
ackAddress_next = {BITSIZE_dat_is{1&apos;b0}};
end
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>notify_caller_FU</name>
      <circuit>
        <component_o id="notify_caller_FU">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="notify_caller_FU"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="status_reg" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ack_im" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="cyc_om" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="stb_om" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_om" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_om" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="outctrl" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="notify_caller_FU addr_om status_reg" VERILOG_PROVIDED="
reg [BITSIZE_addr_om-1:0] addr_om;
reg cyc_om;
reg stb_om;
reg we_om;
reg outctrl;
reg state 1INIT_ZERO_VALUE;
reg state_next;
wire [BITSIZE_status_reg-1:0] notify_addr;

assign notify_addr = {status_reg[BITSIZE_status_reg-1:2], {2{1&apos;b0}}};

always @ (posedge clock 1RESET_EDGE)
  if (1RESET_VALUE)
    begin
       state &lt;= 1&apos;b0;
    end
  else
    begin
       state &lt;= state_next;
    end

always @ (*)
  begin
     state_next = 1&apos;b0;
     cyc_om  = 1&apos;b0;
     stb_om  = 1&apos;b0;
     addr_om = {BITSIZE_addr_om{1&apos;b0}};
     we_om   = 1&apos;b0;
     outctrl = 1&apos;b0;
     if (state == 1&apos;b0)
       begin
          if (done_port == 1&apos;b1 &amp;&amp; (| notify_addr))
            begin
               state_next = 1&apos;b1;
               cyc_om  = 1&apos;b1;
               stb_om  = 1&apos;b1;
               addr_om = notify_addr;
               we_om   = 1&apos;b1;
               outctrl = 1&apos;b1;
            end
          else
            state_next = 1&apos;b0;
       end
     else
       begin
          cyc_om  = 1&apos;b1;
          stb_om  = 1&apos;b1;
          addr_om = notify_addr;
          we_om   = 1&apos;b1;
          outctrl = 1&apos;b1;
          if (ack_im == 1&apos;b1)
            state_next = 1&apos;b0;
          else
            state_next = 1&apos;b1;
       end
  end
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>not_internal_component</name>
      <circuit>
        <component_o id="not_internal_component">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="not_internal_component"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we1" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="oe1" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="internal1" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="not_internal_component" VERILOG_PROVIDED="
reg oe_int_delayed 1INIT_ZERO_VALUE;
assign out1 = !((we1 &amp; internal1) | oe_int_delayed);
always @(posedge clock)
  oe_int_delayed &lt;= oe1 &amp; internal1;
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>__builtin_wait_call</name>
      <operation operation_name="__builtin_wait_call" execution_time="0" bounded="0"/>
      <channels_type>MEM_ACC_11,MEM_ACC_N1</channels_type>
      <circuit>
        <component_o id="__builtin_wait_call">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="__builtin_wait_call"/>
          <parameter name="unlock_address">0</parameter>
          <parameter name="MEMORY_INIT_file">&quot;&quot;parameter_address.mem&quot;&quot;</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="var_arg" dir="IN" is_var_args="1">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="done_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_o>
          <port_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="unlock_address MEMORY_INIT_file Min_oe_ram Mout_oe_ram Min_we_ram Mout_we_ram Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size M_DataRdy S_addr_ram S_Wdata_ram Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size" VERILOG_GENERATOR="BuiltinWaitCallModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>__builtin_wait_callN</name>
      <operation operation_name="__builtin_wait_call" execution_time="0" bounded="0"/>
      <channels_type>MEM_ACC_NN</channels_type>
      <circuit>
        <component_o id="__builtin_wait_callN">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="__builtin_wait_callN"/>
          <parameter name="unlock_address">0</parameter>
          <parameter name="MEMORY_INIT_file">&quot;&quot;parameter_address.mem&quot;&quot;</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="var_arg" dir="IN" is_var_args="1">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="done_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="Min_oe_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_we_ram" dir="IN" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_addr_ram" dir="IN" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_Wdata_ram" dir="IN" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Min_data_ram_size" dir="IN" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_oe_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_we_ram" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="S_addr_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="S_Wdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sin_Rdata_ram" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="Sout_Rdata_ram" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="8"/>
          </port_vector_o>
          <port_vector_o id="S_data_ram_size" dir="IN" is_memory="1" is_global="1" is_extern="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Sin_DataRdy" dir="IN" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Sout_DataRdy" dir="OUT" is_memory="1" is_slave="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="unlock_address MEMORY_INIT_file Min_oe_ram Mout_oe_ram Min_we_ram Mout_we_ram Min_addr_ram Mout_addr_ram M_Rdata_ram Min_Wdata_ram Mout_Wdata_ram Min_data_ram_size Mout_data_ram_size M_DataRdy S_oe_ram S_we_ram S_addr_ram S_Wdata_ram  Sin_Rdata_ram Sout_Rdata_ram S_data_ram_size Sin_DataRdy Sout_DataRdy" VERILOG_GENERATOR="BuiltinWaitCallNModuleGenerator"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>intercon_arbiter</name>
      <circuit>
        <component_o id="intercon_arbiter">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="intercon_arbiter"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="arb_requests" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="arb_grant" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="intercon_arbiter arb_requests arb_grant" VERILOG_PROVIDED="
   reg  [PORTSIZE_arb_grant-1:0] arb_grant 1INIT_ZERO_VALUE;
   reg  [PORTSIZE_arb_grant-1:0] arb_grant_next;

   always @ (arb_requests, arb_grant)
     begin : ARBITER
        integer i, busy, stop;

        busy = 0;
        stop = 0;

        for (i = 0; i &lt; PORTSIZE_arb_requests; i = i + 1)
          if (arb_requests[i] == arb_grant[i] &amp;&amp; arb_grant[i] == 1&apos;b1)
            busy = 1;

        if (busy == 1)
          // I don&apos;t want to interrupt ongoing cycles.
          arb_grant_next = arb_grant;
        else
          for (i = 0; i &lt; PORTSIZE_arb_requests; i = i + 1)
            if (stop == 0 &amp;&amp; arb_requests[i] == 1&apos;b1) begin
               arb_grant_next[i] = 1&apos;b1;
               stop = 1;
            end else
              arb_grant_next[i] = 1&apos;b0;
     end

   always @ (posedge clock 1RESET_EDGE)
     if (1RESET_VALUE) begin
        arb_grant = {PORTSIZE_arb_grant{1&apos;b0}};
     end
     else begin
        arb_grant = arb_grant_next;
      end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>wb4Intercon</name>
      <circuit>
        <component_o id="wb4Intercon">
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2012-2023 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;, Marco Minutoli &lt;mminutoli@gmail.com&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="wb4Intercon"/>
          <parameter name="MASTERS">1</parameter>
          <parameter name="SLAVES">1</parameter>
          <parameter name="ADDR_BUS_SIZE">1</parameter>
          <parameter name="DATA_BUS_SIZE">1</parameter>
          <parameter name="SEL_BUS_SIZE">1</parameter>
          <parameter name="MEMORY_INIT_file">&quot;&quot;array.mem&quot;&quot;</parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="cyc_om" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="stb_om" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="we_om" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_om" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="addr_om" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dat_om" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="ack_im" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dat_im" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="cyc_is" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="stb_is" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="we_is" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="sel_is" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="addr_is" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dat_is" dir="OUT" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="ack_os" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="dat_os" dir="IN" is_memory="1" is_slave="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="wb4Intercon MASTERS SLAVES MEMORY_INIT_file cyc_om stb_om we_om sel_om addr_om dat_om ack_im dat_im cyc_is stb_is we_is sel_is addr_is dat_is ack_os dat_os" IP_COMPONENT="intercon_arbiter" VERILOG_PROVIDED="
// Internal wires
wire [MASTERS-1:0]                 arb_grant;
reg [SLAVES-1:0]                  requested_slave;

// Common Master bus
reg                               mst_comm_cyc_o, mst_comm_stb_o, mst_comm_we_o;
reg [BITSIZE_sel_om-1:0]            mst_comm_sel_o;
reg [BITSIZE_addr_om-1:0]           mst_comm_addr_o;
reg [BITSIZE_dat_om-1:0]           mst_comm_dat_o;

// Common Slave bus
reg [BITSIZE_dat_om-1:0]           slv_comm_dat_o;
reg                               slv_comm_ack_o;

// Address rom
reg [BITSIZE_addr_om-1:0]           slave_addresses [2*SLAVES-1:0];

reg [(PORTSIZE_cyc_om*BITSIZE_cyc_om)+(-1):0] cyc_om_next 1INIT_ZERO_VALUE;
reg [(PORTSIZE_stb_om*BITSIZE_stb_om)+(-1):0] stb_om_next 1INIT_ZERO_VALUE;
reg [(PORTSIZE_we_om*BITSIZE_we_om)+(-1):0]   we_om_next 1INIT_ZERO_VALUE;
reg [(PORTSIZE_sel_om*BITSIZE_sel_om)+(-1):0] sel_om_next 1INIT_ZERO_VALUE;
reg [(PORTSIZE_addr_om*BITSIZE_addr_om)+(-1):0] addr_om_next 1INIT_ZERO_VALUE;
reg [(PORTSIZE_dat_om*BITSIZE_dat_om)+(-1):0]   dat_om_next 1INIT_ZERO_VALUE;

always @ (posedge clock 1RESET_EDGE)
  begin
     if (1RESET_VALUE)
       begin
          cyc_om_next  = {(PORTSIZE_ack_im*BITSIZE_ack_im){1&apos;b0}};  
          stb_om_next  = {(PORTSIZE_stb_om*BITSIZE_stb_om){1&apos;b0}};  
          we_om_next   = {(PORTSIZE_we_om*BITSIZE_we_om){1&apos;b0}};   
          sel_om_next  = {(PORTSIZE_sel_om*BITSIZE_sel_om){1&apos;b0}};  
          addr_om_next = {(PORTSIZE_addr_om*BITSIZE_addr_om){1&apos;b0}};
          dat_om_next  = {(PORTSIZE_dat_om*BITSIZE_dat_om){1&apos;b0}};
       end
     else
       begin
          cyc_om_next  = cyc_om;  
          stb_om_next  = stb_om;  
          we_om_next   = we_om;   
          sel_om_next  = sel_om;  
          addr_om_next = addr_om;
          dat_om_next  = dat_om;
       end
  end
 
initial
  begin
     slave_addresses[0] = {BITSIZE_addr_om{1&apos;b0}};
     slave_addresses[1] = {BITSIZE_addr_om{1&apos;b0}};
     $readmemb(MEMORY_INIT_file, slave_addresses, 2, 2*SLAVES-1);
  end

generate
genvar                            idx;
   for (idx = 0; idx &lt; SLAVES; idx = idx + 1)
     begin: mst_to_slv_common_bus
        assign cyc_is  [idx] = requested_slave[idx] ? mst_comm_cyc_o  : 1&apos;b0;
        assign stb_is  [idx] = requested_slave[idx] ? mst_comm_stb_o  : 1&apos;b0;
        assign we_is   [idx] = requested_slave[idx] ? mst_comm_we_o   : 1&apos;b0;
        assign sel_is  [idx * BITSIZE_sel_om+:BITSIZE_sel_om]   = requested_slave[idx] ? mst_comm_sel_o  : {BITSIZE_sel_om{1&apos;b0}};
        assign addr_is [idx * BITSIZE_addr_om+:BITSIZE_addr_om] = requested_slave[idx] ? mst_comm_addr_o : {BITSIZE_addr_om{1&apos;b0}};
        assign dat_is  [idx * BITSIZE_dat_om+:BITSIZE_dat_om] = requested_slave[idx] ? mst_comm_dat_o  : {BITSIZE_dat_om{1&apos;b0}};
     end
endgenerate

generate
   for (idx = 0; idx &lt; MASTERS; idx = idx + 1)
     begin: slv_to_mst_common_bus
        assign ack_im [idx] = arb_grant[idx] ? slv_comm_ack_o : 1&apos;b0;
        assign dat_im [idx * BITSIZE_dat_om+:BITSIZE_dat_om] = arb_grant[idx] ? slv_comm_dat_o : {BITSIZE_dat_om{1&apos;b0}};
     end
endgenerate

// Master Muxes
always @ (*)
  begin : MST_MUX
     integer i;

     mst_comm_cyc_o = 1&apos;b0;
     mst_comm_stb_o = 1&apos;b0;
     mst_comm_we_o = 1&apos;b0;
     mst_comm_sel_o = {BITSIZE_sel_om{1&apos;b0}};
     mst_comm_addr_o = {BITSIZE_addr_om{1&apos;b0}};
     mst_comm_dat_o = {BITSIZE_dat_om{1&apos;b0}};

     for (i = 0; i &lt; MASTERS; i = i + 1) begin
        // Grant the master
        if (arb_grant[i] == 1) begin
           mst_comm_cyc_o  = cyc_om_next[i];
           mst_comm_stb_o  = stb_om_next[i];
           mst_comm_we_o   = we_om_next[i];
           mst_comm_sel_o  = sel_om_next[(i*BITSIZE_sel_om)+:BITSIZE_sel_om];
           mst_comm_addr_o = addr_om_next[(i*BITSIZE_addr_om)+:BITSIZE_addr_om];
           mst_comm_dat_o  = dat_om_next[(i*BITSIZE_dat_om)+:BITSIZE_dat_om];
        end
     end
  end

always @ (*)
  begin : SLV_MUX
     integer j;

     slv_comm_ack_o = 1&apos;b0;
     slv_comm_dat_o = {BITSIZE_dat_om{1&apos;b0}};

     for (j = 0; j &lt; SLAVES; j = j + 1) begin
        if (requested_slave[j] == 1&apos;b1) begin
           slv_comm_ack_o = ack_os[j];
           slv_comm_dat_o = dat_os[j*BITSIZE_dat_om+:BITSIZE_dat_om];
        end
     end
  end

always @ (*) begin : RQS_SLAVE
     integer j;
   for (j = 1; j &lt; SLAVES; j = j + 1)
     begin
        if (mst_comm_addr_o[BITSIZE_addr_om-1:0] &gt;= slave_addresses[2 * j] &amp;&amp;
            mst_comm_addr_o[BITSIZE_addr_om-1:0] &lt;= slave_addresses[2 * j + 1])
          requested_slave[j] = 1&apos;b1;
        else
          requested_slave[j] = 1&apos;b0;
     end
   requested_slave[0] = (~| requested_slave[SLAVES - 1:1]);
end

intercon_arbiter #(.PORTSIZE_arb_requests(MASTERS), .PORTSIZE_arb_grant(MASTERS)) wb_arbiter(clock, reset, cyc_om, arb_grant);
"/>
        </component_o>
      </circuit>
    </cell>
  </library>
</technology>