<?xml version="1.0"?>
<technology>
  <library>
    <name>STD_FU</name>
    <cell>
      <name>IOB_front_end</name>
      <circuit>
        <component_o id="IOB_front_end">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_front_end"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_BYTE_W"> 2 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_valid_reg" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_addr_reg" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_wdata_reg" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_wstrb_reg" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ctrl_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ctrl_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ctrl_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ctrl_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_front_end FE_ADDR_W CTRL_CACHE CTRL_CNT addr wdata wstrb rdata data_addr data_rdata data_addr_reg data_wdata_reg data_wstrb_reg ctrl_addr ctrl_rdata" VERILOG_PROVIDED="
`define CTRL_ADDR_W 4
localparam FE_DATA_W = BITSIZE_wdata;
localparam FE_NBYTES = BITSIZE_wstrb;
localparam FE_BYTE_W = $clog2(FE_NBYTES);
wire valid_int;

reg valid_reg;
reg valid_reg_next;
reg [FE_ADDR_W-1:FE_BYTE_W] addr_reg;
reg [FE_ADDR_W-1:FE_BYTE_W] addr_reg_next;
reg [FE_DATA_W-1:0] wdata_reg;
reg [FE_DATA_W-1:0] wdata_reg_next;
reg [FE_NBYTES-1:0] wstrb_reg;
reg [FE_NBYTES-1:0] wstrb_reg_next;
   
//////////////////////////////////////////////////////////////////////////////////
  //    Cache-selection - cache-memory or cache-control 
/////////////////////////////////////////////////////////////////////////////////
generate
  if(CTRL_CACHE) 
  begin
    //Front-end output signals
    assign ready = ctrl_ready | data_ready;
    assign rdata = (ctrl_ready)? ctrl_rdata  : data_rdata;
    assign valid_int  = ~addr[CTRL_CACHE + FE_ADDR_W -1 - FE_BYTE_W] &amp; valid;
    assign ctrl_valid =  addr[CTRL_CACHE + FE_ADDR_W -1 - FE_BYTE_W] &amp; valid;       
    assign ctrl_addr  =  addr[FE_BYTE_W - FE_BYTE_W +: `CTRL_ADDR_W];      
  end
  else 
  begin
    //Front-end output signals
    assign ready = data_ready; 
    assign rdata = data_rdata;    
    assign valid_int = valid;    
    assign ctrl_valid = 1&apos;bx;
    assign ctrl_addr = `CTRL_ADDR_W&apos;dx;    
  end
endgenerate

//////////////////////////////////////////////////////////////////////////////////
// Input Data stored signals
/////////////////////////////////////////////////////////////////////////////////

always @(posedge clock 1RESET_EDGE)
begin
  if(1RESET_VALUE)
  begin
    valid_reg &lt;= 0;
    addr_reg  &lt;= 0;
    wdata_reg &lt;= 0;
    wstrb_reg &lt;= 0;    
  end
  else 
  begin
    valid_reg &lt;= valid_reg_next;
    addr_reg  &lt;= addr_reg_next;
    wdata_reg &lt;= wdata_reg_next;
    wstrb_reg &lt;= wstrb_reg_next; 
  end
end

always @(*)
begin
  if(ready) 
  begin
    valid_reg_next = 0;
    addr_reg_next  = 0;
    wdata_reg_next = 0;
    wstrb_reg_next = 0;
  end
  else if(valid)
  begin
    valid_reg_next = valid_int;
    addr_reg_next  = addr[FE_ADDR_W-1 - FE_BYTE_W : 0];
    wdata_reg_next = wdata;
    wstrb_reg_next = wstrb;
  end
  else
  begin
    valid_reg_next = valid_reg;
    addr_reg_next  = addr_reg;
    wdata_reg_next = wdata_reg;
    wstrb_reg_next = wstrb_reg;
  end
end


//////////////////////////////////////////////////////////////////////////////////
// Data-output ports
/////////////////////////////////////////////////////////////////////////////////

assign data_addr  = addr[FE_ADDR_W-1 - FE_BYTE_W : 0];
assign data_valid = valid_int | valid_reg;
assign data_addr_reg  = addr_reg[FE_ADDR_W-1 : FE_BYTE_W];
assign data_wdata_reg = wdata_reg;
assign data_wstrb_reg = wstrb_reg;
assign data_valid_reg = valid_reg;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_read_channel_axi</name>
      <circuit>
        <component_o id="IOB_read_channel_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_read_channel_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <parameter name="BURST_TYPE"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_read_channel_axi FE_ADDR_W FE_DATA_W WORD_OFF_W BE_ADDR_W AXI_ID BURST_TYPE replace_addr read_addr read_rdata m_axi_arid m_axi_araddr m_axi_arlen m_axi_rid m_axi_rdata" VERILOG_PROVIDED="
localparam LINE2MEM_W = BITSIZE_read_addr;
localparam BE_BYTE_W = $clog2(BITSIZE_read_rdata/8);

reg [BITSIZE_read_addr - 1 : 0] read_addr;
reg replace;

reg m_axi_arvalid_int;
reg m_axi_rready_int;

assign m_axi_arvalid = m_axi_arvalid_int;
assign m_axi_rready = m_axi_rready_int;
assign m_axi_arqos = &apos;b0;
        
generate
  if(LINE2MEM_W &gt; 0)
  begin
    //Constant AXI signals
    assign m_axi_arid    = AXI_ID;
    assign m_axi_arlock  = 1&apos;b0;
    assign m_axi_arcache = 4&apos;b0011;
    assign m_axi_arprot  = 3&apos;d0;
    //Burst parameters
    assign m_axi_arlen   = 2**LINE2MEM_W -1; //will choose the burst lenght depending on the cache&apos;s and slave&apos;s data width
    assign m_axi_arsize  = BE_BYTE_W; //each word will be the width of the memory for maximum bandwidth
    assign m_axi_arburst = 2&apos;b01; //incremental burst
    assign m_axi_araddr  = {BE_ADDR_W{1&apos;b0}} + {replace_addr, {(LINE2MEM_W+BE_BYTE_W){1&apos;b0}}}; //base address for the burst, with width extension 

    // Read Line values
    assign read_rdata = m_axi_rdata;
    assign read_valid = m_axi_rvalid;

    localparam
      idle          = 2&apos;d0,
      init_process  = 2&apos;d1,
      load_process  = 2&apos;d2,
      end_process   = 2&apos;d3;
      
    reg [1:0] state;   
    always @(posedge clock 1RESET_EDGE)
    begin
      if(1RESET_VALUE)
      begin
        state &lt;= idle;
        read_addr &lt;= 0;
      end
      else
      begin
        case (state)   
          idle:
          begin
            read_addr &lt;= 0;  
            if(replace_valid)
            begin
              state &lt;= init_process;
            end
            else
            begin
              state &lt;= idle;
            end
          end

          init_process:
          begin
            read_addr &lt;= 0;  
            if(m_axi_arready)
            begin
              state &lt;= load_process;
            end
            else
            begin
              state &lt;= init_process;
            end
          end

          load_process:
          begin
            if(m_axi_rvalid)
            begin
              if(m_axi_rlast)
              begin
                state &lt;= end_process;
                read_addr &lt;= read_addr; //to avoid writting last data in first line word
              end
              else
              begin
                read_addr &lt;= read_addr +1;
                state &lt;= load_process;
              end
            end
            else
            begin
              read_addr &lt;= read_addr;
              state &lt;= load_process;
            end
          end

          default:
              state &lt;= idle;              
        endcase
      end
    end

    always @(*)
    begin
      m_axi_arvalid_int   = 1&apos;b0;
      m_axi_rready_int    = 1&apos;b0;
      replace = 1&apos;b1;
      case(state)
        idle:
        begin
          replace = 1&apos;b0;
        end
        
        init_process:
        begin
          m_axi_arvalid_int = 1&apos;b1;
        end

        default:
        begin
          m_axi_rready_int  = 1&apos;b1;
        end        
      endcase
    end
  end
  else    
  begin
    //Constant AXI signals
    assign m_axi_arid    = AXI_ID;
    assign m_axi_arlock  = 1&apos;b0;
    assign m_axi_arcache = 4&apos;b0011;
    assign m_axi_arprot  = 3&apos;d0;
    //Burst parameters - single 
    assign m_axi_arlen   = 8&apos;d0; //A single burst of Memory data width word
    assign m_axi_arsize  = BE_BYTE_W; //each word will be the width of the memory for maximum bandwidth
    assign m_axi_arburst = BURST_TYPE; 
    assign m_axi_araddr  = {BE_ADDR_W{1&apos;b0}} + {replace_addr, {BE_BYTE_W{1&apos;b0}}}; //base address for the burst, with width extension 

    // Read Line values
    assign read_valid = m_axi_rvalid;
    assign read_rdata  = m_axi_rdata;    
    
    localparam
      idle          = 2&apos;d0,
      init_process  = 2&apos;d1,
      load_process  = 2&apos;d2,
      end_process   = 2&apos;d3;    
    
    reg [1:0] state;
    
    always @(posedge clock 1RESET_EDGE)
    begin
      if(1RESET_VALUE)
      begin    
        state &lt;= idle;
      end
      else
      begin    
        case (state)   
          idle:
          begin
            if(replace_valid)
            begin
              state &lt;= init_process;
            end
            else
            begin
              state &lt;= idle;
            end
          end

          init_process:
          begin                      
            if(m_axi_arready)
            begin
              state &lt;= load_process;
            end
            else
            begin
              state &lt;= init_process;
            end
          end

          load_process:
          begin
            if(m_axi_rvalid)
            begin
              state &lt;= end_process;
            end
            else
            begin
              state &lt;= load_process;
            end
          end

          end_process:
          begin
            state &lt;= idle;
          end          
          
          default:;
        endcase
      end
    end    
    
    always @(*)
    begin
      m_axi_arvalid_int   = 1&apos;b0;
      m_axi_rready_int    = 1&apos;b0;
      replace = 1&apos;b1;
      case(state)
        idle:
        begin
          replace = 1&apos;b0;
        end
        
        init_process:
        begin
          m_axi_arvalid_int = 1&apos;b1;
        end

        load_process:
        begin
          m_axi_rready_int  = 1&apos;b1;             
        end
        
        default:;        
      endcase
    end      
  end     
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_write_channel_axi</name>
      <circuit>
        <component_o id="IOB_write_channel_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_write_channel_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_DATA_W"> 32 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <parameter name="BURST_TYPE"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="b_done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_write_channel_axi FE_ADDR_W FE_DATA_W BE_ADDR_W BE_DATA_W AXI_ID WRITE_POL WORD_OFF_W BURST_TYPE addr wdata wstrb m_axi_awid m_axi_awaddr m_axi_awlen m_axi_wdata m_axi_wstrb m_axi_bid" VERILOG_PROVIDED="
//Write Policy
`define WRITE_THROUGH 0 //write-through not allocate: implements a write-through buffer
`define WRITE_BACK 1    //write-back allocate: implementes a dirty-memory

localparam FE_NBYTES = BITSIZE_wstrb;
localparam FE_BYTE_W = $clog2(FE_NBYTES);
localparam BE_NBYTES = BE_DATA_W / 8;
localparam BE_BYTE_W = $clog2(BE_NBYTES);
localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);

reg ready;
reg m_axi_awvalid_int;
reg m_axi_wvalid_int;
reg m_axi_bready_int;

assign m_axi_awvalid = m_axi_awvalid_int;
assign m_axi_wvalid = m_axi_wvalid_int;
assign m_axi_awqos = &apos;b0;

// Write failed signals
assign b_done = m_axi_bvalid;
reg [BITSIZE_addr - 1:0] reg_addr;
reg [FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)-1 :0]  reg_wdata;

localparam
  aw_idle     = 2&apos;b00,
  aw_address  = 2&apos;b01,
  aw_wait     = 2&apos;b10;
        
localparam
  w_idle      = 1&apos;b0,
  w_active    = 1&apos;b1;

reg [1:0] aw_state;
reg [0:0] w_state;         

genvar i;
generate
  if(WRITE_POL == `WRITE_THROUGH) 
  begin
    //Constant AXI signals
    assign m_axi_awid    = AXI_ID;
    assign m_axi_awlen   = 8&apos;d0;
    assign m_axi_awsize  = BE_BYTE_W; // verify - Writes data of the size of BE_DATA_W
    assign m_axi_awburst = BURST_TYPE;
    assign m_axi_awlock  = 1&apos;b0; // 00 - Normal Access
    assign m_axi_awcache = 4&apos;b0011;
    assign m_axi_awprot  = 3&apos;d0;
    assign m_axi_wlast   = m_axi_wvalid_int;
    assign m_axi_bready  = 1&apos;b1;
    //AXI Buffer Output signals
    assign m_axi_awaddr = {BE_ADDR_W{1&apos;b0}} + {addr[FE_ADDR_W-1 - BE_BYTE_W : (BE_BYTE_W - FE_BYTE_W)], {BE_BYTE_W{1&apos;b0}}};
            
    if(BE_DATA_W == FE_DATA_W)
    begin
      assign m_axi_wstrb = wstrb;
      assign m_axi_wdata = reg_wdata;
    end
    else
    begin
      wire [BE_BYTE_W - FE_BYTE_W -1 :0] word_align = reg_addr[0 +: (BE_BYTE_W - FE_BYTE_W)];
      assign m_axi_wstrb = wstrb &lt;&lt; (word_align * FE_NBYTES);
      for (i = 0; i &lt; BE_DATA_W/FE_DATA_W; i = i +1) 
      begin : wdata_block
        assign m_axi_wdata[(i+1)*FE_DATA_W-1:i*FE_DATA_W] = reg_wdata;
      end
    end

    always @(posedge clock 1RESET_EDGE) 
    begin
      if(1RESET_VALUE) 
      begin
        aw_state &lt;= aw_idle;
        w_state &lt;= w_idle;
      end 
      else 
      begin
        case(aw_state) 
          aw_idle: 
          begin
            if(valid) 
            begin
              aw_state &lt;= aw_address;
            end 
            else
            begin
              aw_state  &lt;= aw_idle;
            end
          end
          aw_address: 
          begin
            if(m_axi_awready &amp;&amp; w_state == w_idle) 
            begin
              aw_state &lt;= aw_idle; /* Address written, can write data */
              w_state &lt;= w_active;
              reg_addr &lt;= addr;
              reg_wdata &lt;= wdata;
            end 
            else 
            begin
              if (m_axi_awready)  
              begin   
                aw_state &lt;= aw_wait; /* Address written, but data channel busy */
              end
              else
              begin
                aw_state &lt;= aw_address; /* Address not written yet */
              end
            end
          end
          aw_wait : 
          begin
            if(w_state == w_idle) 
            begin
              aw_state &lt;= aw_idle;
              w_state &lt;= w_active;
              reg_addr &lt;= addr;
              reg_wdata &lt;= wdata;
            end 
            else
            begin
              aw_state &lt;= aw_wait;
            end
          end
          default : 
          begin
            aw_state &lt;= aw_idle;
            w_state &lt;= w_idle;
          end
        endcase
        
        if(w_state == w_active &amp;&amp; m_axi_wready)
        begin
          w_state &lt;= w_idle;
        end
      end  
    end
  end 
  else 
  begin
    if(LINE2MEM_W &gt; 0) 
    begin
      //Constant AXI signals
      assign m_axi_awid    = AXI_ID;
      assign m_axi_awlock  = 1&apos;b0;
      assign m_axi_awcache = 4&apos;b0011;
      assign m_axi_awprot  = 3&apos;d0;

      //Burst parameters
      assign m_axi_awlen   = 2**LINE2MEM_W -1; //will choose the burst lenght depending on the cache&apos;s and slave&apos;s data width
      assign m_axi_awsize  = BE_BYTE_W; //each word will be the width of the memory for maximum bandwidth
      assign m_axi_awburst = 2&apos;b01; //incremental burst
      assign m_axi_bready  = 1&apos;b1;

      //memory address
      assign m_axi_awaddr  = {BE_ADDR_W{1&apos;b0}} + {addr, {(FE_BYTE_W+WORD_OFF_W){1&apos;b0}}}; //base address for the burst, with width extension

      // memory write-data
      reg [LINE2MEM_W-1:0] word_counter = &apos;b0;
      assign m_axi_wdata = reg_wdata >> (word_counter*BE_DATA_W);
      assign m_axi_wstrb = {BE_NBYTES{1&apos;b1}};
      assign m_axi_wlast = &amp;word_counter &amp; m_axi_wvalid;  

      always @(posedge clock 1RESET_EDGE) 
      begin
        if(1RESET_VALUE) 
        begin
          aw_state &lt;= aw_idle;
          w_state &lt;= w_idle;
        end 
        else 
        begin
          case(aw_state) 
            aw_idle: 
            begin
              if(valid) 
              begin
                aw_state &lt;= aw_address;
              end 
              else
              begin
                aw_state  &lt;= aw_idle;
              end
            end
            aw_address: 
            begin
              if(m_axi_awready &amp;&amp; w_state == w_idle) 
              begin
                aw_state &lt;= aw_idle; /* Address written, can write data */
                w_state &lt;= w_active;
                reg_wdata &lt;= wdata;
              end 
              else 
              if (m_axi_awready)  
              begin   
                aw_state &lt;= aw_wait; /* Address written, but data channel busy */
              end
              else
              begin
                aw_state &lt;= aw_address; /* Address not written yet */
              end
            end
            aw_wait: 
            begin
              if(w_state == w_idle) 
              begin
                aw_state &lt;= aw_idle;
                w_state &lt;= w_active;
                reg_wdata &lt;= wdata;
              end 
              else
              begin
                aw_state &lt;= aw_wait;
              end
            end
            default : 
            begin
              aw_state &lt;= aw_idle;
              w_state &lt;= w_idle;
            end
          endcase
          
          if(w_state == w_active) 
          begin
            if(m_axi_wready &amp;&amp; (&amp;word_counter)) 
            begin
              w_state &lt;= w_idle;
              word_counter &lt;= &apos;b0;
            end 
            else if(m_axi_wready) 
            begin
              word_counter &lt;= word_counter + 1;
              w_state &lt;= w_active;
            end
          end
        end  
      end
    end
    else 
    begin 
      //Constant AXI signals
      assign m_axi_awid    = AXI_ID;
      assign m_axi_awlock  = 1&apos;b0;
      assign m_axi_awcache = 4&apos;b0011;
      assign m_axi_awprot  = 3&apos;d0;

      //Burst parameters - single
      assign m_axi_awlen   = 8&apos;d0; //A single burst of Memory data width word
      assign m_axi_awsize  = BE_BYTE_W; //each word will be the width of the memory for maximum bandwidth
      assign m_axi_awburst = BURST_TYPE;
      assign m_axi_bready  = 1&apos;b1;

      //memory address
      assign m_axi_awaddr  = {BE_ADDR_W{1&apos;b0}} + {addr, {BE_BYTE_W{1&apos;b0}}}; //base address for the burst, with width extension

      //memory write-data
      assign m_axi_wdata = reg_wdata;
      assign m_axi_wstrb = {BE_NBYTES{1&apos;b1}}; //uses entire bandwidth
      assign m_axi_wlast = m_axi_wvalid;

      always @(posedge clock 1RESET_EDGE) 
      begin
        if(1RESET_VALUE) 
        begin
          aw_state &lt;= aw_idle;
          w_state &lt;= w_idle;
        end 
        else 
        begin
          case(aw_state) 
            aw_idle: 
            begin
              if(valid) 
              begin
                aw_state &lt;= aw_address;
              end 
              else
              begin
                aw_state &lt;= aw_idle;
              end
            end
            aw_address: begin
              if(m_axi_awready &amp;&amp; w_state == w_idle) 
              begin
                aw_state &lt;= aw_idle; /* Address written, can write data */
                w_state &lt;= w_active;
                reg_wdata &lt;= wdata;
              end 
              else if (m_axi_awready) 
              begin    
                aw_state &lt;= aw_wait; /* Address written, but data channel busy */
              end
              else
              begin
                aw_state &lt;= aw_address;  /* Address not written yet */
              end
            end
            aw_wait : 
            begin
              if(w_state == w_idle) 
              begin
                aw_state &lt;= aw_idle;
                w_state &lt;= w_active;
                reg_wdata &lt;= wdata;
              end 
              else
              begin
                aw_state &lt;= aw_wait;
              end
            end
            default : 
            begin
              aw_state &lt;= aw_idle;
              w_state &lt;= w_idle;
            end
          endcase
          
          if(w_state == w_active) 
          begin
            if(m_axi_wready) 
            begin
              w_state &lt;= w_idle;
            end
          end
        end 
      end    
    end
  end
endgenerate

always @(*) 
begin
  m_axi_awvalid_int = 1&apos;b0;
  m_axi_wvalid_int  = 1&apos;b0;
  ready = 1&apos;b0;
  case(aw_state)
    aw_idle:
    begin
      ready = 1&apos;b1;
    end
    aw_address:
    begin
      m_axi_awvalid_int = 1&apos;b1;
    end
  endcase
  if(w_state == w_active) 
  begin
    m_axi_wvalid_int = 1&apos;b1;
  end
end 
`undef WRITE_THROUGH
`undef WRITE_BACK"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_back_end_axi</name>
      <circuit>
        <component_o id="IOB_back_end_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_back_end_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_NBYTES"> 4 </parameter>
          <parameter name="BE_BYTE_W"> 32 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <parameter name="BURST_TYPE"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_back_end_axi FE_ADDR_W FE_DATA_W WORD_OFF_W BE_ADDR_W WRITE_POL AXI_ID BURST_TYPE write_addr write_wdata write_wstrb replace_addr read_addr read_rdata m_axi_awid m_axi_awaddr m_axi_awlen m_axi_wdata m_axi_wstrb m_axi_bid m_axi_arid m_axi_araddr m_axi_arlen m_axi_rid m_axi_rdata" IP_COMPONENT="IOB_read_channel_axi,IOB_write_channel_axi" VERILOG_PROVIDED="
localparam FE_NBYTES = FE_DATA_W / 8;
localparam FE_BYTE_W = $clog2(FE_NBYTES);
localparam BE_DATA_W = BITSIZE_read_rdata;
localparam BE_NBYTES = BE_DATA_W / 8;
localparam BE_BYTE_W = $clog2(BE_NBYTES);
localparam AXI_ID_W = BITSIZE_m_axi_awid;
localparam AXI_ADDR_W = BITSIZE_m_axi_awaddr;
localparam AXI_DATA_W = BITSIZE_m_axi_wdata;
localparam AXI_LEN_W = BITSIZE_m_axi_awlen;

reg resetted = 0;
wire resetted_next;

always @(posedge clock)
begin
  if(1RESET_VALUE)
  begin
    resetted &lt;= 1;
  end
  else
  begin
    resetted &lt;= resetted_next;
  end
end

assign resetted_next = resetted;

IOB_read_channel_axi #(.FE_ADDR_W(FE_ADDR_W),
  .FE_DATA_W(FE_DATA_W),  
  .WORD_OFF_W(WORD_OFF_W),
  .BE_ADDR_W (BE_ADDR_W),
  .AXI_ID  (AXI_ID),
  .BURST_TYPE(BURST_TYPE),
  .BITSIZE_replace_addr(FE_ADDR_W - ($clog2(BE_DATA_W/8) + (WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W)))),
  .BITSIZE_read_addr(WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W)),
  .BITSIZE_read_rdata(BE_DATA_W),
  .BITSIZE_m_axi_arid(AXI_ID_W),
  .BITSIZE_m_axi_araddr(AXI_ADDR_W),
  .BITSIZE_m_axi_arlen(AXI_LEN_W),
  .BITSIZE_m_axi_rid(AXI_ID_W),
  .BITSIZE_m_axi_rdata(AXI_DATA_W))
read_fsm (.replace_valid (replace_valid &amp;&amp; resetted),
  .replace_addr (replace_addr),
  .replace (replace),
  .read_valid (read_valid),
  .read_addr (read_addr),
  .read_rdata (read_rdata),
  .m_axi_arid(m_axi_arid), //Address read channel ID
  .m_axi_araddr(m_axi_araddr), //Address read channel address
  .m_axi_arlen(m_axi_arlen), //Address read channel burst length
  .m_axi_arsize(m_axi_arsize), //Address read channel burst size. This signal indicates the size of each transfer in the burst
  .m_axi_arburst(m_axi_arburst), //Address read channel burst type
  .m_axi_arlock(m_axi_arlock), //Address read channel lock type
  .m_axi_arcache(m_axi_arcache), //Address read channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
  .m_axi_arprot(m_axi_arprot), //Address read channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
  .m_axi_arqos(m_axi_arqos), //Address read channel quality of service
  .m_axi_arvalid(m_axi_arvalid), //Address read channel valid
  .m_axi_arready(m_axi_arready), //Address read channel ready
  .m_axi_rid(m_axi_rid), //Read channel ID
  .m_axi_rdata(m_axi_rdata), //Read channel data
  .m_axi_rresp(m_axi_rresp), //Read channel response
  .m_axi_rlast(m_axi_rlast), //Read channel last word
  .m_axi_rvalid(m_axi_rvalid), //Read channel valid
  .m_axi_rready(m_axi_rready), //Read channel ready
  .clock(clock),
  .reset(reset));

IOB_write_channel_axi #(.FE_ADDR_W(FE_ADDR_W),
  .FE_DATA_W(FE_DATA_W),
  .BE_ADDR_W (BE_ADDR_W),
  .BE_DATA_W (BE_DATA_W),
  .WRITE_POL (WRITE_POL),
  .WORD_OFF_W(WORD_OFF_W),
  .AXI_ID(AXI_ID),
  .BURST_TYPE(BURST_TYPE),
  .BITSIZE_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
  .BITSIZE_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
  .BITSIZE_wstrb(FE_NBYTES),
  .BITSIZE_m_axi_awid(AXI_ID_W),
  .BITSIZE_m_axi_awaddr(AXI_ADDR_W),
  .BITSIZE_m_axi_awlen(AXI_LEN_W),
  .BITSIZE_m_axi_wdata(AXI_DATA_W),
  .BITSIZE_m_axi_wstrb(AXI_DATA_W / 8),
  .BITSIZE_m_axi_bid(AXI_ID_W))
write_fsm (.valid (write_valid &amp;&amp; resetted),
  .addr (write_addr),
  .wstrb (write_wstrb),
  .wdata (write_wdata),
  .ready (write_ready),
  .b_done(write_done),
  /* BEGIN m_axi_write_portmap.vh */
  .m_axi_awid(m_axi_awid), //Address write channel ID
  .m_axi_awaddr(m_axi_awaddr), //Address write channel address
  .m_axi_awlen(m_axi_awlen), //Address write channel burst length
  .m_axi_awsize(m_axi_awsize), //Address write channel burst size. This signal indicates the size of each transfer in the burst
  .m_axi_awburst(m_axi_awburst), //Address write channel burst type
  .m_axi_awlock(m_axi_awlock), //Address write channel lock type
  .m_axi_awcache(m_axi_awcache), //Address write channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
  .m_axi_awprot(m_axi_awprot), //Address write channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
  .m_axi_awqos(m_axi_awqos), //Address write channel quality of service
  .m_axi_awvalid(m_axi_awvalid), //Address write channel valid
  .m_axi_awready(m_axi_awready), //Address write channel ready
  .m_axi_wdata(m_axi_wdata), //Write channel data
  .m_axi_wstrb(m_axi_wstrb), //Write channel write strobe
  .m_axi_wlast(m_axi_wlast), //Write channel last word flag
  .m_axi_wvalid(m_axi_wvalid), //Write channel valid
  .m_axi_wready(m_axi_wready), //Write channel ready
  .m_axi_bid(m_axi_bid), //Write response channel ID
  .m_axi_bresp(m_axi_bresp), //Write response channel response
  .m_axi_bvalid(m_axi_bvalid), //Write response channel valid
  .m_axi_bready(m_axi_bready), //Write response channel ready
  /* END m_axi_write_portmap */
  .clock(clock),
  .reset(reset));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_ram_2p</name>
      <circuit>
        <component_o id="IOB_ram_2p">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_ram_2p"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="r_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_ram_2p w_addr w_data r_addr r_data" VERILOG_PROVIDED="
reg [BITSIZE_r_data - 1 : 0] r_data;
localparam DATA_W = BITSIZE_w_data;
localparam ADDR_W = BITSIZE_w_addr;

// Declare the RAM
reg [DATA_W-1:0] mem [(2**ADDR_W)-1:0];

integer index;
// Initialize the RAM
initial
begin
  for(index=0; index&lt;(2**ADDR_W); index=index+1)
  begin
    mem[index] = 0;
  end
end

//read port
always @(posedge clock)
begin
  if(r_en)
  begin
    r_data &lt;= mem[r_addr];
  end
end

//write port
always @(posedge clock)
begin
  if(w_en)
  begin
    mem[w_addr] &lt;= w_data;
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_ram_2p_asym</name>
      <circuit>
        <component_o id="IOB_ram_2p_asym">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_ram_2p_asym"/>
          <parameter name="W_DATA_W"> 0 </parameter>
          <parameter name="R_DATA_W"> 0 </parameter>
          <parameter name="ADDR_W"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ext_mem_w_en" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_w_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_w_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_r_en" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ext_mem_r_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_r_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="r_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_ram_2p_asym W_DATA_W R_DATA_W ADDR_W ext_mem_w_en ext_mem_w_data ext_mem_w_addr ext_mem_r_addr ext_mem_r_data w_data w_addr r_addr r_data" VERILOG_PROVIDED="
`define IOB_MAX(a,b) {((a) &gt; (b)) ? (a) : (b)}
`define IOB_MIN(a,b) {((a) &lt; (b)) ? (a) : (b)}

reg [BITSIZE_r_data - 1 : 0] r_data;

localparam MAXDATA_W = `IOB_MAX(W_DATA_W, R_DATA_W);
localparam MINDATA_W = `IOB_MIN(W_DATA_W, R_DATA_W);
localparam MINADDR_W = ADDR_W-$clog2(MAXDATA_W/MINDATA_W);//lower ADDR_W (higher DATA_W)
localparam W_ADDR_W = (W_DATA_W == MAXDATA_W) ? MINADDR_W : ADDR_W;
localparam R_ADDR_W = (R_DATA_W == MAXDATA_W) ? MINADDR_W : ADDR_W;
//determine the number of blocks N
localparam N = MAXDATA_W/MINDATA_W;

//symmetric memory block buses
//write buses
reg [N-1:0] en_wr;
reg [MINDATA_W-1:0] data_wr [N-1:0];
reg [MINADDR_W-1:0] addr_wr [N-1:0];

//read buses
wire [MINDATA_W-1:0] data_rd [N-1:0];
reg [MINADDR_W-1:0] addr_rd [N-1:0];

wire [MINDATA_W-1:0] data_rd_0 = data_rd[0];

//connect the buses
integer j,k,l;
generate
  if (W_DATA_W &gt; R_DATA_W) 
  begin
    //write parallel
    always @(*) 
    begin
      for (j=0; j &lt; N; j= j+1) 
      begin
        en_wr[j] = w_en;
        data_wr[j] = w_data[j*MINDATA_W +: MINDATA_W];
        addr_wr[j] = w_addr;
      end
    end

    //read serial
    always @(*) 
    begin
      for (k=0; k &lt; N; k= k+1) 
      begin
        addr_rd[k] = r_addr[R_ADDR_W-1-:W_ADDR_W];
      end
    end

    //read address register
    reg [(R_ADDR_W-W_ADDR_W)-1:0] r_addr_lsbs_reg;
    always @(posedge clock)
    begin
      if (r_en)
      begin
        r_addr_lsbs_reg &lt;= r_addr[(R_ADDR_W-W_ADDR_W)-1:0];
      end
    end

    //read mux
    always @(*) 
    begin
      r_data = 1&apos;b0;
      for (l=0; l &lt; N; l= l+1) 
      begin
        r_data = data_rd[r_addr_lsbs_reg];
      end
    end

  end 
  else  if (W_DATA_W &lt; R_DATA_W) 
  begin
    //write serial
    always @(*) 
    begin
      for (j=0; j &lt; N; j= j+1) 
      begin
        en_wr[j] = w_en &amp; (w_addr[(W_ADDR_W-R_ADDR_W)-1:0] == j);
        data_wr[j] = w_data;
        addr_wr[j] = w_addr[W_ADDR_W-1 -: R_ADDR_W];
      end
    end
    //read parallel
    always @(*) 
    begin
      r_data = 1&apos;b0;
      for (k=0; k &lt; N; k= k+1) 
      begin
        addr_rd[k] = r_addr;
        r_data[k*MINDATA_W +: MINDATA_W] = data_rd[k];
      end
    end
  end 
  else 
  begin
    //write serial
    always @(*) 
    begin
      en_wr[0] = w_en;
      data_wr[0] = w_data;
      addr_wr[0] = w_addr;
    end
    //read parallel
    always @(*) 
    begin
      addr_rd[0] = r_addr;
      r_data = data_rd_0;
    end
  end
endgenerate

genvar p;
generate
  for(p=0; p &lt; N; p= p+1) 
  begin : ext_mem_interface_gen
    assign ext_mem_w_en[p] = en_wr[p];
    assign ext_mem_w_addr[p*MINADDR_W+:MINADDR_W] = addr_wr[p];
    assign ext_mem_w_data[p*MINDATA_W+:MINDATA_W] = data_wr[p];
    assign ext_mem_r_addr[p*MINADDR_W+:MINADDR_W] = addr_rd[p];
    assign data_rd[p] = ext_mem_r_data[p*MINDATA_W+:MINDATA_W];
  end
endgenerate
assign ext_mem_r_en = r_en;
`undef IOB_MAX
`undef IOB_MIN"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_fifo_sync</name>
      <circuit>
        <component_o id="IOB_fifo_sync">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_fifo_sync"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ext_mem_w_en" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_w_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_w_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_r_en" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="ext_mem_r_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ext_mem_r_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_empty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="dirty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_full" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="level" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_fifo_sync ext_mem_w_en ext_mem_w_data ext_mem_w_addr ext_mem_r_addr ext_mem_r_data r_data w_data level" IP_COMPONENT="IOB_ram_2p_asym" VERILOG_PROVIDED="
//COMMON UTILS
`define IOB_MAX(a,b) {((a) &gt; (b)) ? (a) : (b)}
`define IOB_MIN(a,b) {((a) &lt; (b)) ? (a) : (b)}

//IOB_REGISTER
`define IOB_REG_AR(CLK, RST_VAL, OUT, IN) always @(posedge CLK 1RESET_EDGE) if (1RESET_VALUE) OUT &lt;= RST_VAL; else OUT &lt;= IN;
`define IOB_REG_ARE(CLK, RST_VAL, EN, OUT, IN) always @(posedge CLK 1RESET_EDGE) if (1RESET_VALUE) OUT &lt;= RST_VAL; \
        else if (EN) OUT &lt;= IN;


//IOB_COUNTER
`define IOB_COUNTER_ARE(CLK, EN, NAME) \
  `IOB_REG_ARE(CLK, 1&apos;b0, EN, NAME, NAME+1&apos;b1)
localparam W_DATA_W = BITSIZE_w_data;
localparam R_DATA_W = BITSIZE_r_data;
localparam ADDR_W = BITSIZE_level - 1;
localparam MAXDATA_W = `IOB_MAX(W_DATA_W, R_DATA_W);
localparam MINDATA_W = `IOB_MIN(W_DATA_W, R_DATA_W);
localparam N = MAXDATA_W/MINDATA_W;
localparam MINADDR_W = ADDR_W-$clog2(N);//lower ADDR_W (higher DATA_W)
localparam W_ADDR_W = (W_DATA_W == MAXDATA_W) ? MINADDR_W : ADDR_W;
localparam R_ADDR_W = (R_DATA_W == MAXDATA_W) ? MINADDR_W : ADDR_W;

localparam ADDR_W_DIFF = $clog2(N);
localparam [ADDR_W:0] FIFO_SIZE = (1 &lt;&lt; ADDR_W); //in bytes

reg [BITSIZE_level - 1 : 0] level;
reg r_empty;
reg w_full;
reg w_full_nxt = 0;

//effective write enable
wire w_en_int = (w_en &amp; ~w_full);

//write address
reg [W_ADDR_W-1:0] w_addr;
`IOB_COUNTER_ARE(clock, w_en_int, w_addr)

//effective read enable
wire r_en_int  = (r_en &amp; ~r_empty);

//backup address (to read in case of write fail)
reg [R_ADDR_W-1:0] b_addr;
`IOB_COUNTER_ARE(clock, write_done, b_addr)

//read address
reg [R_ADDR_W-1:0] r_addr;
`IOB_COUNTER_ARE(clock, r_en_int, r_addr)

assign dirty = w_full || r_addr != b_addr; 

//assign according to assymetry type
localparam [ADDR_W:0] w_incr = (W_DATA_W > R_DATA_W) ? 1 &lt;&lt; ADDR_W_DIFF : 1;
localparam [ADDR_W:0] r_incr = (R_DATA_W > W_DATA_W) ? 1 &lt;&lt; ADDR_W_DIFF : 1;

//FIFO level
reg [ADDR_W+1:0] level_nxt;
`IOB_REG_AR(clock, 1&apos;b0, level, level_nxt[0+:ADDR_W+1])

reg [W_ADDR_W - 1:0] w_addr_next;

always @(*) 
begin
  level_nxt = {1&apos;d0,level};
  if(r_en_int &amp;&amp; w_en_int)
  begin
    level_nxt = (level + w_incr) - r_incr;
  end
  else if(w_en_int)
  begin
    level_nxt = level + w_incr;
  end
  else if (r_en_int) // (!w_en_int) &amp;&amp; r_en_int
  begin
    level_nxt = level -r_incr;
  end
end

always @(*) 
begin
  w_addr_next = w_addr;
  w_full_nxt = w_full;
  if(w_en_int &amp;&amp; write_done)
  begin
    w_full_nxt = w_addr == b_addr;
  end
  else if(write_done)
  begin
    w_full_nxt = 1&apos;b0;
  end
  else if(w_en_int) 
  begin
    w_addr_next = (w_addr + 1);
    w_full_nxt = w_addr_next == b_addr;
  end
end

//FIFO empty
wire r_empty_nxt;
assign r_empty_nxt = (level_nxt[0+:ADDR_W+1] &lt; r_incr);
`IOB_REG_AR(clock, 1&apos;d1, r_empty, r_empty_nxt)

//FIFO full
`IOB_REG_AR(clock, 1&apos;d0, w_full, w_full_nxt)

//FIFO memory
IOB_ram_2p_asym #(.W_DATA_W  (W_DATA_W),
  .R_DATA_W  (R_DATA_W),
  .ADDR_W    (ADDR_W),
  .BITSIZE_ext_mem_w_en(BITSIZE_ext_mem_w_en),
  .BITSIZE_ext_mem_w_data(BITSIZE_ext_mem_w_data),
  .BITSIZE_ext_mem_w_addr(BITSIZE_ext_mem_w_addr),
  .BITSIZE_ext_mem_r_addr(BITSIZE_ext_mem_r_addr),
  .BITSIZE_ext_mem_r_data(BITSIZE_ext_mem_r_data),
  .BITSIZE_w_data(BITSIZE_w_data),
  .BITSIZE_w_addr(W_ADDR_W),
  .BITSIZE_r_addr(R_ADDR_W),
  .BITSIZE_r_data(BITSIZE_r_data))
iob_ram_2p_asym0 (.clock(clock),  
  .ext_mem_w_en  (ext_mem_w_en),
  .ext_mem_w_data(ext_mem_w_data),
  .ext_mem_w_addr(ext_mem_w_addr),
  .ext_mem_r_en  (ext_mem_r_en),
  .ext_mem_r_addr(ext_mem_r_addr),
  .ext_mem_r_data(ext_mem_r_data),
  .w_en(w_en_int),
  .w_data(w_data),
  .w_addr(w_addr),
  .r_en(r_en_int),
  .r_addr(r_addr),
  .r_data(r_data));
`undef IOB_MAX
`undef IOB_MIN
`undef IOB_REG_AR
`undef IOB_REG_ARE
`undef IOB_COUNTER_ARE"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_ram_sp</name>
      <circuit>
        <component_o id="IOB_ram_sp">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_ram_sp"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="dout" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_ram_sp addr dout din" VERILOG_PROVIDED="
   localparam DATA_W = BITSIZE_dout;
   localparam ADDR_W = BITSIZE_addr;
   
   reg [BITSIZE_dout - 1 : 0] dout;

   // Declare the RAM
   reg [DATA_W-1:0]         ram[2**ADDR_W-1:0];

   integer index;
   // Initialize the RAM
   initial
   begin
     for(index=0; index&lt;(2**ADDR_W); index=index+1)
     begin
       ram[index] = 0;
     end
   end

   // Operate the RAM
   always @ (posedge clock)
     if(en)
       if (we)
         ram[addr] &lt;= din;
       else
         dout &lt;= ram[addr];

  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_ram_sp_no_addr</name>
      <circuit>
        <component_o id="IOB_ram_sp_no_addr">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_ram_sp_no_addr"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="dout" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="din" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_ram_sp_no_addr dout din" VERILOG_PROVIDED="
   localparam DATA_W = BITSIZE_dout;

   reg [BITSIZE_dout - 1 : 0] dout;

   // Declare the RAM
   reg [DATA_W-1:0]         ram;

   // Operate the RAM
   always @ (posedge clock)
     if(en)
       if (we)
         ram &lt;= din;
       else
         dout &lt;= ram;
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_gen_sp_ram</name>
      <circuit>
        <component_o id="IOB_gen_sp_ram">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_gen_sp_ram"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_gen_sp_ram we addr data_out data_in" IP_COMPONENT="STD_SP_BRAM_BE" VERILOG_PROVIDED="
localparam ADDR_W = BITSIZE_addr;
wire [BITSIZE_we-1:0] we1;

STD_SP_BRAM_BE #(
  .MEMORY_INIT_file(&quot;&quot;),
  .n_elements(2**ADDR_W),
  .READ_ONLY_MEMORY(0),
  .HIGH_LATENCY(0),
  .BITSIZE_write_enable(BITSIZE_we),
  .BITSIZE_data_in(BITSIZE_data_in),
  .BITSIZE_address_inr(BITSIZE_addr),
  .BITSIZE_address_inw(BITSIZE_addr),
  .BITSIZE_data_out(BITSIZE_data_out))
iob_cache_mem (
  .clock(clock),
  .write_enable(we1),
  .data_in(data_in),
  .address_inr(addr),
  .address_inw(addr),
  .data_out(data_out));

genvar i;
generate
  for (i = 0; i &lt; BITSIZE_we; i = i + 1)
  begin : we_loop
    assign we1[i] = en &amp; we[i];
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_gen_sp_ram_no_addr</name>
      <circuit>
        <component_o id="IOB_gen_sp_ram_no_addr">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_gen_sp_ram_no_addr"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_gen_sp_ram_no_addr we data_out data_in" IP_COMPONENT="IOB_ram_sp_no_addr" VERILOG_PROVIDED="
localparam DATA_W = BITSIZE_data_out;
genvar i;
generate
  for (i = 0; i &lt; (DATA_W/8); i = i + 1)
  begin : ram
    IOB_ram_sp_no_addr #(.BITSIZE_dout(8),
          .BITSIZE_din(8))
    iob_cache_mem (.clock(clock),
        .en(en),
        .we(we[i]),
        .dout(data_out[8*i +: 8]),
        .din(data_in [8*i +: 8]));
  end
endgenerate"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_onehot_to_bin</name>
      <circuit>
        <component_o id="IOB_onehot_to_bin">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_onehot_to_bin"/>
          <port_o id="onehot" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="bin" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_onehot_to_bin onehot bin" VERILOG_PROVIDED="
localparam BIN_W = BITSIZE_bin;

reg [BITSIZE_bin - 1 : 0] bin;

always @ (*) 
begin: onehot_to_binary_encoder
  integer i;
  reg [BIN_W-1:0] bin_cnt ;
  bin_cnt = 0;
  for (i=1; i&lt;2**BIN_W; i=i+1)
  begin
    if (onehot[i - 1])
    begin
      bin_cnt = bin_cnt|i;
    end
  end
  bin = bin_cnt;    
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_regfile_sp</name>
      <circuit>
        <component_o id="IOB_regfile_sp">
          <description>Simple register file, part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2024-2024 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_regfile_sp"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_regfile_sp addr w_data r_data" VERILOG_PROVIDED="
integer index;
localparam n_elements = 2**BITSIZE_addr;

reg [BITSIZE_w_data-1:0] memory [n_elements-1:0];

initial
begin
  for(index=0; index&lt;n_elements; index=index+1)
  begin
    memory[index] = 0;
  end
end

assign r_data = memory[addr];

always @(posedge clock)
begin
  if (we)
  begin
    memory[addr] &lt;= w_data;
  end
end
"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_regfile_sp_no_addr</name>
      <circuit>
        <component_o id="IOB_regfile_sp_no_addr">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_regfile_sp_no_addr"/>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="w_data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="r_data" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_regfile_sp_no_addr w_data r_data" VERILOG_PROVIDED="
localparam DATA_W = BITSIZE_w_data;
reg [DATA_W-1:0] reg_file;

//read
assign r_data = reg_file;

//write
always @(posedge clock)
begin
  if(reset)
  begin
    reg_file &lt;= {DATA_W{1&apos;b0}};
  end
  else if (we)
  begin
    reg_file &lt;= w_data;
  end
end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_replacement_policy</name>
      <circuit>
        <component_o id="IOB_replacement_policy">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_replacement_policy"/>
          <parameter name="REP_POLICY"> 2 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="way_hit" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="line_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="way_select" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="way_select_bin" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_replacement_policy REP_POLICY way_hit line_addr way_select way_select_bin" IP_COMPONENT="IOB_onehot_to_bin,IOB_regfile_sp,IOB_regfile_sp_no_addr" VERILOG_PROVIDED="
//Replacement Policy
`define LRU       0 // Least Recently Used -- more resources intensive - N*log2(N) bits per cache line - Uses counters
`define PLRU_mru  1 // bit-based Pseudo-Least-Recently-Used, a simpler replacement policy than LRU, using a much lower complexity (lower resources) - N bits per cache line
`define PLRU_tree 2 // tree-based Pseudo-Least-Recently-Used, uses a tree that updates after any way received an hit, and points towards the oposing one. Uses less resources than bit-pseudo-lru - N-1 bits per cache line

localparam N_WAYS = BITSIZE_way_hit;
localparam LINE_OFF_W = BITSIZE_line_addr;
localparam NWAY_W = $clog2(N_WAYS);

genvar i, j, k;

generate
  if (REP_POLICY == `LRU)
  begin
    wire [N_WAYS*NWAY_W -1:0] mru_out, mru_in;
    wire [N_WAYS*NWAY_W -1:0] mru; //Initial MRU values of the LRU algorithm, also initialized them in case it&apos;s the first access or was invalidated
    wire [N_WAYS*NWAY_W -1:0] mru_cnt; //updates the MRU line, the way used will be the highest value, while the others are decremented
    wire [NWAY_W-1:0] mru_index, way_hit_bin;

    IOB_onehot_to_bin #(.BITSIZE_onehot(2**NWAY_W - 1),
                    .BITSIZE_bin(NWAY_W))
    way_hit_binary (.onehot(way_hit[N_WAYS-1:1]),
          .bin(way_hit_bin));

    assign mru_index [NWAY_W-1:0] = mru_out &gt;&gt; (NWAY_W*way_hit_bin);

    for (i = 0; i &lt; N_WAYS; i=i+1)
    begin : encoder_decoder
      assign mru [i*NWAY_W +: NWAY_W] = (|mru_out)? mru_out [i*NWAY_W +: NWAY_W] : i; //verifies if the mru line has been initialized (if any bit in mru_output is HIGH), otherwise applies the priority values
      assign mru_cnt [i*NWAY_W +: NWAY_W] = (way_hit[i])? {NWAY_W{1&apos;b1}} : (mru[i*NWAY_W +: NWAY_W] &gt; mru_index) ? mru[i*NWAY_W +: NWAY_W] - 1 : mru[i*NWAY_W +: NWAY_W];// the MRU way gets updated to the the highest value; the remaining, if their value was bigger than the MRU index previous value (mru_index), they get decremented
      assign way_select [i] = ~(|mru[i*NWAY_W +: NWAY_W]); //selects the way that has the lowest priority (mru = 0)
    end

    assign mru_in = (|way_hit)? mru_cnt : mru_out; //If an hit occured, then it updates, to avoid updating during a (write) miss (mru_cnt would decrement every way besides the lowest)

    if(LINE_OFF_W &gt; 0) 
    begin
      IOB_regfile_sp #(.BITSIZE_addr(LINE_OFF_W),
            .BITSIZE_w_data(N_WAYS * NWAY_W),
            .BITSIZE_r_data(N_WAYS * NWAY_W))
      mru_memory (.clock(clock),
            .reset(reset),
            .we(write_en),
            .addr(line_addr),
            .w_data(mru_in),
            .r_data(mru_out));
    end 
    else 
    begin
      IOB_regfile_sp_no_addr #(.BITSIZE_w_data(N_WAYS * NWAY_W),
        .BITSIZE_r_data(N_WAYS * NWAY_W))
      mru_memory (.clock(clock),
        .reset(reset),
        .we(write_en),
        .w_data(mru_in),
        .r_data(mru_out));
    end

    IOB_onehot_to_bin #(.BITSIZE_onehot(2**NWAY_W - 1),
      .BITSIZE_bin(NWAY_W))
    onehot_bin (.onehot(way_select[N_WAYS-1:1]),
      .bin(way_select_bin));
  end 
  else if (REP_POLICY == `PLRU_mru)
  begin
    wire [N_WAYS -1:0] mru_in, mru_out;

    //pseudo LRU MRU based Encoder (More Recenty-Used bits):
    assign mru_in = (&amp;(mru_out | way_hit))? way_hit : mru_out | way_hit;//When the cache access results in a hi, it will update the MRU signal, if all ways were used, it resets and only updated the Most Recent

    // pseudo LRU MRU based Decoder:
    for (i = 1; i &lt; N_WAYS; i=i+1) 
    begin : way_select_block
      assign way_select [i] = ~mru_out[i] &amp; (&amp;mru_out[i-1:0]); //verifies priority (lower index)
    end
    assign way_select[0] = ~mru_out[0];

    if(LINE_OFF_W &gt; 0) 
    begin
      //Most Recently Used (MRU) memory
      IOB_regfile_sp #(.BITSIZE_addr(LINE_OFF_W),
            .BITSIZE_w_data(N_WAYS - 1),
            .BITSIZE_r_data(N_WAYS - 1))
      mru_memory (.clock(clock),
            .reset(reset),
            .we(write_en),
            .addr(line_addr),
            .w_data(mru_in),
            .r_data(mru_out));
    end 
    else 
    begin
      //Most Recently Used (MRU) memory
      IOB_regfile_sp_no_addr #(.BITSIZE_w_data(N_WAYS - 1),
        .BITSIZE_r_data(N_WAYS - 1))
      mru_memory (.clock(clock),
        .reset(reset),
        .we(write_en),
        .w_data(mru_in),
        .r_data(mru_out));
    end

    IOB_onehot_to_bin #(.BITSIZE_onehot(2**NWAY_W - 1),
      .BITSIZE_bin(NWAY_W))
    onehot_bin(.onehot(way_select[N_WAYS-1:1]),
      .bin(way_select_bin));
  end
  else 
  begin
    /*
    i: tree level, start from 1, i &lt;= NWAY_W
    j: tree node id @ i level, start from 0, j &lt; (1&lt;&lt;(i-1))
    (((1&lt;&lt;(i-1))+j)*2)*(1&lt;&lt;(NWAY_W-i))   ==&gt; start node id of left tree @ the lowest level node pointed to
    (((1&lt;&lt;(i-1))+j)*2+1)*(1&lt;&lt;(NWAY_W-i)) ==&gt; start node id of right tree @ the lowest level node pointed to

    way_hit[(((1&lt;&lt;(i-1))+j)*2)*(1&lt;&lt;(NWAY_W-i))-N_WAYS +: (N_WAYS&gt;&gt;i)]   ==&gt; way hit range of left tree
    way_hit[(((1&lt;&lt;(i-1))+j)*2+1)*(1&lt;&lt;(NWAY_W-i))-N_WAYS +: (N_WAYS&gt;&gt;i)] ==&gt; way hit range of right tree


    == tree traverse ==

                  &lt;--0     1--&gt;                 traverse direction
                      [1]                      node id @ level1
            [2]                 [3]            node id @ level2 ==&gt; which to traverse? from node_id[1]
        [4]       [5]       [6]       [7]       node id @ level3 ==&gt; which to traverse? from node_id[2]
    [08] [09] [10] [11] [12] [13] [14] [15]    node id @ level4 ==&gt; which to traverse? from node_id[3]
    (00) (01) (02) (03) (04) (05) (06) (07)    way idx

    node value is 0 -&gt; left tree traverse
    node value is 1 -&gt; right tree traverse

    node id mapping to way idx: node_id[NWAY_W]-N_WAYS
    */

    wire [N_WAYS -1: 1] tree_in, tree_out;
    wire [NWAY_W:0]     node_id[NWAY_W:1];
    assign node_id[1] = tree_out[1] ? 3 : 2; // next node id @ level2 to traverse
    for (i = 2; i &lt;= NWAY_W; i = i + 1) 
    begin : traverse_tree_level
      // next node id @ level3, level4, ..., to traverse
      assign node_id[i] = tree_out[node_id[i-1]] ? ((node_id[i-1]&lt;&lt;1)+1) : (node_id[i-1]&lt;&lt;1);
    end

    for (i = 1; i &lt;= NWAY_W; i = i + 1) 
    begin : tree_level
      for (j = 0; j &lt; (1&lt;&lt;(i-1)); j = j + 1) 
      begin : tree_level_node
          assign tree_in[(1&lt;&lt;(i-1))+j] = ~(|way_hit) ? tree_out[(1&lt;&lt;(i-1))+j] :
                                        (|way_hit[((((1&lt;&lt;(i-1))+j)*2)*(1&lt;&lt;(NWAY_W-i)))-N_WAYS +: (N_WAYS&gt;&gt;i)]) ||
                                        (tree_out[(1&lt;&lt;(i-1))+j] &amp;&amp; (~(|way_hit[((((1&lt;&lt;(i-1))+j)*2+1)*(1&lt;&lt;(NWAY_W-i)))-N_WAYS +: (N_WAYS&gt;&gt;i)])));
      end
    end

    assign way_select_bin = node_id[NWAY_W]-N_WAYS;
    assign way_select = (1 &lt;&lt; way_select_bin);

    if(LINE_OFF_W &gt; 0) 
    begin
      //Most Recently Used (MRU) memory
      IOB_regfile_sp #(.BITSIZE_addr(LINE_OFF_W),
        .BITSIZE_w_data(N_WAYS - 1),
        .BITSIZE_r_data(N_WAYS - 1))
      mru_memory (
        .clock(clock),
        .reset(reset),
        .we(write_en),
        .addr(line_addr),
        .w_data(tree_in),
        .r_data(tree_out));
      end else begin
        //Most Recently Used (MRU) memory
        IOB_regfile_sp_no_addr
            #(
              .BITSIZE_w_data(N_WAYS - 1),
              .BITSIZE_r_data(N_WAYS - 1)
            )
        mru_memory //simply uses the same format as valid memory
            (
              .clock    (clock          ),
              .reset    (reset        ),

              .we     (write_en     ),
              .w_data (tree_in      ),
              .r_data (tree_out     )
            );
      end
  end
endgenerate

`undef LRU
`undef PLRU_mru
`undef PLRU_tree"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_memory</name>
      <circuit>
        <component_o id="IOB_cache_memory">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_memory"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="N_WAYS"> 2 </parameter>
          <parameter name="LINE_OFF_W"> 10 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <parameter name="WTBUF_DEPTH_W"> 3 </parameter>
          <parameter name="REP_POLICY"> 2 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>

          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="flush" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="dirty_mem" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid_reg" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_reg" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wdata_reg" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb_reg" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="invalidate" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wtbuf_full" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wtbuf_empty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_hit" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_miss" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_hit" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_miss" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_memory FE_ADDR_W N_WAYS LINE_OFF_W WORD_OFF_W WTBUF_DEPTH_W REP_POLICY CTRL_CACHE CTRL_CNT WRITE_POL addr rdata addr_reg wdata_reg wstrb_reg write_addr write_wdata write_wstrb replace_addr read_addr read_rdata" IP_COMPONENT="IOB_ram_2p,IOB_fifo_sync,IOB_gen_sp_ram,IOB_gen_sp_ram_no_addr,IOB_ram_sp,IOB_ram_sp_no_addr,IOB_replacement_policy,IOB_onehot_to_bin" VERILOG_PROVIDED="
//Write Policy
`define WRITE_THROUGH 0 //write-through not allocate: implements a write-through buffer
`define WRITE_BACK 1    //write-back allocate: implementes a dirty-memory

`define IOB_MAX(a,b) {((a) &gt; (b)) ? (a) : (b)}
`define IOB_MIN(a,b) {((a) &lt; (b)) ? (a) : (b)}

  
localparam FE_DATA_W = BITSIZE_rdata;
localparam BE_DATA_W = BITSIZE_read_rdata;
localparam NWAY_W = $clog2(N_WAYS);
localparam FE_NBYTES  = FE_DATA_W/8;
localparam FE_BYTE_W = $clog2(FE_NBYTES);
localparam BE_NBYTES = BE_DATA_W/8;
localparam BE_BYTE_W = $clog2(BE_NBYTES);
localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);
/* To avoid 0 size when using fully associative cache. Signals are ignored if the size should be 0  */
localparam INDEX_W = LINE_OFF_W &gt; 0 ? LINE_OFF_W : 1;

localparam TAG_W = FE_ADDR_W - (FE_BYTE_W + WORD_OFF_W + LINE_OFF_W);
localparam BUF_DATA_SIZE = WRITE_POL == `WRITE_THROUGH ? FE_NBYTES+(FE_ADDR_W-FE_BYTE_W)+(FE_DATA_W) : FE_ADDR_W-FE_BYTE_W + (2**WORD_OFF_W)*FE_DATA_W;

wire hit;

//cache-memory internal signals
wire [N_WAYS-1:0] way_hit, way_select;

wire [TAG_W-1:0] tag = addr_reg[FE_ADDR_W-1 - (FE_BYTE_W) -:TAG_W]; //so the tag doesnt update during ready on a read-access, losing the current hit status (can take the 1 clock-cycle delay)
wire [INDEX_W-1:0] index;
wire [INDEX_W-1:0] index_reg;
wire [WORD_OFF_W-1:0] offset = addr_reg[FE_BYTE_W - (FE_BYTE_W) +:WORD_OFF_W]; //so the offset doesnt update during ready on a read-access (can take the 1 clock-cycle delay)

wire [N_WAYS*(2**WORD_OFF_W)*FE_DATA_W-1:0] line_rdata;
wire [N_WAYS*TAG_W-1:0]  line_tag;
reg [N_WAYS*(2**LINE_OFF_W)-1:0] v_reg;
reg [N_WAYS-1:0] v;

reg [(2**WORD_OFF_W)*FE_NBYTES-1:0] line_wstrb;

wire write_access = |wstrb_reg &amp; valid_reg;
wire read_access = ~|wstrb_reg &amp; valid_reg; //signal mantains the access 1 addition clock-cycle after ready is asserted


//back-end write channel
wire buffer_empty, buffer_full;
wire [BUF_DATA_SIZE-1 : 0] buffer_dout;
wire [BUF_DATA_SIZE-1 : 0] buf_w_data;
wire buf_w_en;

//for write-back write-allocate only
reg [N_WAYS-1:0] dirty;
reg [N_WAYS*(2**LINE_OFF_W)-1:0] dirty_reg;


localparam S_IDLE = 2&apos;b00, S_ADDR = 2&apos;b01, S_WRITE = 2&apos;b10;
reg [1:0] flush_state = S_IDLE, next_flush_state;
reg [(LINE_OFF_W + NWAY_W) - 1: 0] flush_addr, next_flush_addr;


generate
  if(LINE_OFF_W &gt; 0) 
  begin
      assign index     = addr    [FE_ADDR_W-TAG_W-1 - (BE_BYTE_W + LINE2MEM_W) -:LINE_OFF_W];//cant wait, doesnt update during a write-access
      assign index_reg = addr_reg[FE_ADDR_W-TAG_W-1 - (FE_BYTE_W) -:INDEX_W];//cant wait, doesnt update during a write-access
  end
endgenerate

generate
  if(WRITE_POL == `WRITE_THROUGH) 
  begin

    localparam FIFO_DATA_W = FE_ADDR_W-FE_BYTE_W + FE_DATA_W + FE_NBYTES;
    localparam FIFO_ADDR_W = WTBUF_DEPTH_W;
    localparam MAXDATA_W = `IOB_MAX(FIFO_DATA_W, FIFO_DATA_W);
    localparam MINDATA_W = `IOB_MIN(FIFO_DATA_W, FIFO_DATA_W);
    localparam N = MAXDATA_W/MINDATA_W;
    localparam MINADDR_W = FIFO_ADDR_W-$clog2(N);
    wire mem_w_en;
    wire [FIFO_ADDR_W-1:0] mem_w_addr;
    wire [FIFO_DATA_W-1:0] mem_w_data;
    wire mem_r_en;
    wire [FIFO_ADDR_W-1:0] mem_r_addr;
    wire [FIFO_DATA_W-1:0] mem_r_data;

    // FIFO memory
    IOB_ram_2p #(.BITSIZE_w_addr(FIFO_ADDR_W),
        .BITSIZE_w_data(FIFO_DATA_W),
        .BITSIZE_r_addr(FIFO_ADDR_W),
        .BITSIZE_r_data(FIFO_DATA_W))
    iob_ram_2p0 (.clock(clock),
      .w_en(mem_w_en),
      .w_addr(mem_w_addr),
      .w_data(mem_w_data),
      .r_en(mem_r_en),
      .r_addr(mem_r_addr),
      .r_data(mem_r_data));

    IOB_fifo_sync #(.BITSIZE_ext_mem_w_en  (N),
        .BITSIZE_ext_mem_w_data(MINDATA_W * N),
        .BITSIZE_ext_mem_w_addr(MINADDR_W * N),
        .BITSIZE_ext_mem_r_addr(MINADDR_W * N),
        .BITSIZE_ext_mem_r_data(MINDATA_W * N),
        .BITSIZE_r_data(FIFO_DATA_W),
        .BITSIZE_w_data(FIFO_DATA_W),
        .BITSIZE_level(FIFO_ADDR_W + 1))
    write_buffer (.clock(clock),
      .reset(reset),
      .ext_mem_w_en(mem_w_en),
      .ext_mem_w_addr(mem_w_addr),
      .ext_mem_w_data(mem_w_data),
      .ext_mem_r_en(mem_r_en),
      .ext_mem_r_addr(mem_r_addr),
      .ext_mem_r_data (mem_r_data),

      .level   (),

      .r_data  (buffer_dout),
      .r_empty (buffer_empty),
      .r_en    (write_ready),
      .dirty   (dirty_mem),

      .w_data  (buf_w_data),
      .w_full  (buffer_full),
      .w_en    (buf_w_en),
      .write_done(write_done)
      );

    assign buf_w_data = {addr_reg,wdata_reg,wstrb_reg};
    assign buf_w_en = write_access &amp; ready;

    //buffer status
    assign wtbuf_full = buffer_full;
    assign wtbuf_empty = buffer_empty &amp; write_ready &amp; ~write_valid;

    //back-end write channel
    assign write_valid = ~buffer_empty;
    assign write_addr  = buffer_dout[FE_NBYTES + FE_DATA_W +: FE_ADDR_W - FE_BYTE_W];
    assign write_wdata = buffer_dout[FE_NBYTES             +: FE_DATA_W            ];
    assign write_wstrb = buffer_dout[0                     +: FE_NBYTES            ];


    //back-end read channel
    assign replace_valid = (~hit &amp; read_access &amp; ~replace) &amp; (buffer_empty &amp; write_ready);
    assign replace_addr  = addr[FE_ADDR_W -1 - (BE_BYTE_W + LINE2MEM_W):BE_BYTE_W+LINE2MEM_W - (BE_BYTE_W + LINE2MEM_W)];

  end
  else begin // if (WRITE_POL == WRITE_BACK)
      localparam FIFO_ADDR_W = WTBUF_DEPTH_W;
      localparam FIFO_DATA_W = FE_ADDR_W-FE_BYTE_W + (2**WORD_OFF_W)*FE_DATA_W;

      wire mem_w_en;
      wire [FIFO_ADDR_W-1:0] mem_w_addr;
      wire [FIFO_DATA_W-1:0] mem_w_data;

      wire mem_r_en;
      wire [FIFO_ADDR_W-1:0] mem_r_addr;
      wire [FIFO_DATA_W-1:0] mem_r_data;
      wire buf_dirty;
    // FIFO memory
    IOB_ram_2p
    #(
      .BITSIZE_w_addr(FIFO_ADDR_W),
      .BITSIZE_w_data(FIFO_DATA_W),
      .BITSIZE_r_addr(FIFO_ADDR_W),
      .BITSIZE_r_data(FIFO_DATA_W)
    )
    iob_ram_2p0
    (
      .clock    (clock),
      .w_en   (mem_w_en),
      .w_addr (mem_w_addr),
      .w_data (mem_w_data),
      .r_en   (mem_r_en),
      .r_addr (mem_r_addr),
      .r_data (mem_r_data)
    );
    IOB_fifo_sync 
    #(
      .BITSIZE_ext_mem_w_en  (1),
      .BITSIZE_ext_mem_w_data(FIFO_DATA_W),
      .BITSIZE_ext_mem_w_addr(FIFO_ADDR_W),
      .BITSIZE_ext_mem_r_addr(FIFO_ADDR_W),
      .BITSIZE_ext_mem_r_data(FIFO_DATA_W),
      .BITSIZE_r_data        (FIFO_DATA_W),
      .BITSIZE_w_data        (FIFO_DATA_W),
      .BITSIZE_level         (FIFO_ADDR_W + 1)
    )
    write_buffer
    (
      .clock     (clock),
      .reset   (reset),
      .ext_mem_w_en   (mem_w_en),
      .ext_mem_w_addr (mem_w_addr),
      .ext_mem_w_data (mem_w_data),
      .ext_mem_r_en   (mem_r_en),
      .ext_mem_r_addr (mem_r_addr),
      .ext_mem_r_data (mem_r_data),
      .level   (),
      .r_data  (buffer_dout),
      .r_empty (buffer_empty),
      .r_en    (write_ready),
      .dirty   (buf_dirty),
      .w_data  (buf_w_data),
      .w_full  (buffer_full),
      .w_en    (buf_w_en),
      .write_done(write_done)
    );

    //buffer status
    assign write_valid = !buffer_empty;
    assign wtbuf_full = buffer_full;
    assign wtbuf_empty = buffer_empty &amp; write_ready &amp; ~write_valid;

    assign dirty_mem = |dirty_reg || buf_dirty;
    //back-end read channel
    assign replace_valid = (~|way_hit) &amp; (write_ready) &amp; valid_reg &amp; ~replace;

    assign replace_addr = addr[FE_ADDR_W -1 - (BE_BYTE_W + LINE2MEM_W):BE_BYTE_W+LINE2MEM_W - (BE_BYTE_W + LINE2MEM_W)];
  
    //back-end write channel
    assign write_wstrb = {FE_NBYTES{1&apos;bx}};
    assign write_addr = buffer_dout[FIFO_DATA_W - 1 -: (FE_ADDR_W - FE_BYTE_W)];
    assign write_wdata = buffer_dout[(2**WORD_OFF_W)*FE_DATA_W - 1 : 0];        
  end
endgenerate


//////////////////////////////////////////////////////
// Read-After-Write (RAW) Hazard (pipeline) control
//////////////////////////////////////////////////////
wire                                                     raw;
reg                                                      write_hit_prev;
reg [WORD_OFF_W-1:0]                                     offset_prev;
reg [N_WAYS-1:0]                                         way_hit_prev;

generate
if (WRITE_POL == `WRITE_THROUGH) begin
  always @(posedge clock) begin
    write_hit_prev &lt;= write_access &amp; (|way_hit);
    //previous write position
    offset_prev &lt;= offset;
    way_hit_prev &lt;= way_hit;
  end
  assign raw = write_hit_prev &amp; (way_hit_prev == way_hit) &amp; (offset_prev == offset);
end
else begin //// if (WRITE_POL == WRITE_BACK)
  always @(posedge clock) begin
    write_hit_prev &lt;= write_access; //all writes will have the data in cache in the end
    //previous write position
    offset_prev &lt;= offset;
    way_hit_prev &lt;= way_hit;
  end
  assign raw = write_hit_prev &amp; (way_hit_prev == way_hit) &amp; (offset_prev == offset) &amp; read_access; //without read_access it is an infinite replacement loop
end
endgenerate


///////////////////////////////////////////////////////////////
// Hit signal: data available and in the memory&apos;s output
///////////////////////////////////////////////////////////////
assign hit = |way_hit &amp; ~replace &amp; (~raw);


/////////////////////////////////
//front-end READY signal
/////////////////////////////////
generate
  if (WRITE_POL == `WRITE_THROUGH)
  begin
    assign ready = (hit &amp; read_access) | (~buffer_full &amp; write_access);
  end
  else 
  begin
    assign ready = hit &amp; valid_reg;
  end
endgenerate

//cache-control hit-miss counters enables
generate
  if(CTRL_CACHE &amp; CTRL_CNT)
    begin
        //cache-control hit-miss counters enables
        assign write_hit  = ready &amp; ( hit &amp; write_access);
        assign write_miss = replace_valid &amp; write_access;
        assign read_hit   = ready &amp; ( hit &amp;  read_access);
        assign read_miss  = replace_valid &amp; read_access;
    end
  else
    begin
        assign write_hit  = 1&apos;bx;
        assign write_miss = 1&apos;bx;
        assign read_hit   = 1&apos;bx;
        assign read_miss  = 1&apos;bx;
    end // else: !if(CACHE_CTRL &amp; CTRL_CNT)
endgenerate


////////////////////////////////////////
//Memories implementation configurations
////////////////////////////////////////
genvar i,j,k;
generate

  if(LINE_OFF_W &gt; 0 &amp;&amp; WRITE_POL == `WRITE_BACK) 
  begin
    //Data-Memory
    for (k = 0; k &lt; N_WAYS; k=k+1) 
    begin : n_ways_block
      for(j = 0; j &lt; 2**LINE2MEM_W; j=j+1) 
      begin : line2mem_block
        for(i = 0; i &lt; BE_DATA_W/FE_DATA_W; i=i+1) 
        begin : BE_FE_block_LINE_OFF_W_GT_0_WRITE_BACK
          IOB_gen_sp_ram #(.BITSIZE_we(FE_DATA_W / 8),
            .BITSIZE_addr(LINE_OFF_W),
            .BITSIZE_data_out(FE_DATA_W),
            .BITSIZE_data_in(FE_DATA_W)) 
          cache_memory_ram (.clock(clock),
            .en(valid || flush),
            .we({FE_NBYTES{way_hit[k]}} &amp; line_wstrb[(j*(BE_DATA_W/FE_DATA_W)+i)*FE_NBYTES +: FE_NBYTES]),
            .addr(flush ? flush_addr[LINE_OFF_W - 1 : 0] : (write_access &amp; way_hit[k] &amp; ((j*(BE_DATA_W/FE_DATA_W)+i) == offset))? index_reg : index),
            .data_in((replace)? read_rdata[i*FE_DATA_W +: FE_DATA_W] : wdata_reg),
            .data_out(line_rdata[(k*(2**WORD_OFF_W)+j*(BE_DATA_W/FE_DATA_W)+i)*FE_DATA_W +: FE_DATA_W]));
        end
      end
    end
  end
  else if (LINE_OFF_W &gt; 0)
  begin
    //Data-Memory
    for (k = 0; k &lt; N_WAYS; k=k+1) 
    begin : n_ways_block
      for(j = 0; j &lt; 2**LINE2MEM_W; j=j+1) 
      begin : line2mem_block
        for(i = 0; i &lt; BE_DATA_W/FE_DATA_W; i=i+1) 
        begin : BE_FE_block_LINE_OFF_W_GT_0
          IOB_gen_sp_ram #(.BITSIZE_we(FE_DATA_W / 8),
            .BITSIZE_addr(LINE_OFF_W),
            .BITSIZE_data_out(FE_DATA_W),
            .BITSIZE_data_in(FE_DATA_W)) 
          cache_memory (.clock(clock),
            .en(valid),
            .we({FE_NBYTES{way_hit[k]}} &amp; line_wstrb[(j*(BE_DATA_W/FE_DATA_W)+i)*FE_NBYTES +: FE_NBYTES]),
            .addr((write_access &amp; way_hit[k] &amp; ((j*(BE_DATA_W/FE_DATA_W)+i) == offset))? index_reg : index),
            .data_in((replace)? read_rdata[i*FE_DATA_W +: FE_DATA_W] : wdata_reg),
            .data_out(line_rdata[(k*(2**WORD_OFF_W)+j*(BE_DATA_W/FE_DATA_W)+i)*FE_DATA_W +: FE_DATA_W]));
        end
      end
    end
  end
  else if(WRITE_POL == `WRITE_BACK)
  begin
    //Data-Memory
    for (k = 0; k &lt; N_WAYS; k=k+1) 
    begin : n_ways_block
      for(j = 0; j &lt; 2**LINE2MEM_W; j=j+1) 
      begin : line2mem_block
        for(i = 0; i &lt; BE_DATA_W/FE_DATA_W; i=i+1) 
        begin : BE_FE_block_WRITE_BACK
          IOB_gen_sp_ram_no_addr #(.BITSIZE_we(FE_DATA_W / 8),
            .BITSIZE_data_out(FE_DATA_W),
            .BITSIZE_data_in(FE_DATA_W)) 
          cache_memory (
            .clock(clock),
            .en(valid || flush),
            .we({FE_NBYTES{way_hit[k]}} &amp; line_wstrb[(j*(BE_DATA_W/FE_DATA_W)+i)*FE_NBYTES +: FE_NBYTES]),
            .data_in ((replace)? read_rdata[i*FE_DATA_W +: FE_DATA_W] : wdata_reg),
            .data_out(line_rdata[(k*(2**WORD_OFF_W)+j*(BE_DATA_W/FE_DATA_W)+i)*FE_DATA_W +: FE_DATA_W]));
        end
      end
    end
  end
  else
  begin
    //Data-Memory
    for (k = 0; k &lt; N_WAYS; k=k+1) 
    begin : n_ways_block
      for(j = 0; j &lt; 2**LINE2MEM_W; j=j+1) 
      begin : line2mem_block
        for(i = 0; i &lt; BE_DATA_W/FE_DATA_W; i=i+1) 
        begin : BE_FE_block_ELSE
          IOB_gen_sp_ram_no_addr #(.BITSIZE_we(FE_DATA_W / 8),
            .BITSIZE_data_out(FE_DATA_W),
            .BITSIZE_data_in(FE_DATA_W)) 
          cache_memory (
            .clock(clock),
            .en(valid),
            .we({FE_NBYTES{way_hit[k]}} &amp; line_wstrb[(j*(BE_DATA_W/FE_DATA_W)+i)*FE_NBYTES +: FE_NBYTES]),
            .data_in ((replace)? read_rdata[i*FE_DATA_W +: FE_DATA_W] : wdata_reg),
            .data_out(line_rdata[(k*(2**WORD_OFF_W)+j*(BE_DATA_W/FE_DATA_W)+i)*FE_DATA_W +: FE_DATA_W]));
        end
      end
    end
  end

  //Cache Line Write Strobe
  if(LINE2MEM_W &gt; 0)
    begin
        always @(*)
          if(replace)
            line_wstrb = {BE_NBYTES{read_valid}} &lt;&lt; (read_addr*BE_NBYTES); //line-replacement: read_addr indexes the words in cache-line
          else
            line_wstrb = (wstrb_reg &amp; {FE_NBYTES{write_access}}) &lt;&lt; (offset*FE_NBYTES);
    end
  else
    begin
        always @(*)
          if(replace)
            line_wstrb = {BE_NBYTES{read_valid}}; //line-replacement: mem&apos;s word replaces entire line
          else
            line_wstrb = (wstrb_reg &amp; {FE_NBYTES{write_access}}) &lt;&lt; (offset*FE_NBYTES);
    end // else: !if(LINE2MEM_W &lt; 0)


  // Valid-Tag memories &amp; replacement-policy
  if(N_WAYS &gt; 1)
    begin

        wire [NWAY_W-1:0] way_hit_bin, way_select_bin;//reason for the 2 generates for single vs multiple ways
        
        if(LINE_OFF_W &gt; 0) begin
          //valid-memory
          always @ (posedge clock 1RESET_EDGE) 
          begin
              if (1RESET_VALUE)
                v_reg &lt;= 0;
              else if (invalidate)
                v_reg &lt;= 0;
              else if(replace_valid)
                v_reg &lt;= v_reg | (1&lt;&lt;(way_select_bin*(2**LINE_OFF_W) + index_reg));
              else
                v_reg &lt;= v_reg;
          end
              
          for(k = 0; k &lt; N_WAYS; k = k+1) 
          begin : tag_mem_block
            //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
            always @(posedge clock)
            begin
              if(invalidate)
              begin
                v[k] &lt;= 0;
              end
              else
              begin
                v[k] &lt;= v_reg [(2**LINE_OFF_W)*k + index];
              end
            end
  
            if(WRITE_POL == `WRITE_BACK)
            begin
              //tag-memory
              IOB_ram_sp #(.BITSIZE_addr(LINE_OFF_W),
                .BITSIZE_dout(TAG_W),
                .BITSIZE_din(TAG_W))
              tag_memory (.clock(clock),
                .en(valid || flush_state == S_ADDR),
                .we (way_select[k] &amp; replace_valid),
                .addr(flush_state == S_ADDR ? flush_addr[LINE_OFF_W - 1 : 0] : index),
                .din (tag),
                .dout(line_tag[TAG_W*k +: TAG_W]));  
  
              //Way hit signal - hit or replacement
              assign way_hit[k] = flush ? (flush_addr[LINE_OFF_W +: NWAY_W] == k) : (tag == line_tag[TAG_W*k +: TAG_W]) &amp; v[k];
            end
            else
            begin
              //tag-memory
              IOB_ram_sp #(.BITSIZE_addr(LINE_OFF_W),
                .BITSIZE_dout(TAG_W),
                .BITSIZE_din(TAG_W))
              tag_memory (.clock(clock),
                .en(valid),
                .we (way_select[k] &amp; replace_valid),
                .addr(index),
                .din (tag),
                .dout(line_tag[TAG_W*k +: TAG_W]));  
  
              //Way hit signal - hit or replacement
              assign way_hit[k] = (tag == line_tag[TAG_W*k +: TAG_W]) &amp; v[k];
            end
          end
        end 
        else 
        begin
          //valid-memory
          always @ (posedge clock 1RESET_EDGE) 
          begin
              if (1RESET_VALUE)
                v_reg &lt;= 0;
              else if (invalidate)
                v_reg &lt;= 0;
              else if(replace_valid)
                v_reg &lt;= v_reg | (1&lt;&lt;way_select_bin);
              else
                v_reg &lt;= v_reg;
          end
              
          for(k = 0; k &lt; N_WAYS; k = k+1) begin : tag_mem_block
              //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
              always @(posedge clock)
                if(invalidate)
                    v[k] &lt;= 0;
                else
                    v[k] &lt;= v_reg [k];

              if(WRITE_POL == `WRITE_BACK)
              begin
                //tag-memory
                IOB_ram_sp_no_addr #(.BITSIZE_dout(TAG_W),
                  .BITSIZE_din(TAG_W))
                tag_memory (.clock(clock),
                  .en(valid|| flush_state == S_ADDR),
                  .we(way_select[k] &amp; replace_valid),
                  .din (tag),
                  .dout(line_tag[TAG_W*k +: TAG_W]));
              end
              else
              begin
                //tag-memory
                IOB_ram_sp_no_addr #(.BITSIZE_dout(TAG_W),
                  .BITSIZE_din(TAG_W))
                tag_memory (.clock(clock),
                  .en(valid),
                  .we(way_select[k] &amp; replace_valid),
                  .din (tag),
                  .dout(line_tag[TAG_W*k +: TAG_W]));
              end
  
              if(WRITE_POL == `WRITE_BACK)
              begin
                //Way hit signal - hit or replacement
                assign way_hit[k] = flush ? (flush_addr[LINE_OFF_W +: NWAY_W] == k) : (tag == line_tag[TAG_W*k +: TAG_W]) &amp; v[k];
              end
              else
              begin
                //Way hit signal - hit or replacement
                assign way_hit[k] = (tag == line_tag[TAG_W*k +: TAG_W]) &amp; v[k];
              end
          end
        end


        //Read Data Multiplexer
        assign rdata [FE_DATA_W-1:0] = line_rdata &gt;&gt; FE_DATA_W*(offset + (2**WORD_OFF_W)*way_hit_bin);


        //replacement-policy module
        IOB_replacement_policy #(
                      .BITSIZE_way_hit(N_WAYS),
                      .BITSIZE_line_addr(LINE_OFF_W),
                      .BITSIZE_way_select(N_WAYS),
                      .BITSIZE_way_select_bin(NWAY_W),
                      .REP_POLICY(REP_POLICY)
                      )
        replacement_policy_algorithm
          (
          .clock       (clock             ),
          .reset     (1RESET_VALUE|invalidate),
          .write_en  (ready           ),
          .way_hit   (way_hit         ),
          .line_addr (index_reg       ),
          .way_select(way_select      ),
          .way_select_bin(way_select_bin)
          );

        //onehot-to-binary for way-hit
        IOB_onehot_to_bin #(
                        .BITSIZE_onehot(2**NWAY_W - 1),
                        .BITSIZE_bin(NWAY_W)
                        )
        way_hit_encoder
          (
          .onehot(way_hit[N_WAYS-1:1]),
          .bin   (way_hit_bin)
          );

        //dirty-memory
        if(WRITE_POL == `WRITE_BACK)
          begin
            if(LINE_OFF_W &gt; 0) 
            begin
              always @ (posedge clock 1RESET_EDGE) 
              begin
                if (1RESET_VALUE)
                begin
                  dirty_reg &lt;= 0;
                end
                else if (flush_state == S_WRITE &amp;&amp; !buffer_full) 
                begin
                  dirty_reg &lt;= dirty_reg &amp; ~(1&lt;&lt;flush_addr);
                end 
                else if(write_access &amp; hit)
                begin
                  dirty_reg &lt;= dirty_reg |  (1&lt;&lt;(way_hit_bin*(2**LINE_OFF_W) + index_reg));//updates position with 1
                end
                else
                begin
                  dirty_reg &lt;= dirty_reg;
                end
              end

              for(k = 0; k &lt; N_WAYS; k = k+1) 
              begin : dirty_block
                //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
                always @(posedge clock)
                begin
                  dirty[k] &lt;= dirty_reg [(2**LINE_OFF_W)*k + index];
                end
              end
            end 
            else 
            begin
              always @ (posedge clock 1RESET_EDGE) 
              begin
                if (1RESET_VALUE)
                begin
                  dirty_reg &lt;= 0;
                end
                else if (flush_state == S_WRITE &amp;&amp; !buffer_full) 
                begin
                  dirty_reg &lt;= dirty_reg &amp; ~(1&lt;&lt;flush_addr);
                end 
                else if(write_access &amp; hit)
                begin
                  dirty_reg &lt;= dirty_reg |  (1&lt;&lt;(way_hit_bin*(2**LINE_OFF_W)));//updates position with 1
                end
                else
                begin
                  dirty_reg &lt;= dirty_reg;
                end
              end
              
              for(k = 0; k &lt; N_WAYS; k = k+1) 
              begin : dirty_block
                //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
                always @(posedge clock)
                    dirty[k] &lt;= dirty_reg [k];
              end
            end

            //flush line
            wire [TAG_W-1:0] tag_flush = line_tag &gt;&gt; ((flush? way_hit_bin : way_select_bin)*TAG_W);      //auxiliary wire
            assign buf_w_en = (valid_reg &amp;&amp; (way_hit == &apos;b0) &amp;&amp; (way_select &amp; dirty) &amp;&amp; replace_valid) || flush_state == S_WRITE;
            wire [FE_DATA_W*(2**WORD_OFF_W) - 1 : 0] data_flush = line_rdata &gt;&gt; ((flush ? way_hit_bin : way_select_bin) *FE_DATA_W*(2**WORD_OFF_W));
            if(LINE_OFF_W &gt; 0) begin
                assign buf_w_data = {{tag_flush, flush ? flush_addr[LINE_OFF_W - 1 : 0] : index_reg}, data_flush}; 
            end else begin
                assign buf_w_data = {tag_flush, data_flush}; 
            end
          end // if (WRITE_POL == WRITE_BACK)
    end
  else // (N_WAYS = 1)
    begin
        //valid-memory
        always @ (posedge clock 1RESET_EDGE)
          begin
            if (1RESET_VALUE)
              v_reg &lt;= 0;
            else if (invalidate)
              v_reg &lt;= 0;
            else if(replace_valid)
              v_reg &lt;= v_reg | (1 &lt;&lt; index);
            else
              v_reg &lt;= v_reg;
          end

        //valid-memory output stage register - 1 c.c. read-latency (cleaner simulation during rep.)
        always @(posedge clock)
          if(invalidate)
            v &lt;= 0;
          else
            v &lt;= v_reg [index];

        if(WRITE_POL == `WRITE_BACK)
        begin
          //tag-memory
          IOB_ram_sp #(.BITSIZE_addr(LINE_OFF_W),
            .BITSIZE_dout(TAG_W),
            .BITSIZE_din(TAG_W))
          tag_memory (.clock (clock),
            .en(valid || flush_state == S_ADDR),
            .we(replace_valid),
            .addr(flush_state == S_ADDR ? flush_addr[LINE_OFF_W - 1 : 0] : index),
            .din(tag),
            .dout(line_tag));
        end
        else
        begin
          //tag-memory
          IOB_ram_sp #(.BITSIZE_addr(LINE_OFF_W),
            .BITSIZE_dout(TAG_W),
            .BITSIZE_din(TAG_W))
          tag_memory (.clock (clock),
            .en(valid),
            .we(replace_valid),
            .addr(index),
            .din(tag),
            .dout(line_tag));
        end


        //Cache hit signal that indicates which way has had the hit (also during replacement)
        assign way_hit = (tag == line_tag) &amp; v;

        //Read Data Multiplexer
        assign rdata [FE_DATA_W-1:0] = line_rdata &gt;&gt; FE_DATA_W*offset;

        //dirty-memory
        if(WRITE_POL == `WRITE_BACK)
        begin
          //dirty-memory
          always @ (posedge clock 1RESET_EDGE) begin
              if (1RESET_VALUE)
                dirty_reg &lt;= 0;
              else if(flush_state == S_WRITE &amp;&amp; !buffer_full) begin
                dirty_reg &lt;= dirty_reg &amp; ~(1 &lt;&lt; flush_addr);
              end else if(!flush) begin
              if(write_access &amp; hit)
                dirty_reg &lt;= dirty_reg | (1&lt;&lt;(index_reg)); //updates position with 1 (needs to be index_reg otherwise updates the new index if the previous access was a write)
              end else
                dirty_reg &lt;= dirty_reg;
          end

          always @(posedge clock)
          begin
            dirty &lt;= dirty_reg [index];
          end

          assign buf_w_en = ((write_access || read_access) &amp;&amp; (~(way_hit) &amp; dirty) &amp;&amp; replace_valid) || flush_state == S_WRITE;
          assign buf_w_data = {{line_tag, flush_state == S_WRITE ? flush_addr[LINE_OFF_W - 1 : 0] : index_reg}, line_rdata};
        end 
    end // else: !if(N_WAYS &gt; 1)
endgenerate

generate
  if(WRITE_POL == `WRITE_BACK) 
  begin

    always @(*) 
    begin
      next_flush_state = flush_state;
      next_flush_addr = 0;
      case(flush_state)
        S_IDLE: 
        begin
          if(flush) 
          begin
            next_flush_state = S_ADDR;
          end
        end
        S_ADDR: begin
          if(dirty_reg[flush_addr]) 
          begin
            next_flush_addr = flush_addr;
            next_flush_state = S_WRITE;
          end 
          else if (|dirty_reg) 
          begin
            next_flush_addr = flush_addr + 1;
            next_flush_state = S_ADDR;
          end 
          else 
          begin
            next_flush_state = S_IDLE;
          end
        end
        S_WRITE: 
        begin
          if(!buffer_full) 
          begin
            next_flush_addr = flush_addr + 1;
            next_flush_state = S_ADDR;
          end 
          else 
          begin
            next_flush_addr = flush_addr;
            next_flush_state = S_WRITE;
          end
        end
        default: 
        begin
          next_flush_state = S_IDLE;
        end
      endcase
    end
    
    always @(posedge clock) 
    begin
      if(1RESET_VALUE) 
      begin
        flush_state &lt;= S_IDLE;
        flush_addr &lt;= 0;
      end
      else
      begin
        flush_state &lt;= next_flush_state;
        flush_addr &lt;= next_flush_addr;
      end 
    end  
  end
endgenerate

`undef WRITE_THROUGH
`undef WRITE_BACK
`undef IOB_MIN
`undef IOB_MAX"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_control</name>
      <circuit>
        <component_o id="IOB_cache_control">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_control"/>
          <parameter name="CTRL_CNT"> 1 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="wtbuf_full" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wtbuf_empty" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_hit" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_miss" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_hit" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_miss" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="invalidate" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_control CTRL_CNT rdata" VERILOG_PROVIDED="
   `define CTRL_ADDR_W 4
    //Addresses for cache controller&apos;s task
   `define ADDR_BUFFER_EMPTY          (`CTRL_ADDR_W&apos;d1)
   `define ADDR_BUFFER_FULL           (`CTRL_ADDR_W&apos;d2) 
   `define ADDR_CACHE_HIT             (`CTRL_ADDR_W&apos;d3) 
   `define ADDR_CACHE_MISS            (`CTRL_ADDR_W&apos;d4) 
   `define ADDR_CACHE_READ_ACCESS     (`CTRL_ADDR_W&apos;d5) 
   `define ADDR_CACHE_READ_MISS       (`CTRL_ADDR_W&apos;d6) 
   `define ADDR_CACHE_WRITE_ACCESS    (`CTRL_ADDR_W&apos;d7) 
   `define ADDR_CACHE_WRITE_MISS      (`CTRL_ADDR_W&apos;d8) 
   `define ADDR_RESET_COUNTER         (`CTRL_ADDR_W&apos;d9) 
   `define ADDR_CACHE_INVALIDATE      (`CTRL_ADDR_W&apos;d10)

   localparam FE_DATA_W = BITSIZE_rdata;

   reg [BITSIZE_rdata - 1 : 0] rdata;
   reg invalidate;
   reg ready;

   generate
      if(CTRL_CNT)
        begin : cnt
           
           reg [FE_DATA_W-1:0]             read_access_cnt, read_miss_cnt, write_access_cnt, write_miss_cnt;
           wire [FE_DATA_W-1:0]            hit_cnt, miss_cnt;
           reg                             counter_reset;

           assign hit_cnt  = read_access_cnt  + write_access_cnt;
           assign miss_cnt = read_miss_cnt + write_miss_cnt;
           
           always @ (posedge clock 1RESET_EDGE)
             begin
	        if (1RESET_VALUE) 
	          begin
                     read_access_cnt  &lt;= {FE_DATA_W{1&apos;b0}};
               read_miss_cnt &lt;= {FE_DATA_W{1&apos;b0}};
               write_access_cnt  &lt;= {FE_DATA_W{1&apos;b0}};
               write_miss_cnt &lt;= {FE_DATA_W{1&apos;b0}};
                  end
                else
                  begin
                     if (counter_reset) 
                 begin
                          read_access_cnt  &lt;= {FE_DATA_W{1&apos;b0}};
                    read_miss_cnt &lt;= {FE_DATA_W{1&apos;b0}};
                    write_access_cnt  &lt;= {FE_DATA_W{1&apos;b0}};
                    write_miss_cnt &lt;= {FE_DATA_W{1&apos;b0}};
                       end
                     else
                 if (read_hit)
                   begin
                read_access_cnt &lt;= read_access_cnt + 1; 
                   end
                 else if (write_hit)
                   begin
                write_access_cnt &lt;= write_access_cnt + 1;
                   end
                 else if (read_miss)
                   begin
                read_miss_cnt &lt;= read_miss_cnt + 1;
                         end
                 else if (write_miss)
                   begin
                write_miss_cnt &lt;= write_miss_cnt + 1;
                   end
                 else
                   begin
                read_access_cnt &lt;= read_access_cnt;
                read_miss_cnt &lt;= read_miss_cnt;
                write_access_cnt &lt;= write_access_cnt;
                write_miss_cnt &lt;= write_miss_cnt;
                   end
            end // else: !if(ctrl_arst)   
             end // always @ (posedge clock, posedge ctrl_arst)
           
           always @ (posedge clock)
             begin
          rdata &lt;= {FE_DATA_W{1&apos;b0}};
          invalidate &lt;= 1&apos;b0;
          counter_reset &lt;= 1&apos;b0;
          ready &lt;= valid; // Sends acknowlege the next clock cycle after request (handshake)               
          if(valid)
            if (addr == `ADDR_CACHE_HIT)
              rdata &lt;= hit_cnt;
            else if (addr == `ADDR_CACHE_MISS)
              rdata &lt;= miss_cnt;
            else if (addr == `ADDR_CACHE_READ_ACCESS)
              rdata &lt;= read_access_cnt;
            else if (addr == `ADDR_CACHE_READ_MISS)
              rdata &lt;= read_miss_cnt;
            else if (addr == `ADDR_CACHE_WRITE_ACCESS)
              rdata &lt;= write_access_cnt;
            else if (addr == `ADDR_CACHE_WRITE_MISS)
              rdata &lt;= write_miss_cnt;
            else if (addr == `ADDR_RESET_COUNTER)
              counter_reset &lt;= 1&apos;b1;
            else if (addr == `ADDR_CACHE_INVALIDATE)
              invalidate &lt;= 1&apos;b1;  
            else if (addr == `ADDR_BUFFER_EMPTY)
              rdata &lt;= wtbuf_empty;
            else if (addr == `ADDR_BUFFER_FULL)
              rdata &lt;= wtbuf_full;
             end // always @ (posedge clock)
        end // if (CTRL_CNT)
      else
        begin
           
           always @ (posedge clock)
             begin
          rdata &lt;= {FE_DATA_W{1&apos;b0}};
          invalidate &lt;= 1&apos;b0;
          ready &lt;= valid; // Sends acknowlege the next clock cycle after request (handshake)               
          if(valid)
            if (addr == `ADDR_CACHE_INVALIDATE)
              invalidate &lt;= 1&apos;b1;  
            else if (addr == `ADDR_BUFFER_EMPTY)
                    rdata &lt;= wtbuf_empty;
                  else if (addr == `ADDR_BUFFER_FULL)
                    rdata &lt;= wtbuf_full;         
             end // always @ (posedge clock)
        end // else: !if(CTRL_CNT)  
   endgenerate                
  "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_axi</name>
      <circuit>
        <component_o id="IOB_cache_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2022-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_DATA_W"> 32 </parameter>
          <parameter name="N_WAYS"> 1 </parameter>
          <parameter name="LINE_OFF_W"> 8 </parameter>
          <parameter name="WORD_OFF_W"> 4 </parameter>
          <parameter name="WTBUF_DEPTH_W"> 5 </parameter>
          <parameter name="REP_POLICY"> 2 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>
          <parameter name="BURST_TYPE"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="flush" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="dirty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_axi FE_ADDR_W BE_ADDR_W BE_DATA_W N_WAYS LINE_OFF_W WORD_OFF_W WTBUF_DEPTH_W REP_POLICY WRITE_POL AXI_ID CTRL_CACHE CTRL_CNT BURST_TYPE addr wdata wstrb rdata m_axi_awid m_axi_awaddr m_axi_awlen m_axi_wdata m_axi_wstrb m_axi_bid m_axi_arid m_axi_araddr m_axi_arlen m_axi_rid m_axi_rdata" IP_COMPONENT="IOB_front_end,IOB_cache_memory,IOB_back_end_axi,IOB_cache_control" VERILOG_PROVIDED="
   //Cache-Control
   `define CTRL_ADDR_W 4
   //Address-port
   `define WORD_ADDR // Word-addressable, (BE) addr becomes word-addressable (doesn&apos;t receive the byte-offset).

   
   localparam FE_DATA_W = BITSIZE_wdata;
   localparam NWAY_W = $clog2(N_WAYS);
   localparam FE_NBYTES = FE_DATA_W / 8;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   localparam BE_NBYTES = BE_DATA_W / 8;
   localparam BE_BYTE_W = $clog2(BE_NBYTES);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);
   localparam AXI_ADDR_W = BE_ADDR_W;
   localparam AXI_DATA_W = BE_DATA_W;
   localparam AXI_ID_W = 1;
   localparam AXI_LEN_W = 8;

   wire                                         data_valid, data_ready;
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr; 
   wire [FE_DATA_W-1 : 0]                       data_wdata, data_rdata;
   wire [FE_NBYTES-1: 0]                        data_wstrb;
   
   //stored signals
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr_reg; 
   wire [FE_DATA_W-1 : 0]                       data_wdata_reg;
   wire [FE_NBYTES-1: 0]                        data_wstrb_reg;
   wire                                         data_valid_reg;

   //back-end write-channel
   wire                                         write_valid, write_ready;
   wire [FE_ADDR_W-1:FE_BYTE_W + WRITE_POL*WORD_OFF_W] write_addr;
   wire [FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)-1 :0] write_wdata;
   wire [FE_NBYTES-1:0]                                                    write_wstrb;
   wire                                                                    write_done;
   
   //back-end read-channel
   wire                                                                    replace_valid, replace;
   wire [FE_ADDR_W -1:BE_BYTE_W+LINE2MEM_W]                                replace_addr; 
   wire                                                                    read_valid;
   wire [LINE2MEM_W-1:0]                                                   read_addr;
   wire [BE_DATA_W-1:0]                                                    read_rdata;
   
   //cache-control
   wire                                                                    ctrl_valid, ctrl_ready;   
   wire [`CTRL_ADDR_W-1:0]                                                 ctrl_addr;
   wire                                                                    wtbuf_full, wtbuf_empty;
   wire                                                                    write_hit, write_miss, read_hit, read_miss;
   wire [CTRL_CACHE*(FE_DATA_W-1):0]                                       ctrl_rdata;
   wire                                                                    invalidate;
   
   IOB_front_end
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT(CTRL_CNT),
       .BITSIZE_addr(CTRL_CACHE + FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata(FE_DATA_W),
       .BITSIZE_wstrb(FE_NBYTES),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_data_addr(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_rdata(FE_DATA_W),
       .BITSIZE_data_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_wdata_reg(FE_DATA_W),
       .BITSIZE_data_wstrb_reg(FE_NBYTES),
       .BITSIZE_ctrl_addr(`CTRL_ADDR_W),
       .BITSIZE_ctrl_rdata(CTRL_CACHE * (FE_DATA_W - 1) + 1)
       )
   front_end
     (
      .clock   (clock),
      .reset (reset),
      //front-end port
      .valid (valid),
      .addr  ({{CTRL_CACHE{1&apos;b0}}, addr}),
      .wdata (wdata),
      .wstrb (wstrb),
      .rdata (rdata),
      .ready (ready),
      //cache-memory input signals
      .data_valid (data_valid),
      .data_addr  (data_addr),
      //cache-memory output
      .data_rdata (data_rdata),
      .data_ready (data_ready),
      //stored input signals
      .data_valid_reg (data_valid_reg),
      .data_addr_reg  (data_addr_reg),
      .data_wdata_reg (data_wdata_reg),
      .data_wstrb_reg (data_wstrb_reg),
      //cache-control
      .ctrl_valid (ctrl_valid),
      .ctrl_addr  (ctrl_addr),
      .ctrl_rdata (ctrl_rdata),
      .ctrl_ready (ctrl_ready)
      );

   IOB_cache_memory
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .N_WAYS     (N_WAYS),
       .LINE_OFF_W (LINE_OFF_W),
       .WORD_OFF_W (WORD_OFF_W),
       .REP_POLICY (REP_POLICY),    
       .WTBUF_DEPTH_W (WTBUF_DEPTH_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT  (CTRL_CNT),
       .WRITE_POL (WRITE_POL),
       .BITSIZE_addr(FE_ADDR_W - (BE_BYTE_W + LINE2MEM_W)),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata_reg(FE_DATA_W),
       .BITSIZE_wstrb_reg(FE_NBYTES),
       .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_write_wstrb(FE_NBYTES),
       .BITSIZE_replace_addr(FE_ADDR_W - (BE_BYTE_W+LINE2MEM_W)),
       .BITSIZE_read_addr(LINE2MEM_W),
       .BITSIZE_read_rdata(BE_DATA_W)
       )
   cache_memory
     (
      .clock   (clock),
      .reset (reset),
      //front-end
      //internal data signals
      .valid (data_valid),
      .addr  (data_addr[FE_ADDR_W-1:BE_BYTE_W + LINE2MEM_W]),
      //.wdata (data_wdata),
      // .wstrb (data_wstrb),
      .rdata (data_rdata),
      .ready (data_ready),
      .dirty_mem (dirty),
      //stored data signals
      .valid_reg (data_valid_reg),   
      .addr_reg  (data_addr_reg),
      .wdata_reg (data_wdata_reg),
      .wstrb_reg (data_wstrb_reg),
      //back-end
      //write-through-buffer (write-channel)
      .write_valid (write_valid),
      .write_addr  (write_addr),
      .write_wdata (write_wdata),
      .write_wstrb (write_wstrb),
      .write_ready (write_ready),
      .write_done  (write_done),
      //cache-line replacement (read-channel)
      .replace_valid (replace_valid),
      .replace_addr  (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr  (read_addr),
      .read_rdata (read_rdata),
      //control&apos;s signals
      .wtbuf_empty (wtbuf_empty),
      .wtbuf_full  (wtbuf_full),
      .write_hit   (write_hit),
      .write_miss  (write_miss),
      .read_hit    (read_hit),
      .read_miss   (read_miss),
      .invalidate  (invalidate),
      .flush(flush)
      );


   IOB_back_end_axi
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .FE_DATA_W (FE_DATA_W),  
       .BE_ADDR_W (BE_ADDR_W),
       .WORD_OFF_W(WORD_OFF_W),
       .WRITE_POL (WRITE_POL),
       .AXI_ID(AXI_ID),
       .BURST_TYPE(BURST_TYPE),
       .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_write_wstrb(FE_NBYTES),
       .BITSIZE_replace_addr(FE_ADDR_W - (FE_BYTE_W + WORD_OFF_W)),
       .BITSIZE_read_addr(LINE2MEM_W),
       .BITSIZE_read_rdata(BE_DATA_W),
       .BITSIZE_m_axi_awid(AXI_ID_W),
       .BITSIZE_m_axi_awaddr(AXI_ADDR_W),
       .BITSIZE_m_axi_awlen(AXI_LEN_W),
       .BITSIZE_m_axi_wdata(AXI_DATA_W),
       .BITSIZE_m_axi_wstrb(AXI_DATA_W / 8),
       .BITSIZE_m_axi_bid(AXI_ID_W),
       .BITSIZE_m_axi_arid(AXI_ID_W),
       .BITSIZE_m_axi_araddr(AXI_ADDR_W),
       .BITSIZE_m_axi_arlen(AXI_LEN_W),
       .BITSIZE_m_axi_rid(AXI_ID_W),
       .BITSIZE_m_axi_rdata(AXI_DATA_W)       
              )
   back_end
     (
       //write-through-buffer (write-channel)
      .write_valid (write_valid),
      .write_addr  (write_addr),
      .write_wdata (write_wdata),
      .write_wstrb (write_wstrb),
      .write_ready (write_ready),
      .write_done  (write_done),
      //cache-line replacement (read-channel)
      .replace_valid (replace_valid),
      .replace_addr  (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr  (read_addr),
      .read_rdata (read_rdata),
      .m_axi_awid(m_axi_awid), //Address write channel ID
      .m_axi_awaddr(m_axi_awaddr), //Address write channel address
      .m_axi_awlen(m_axi_awlen), //Address write channel burst length
      .m_axi_awsize(m_axi_awsize), //Address write channel burst size. This signal indicates the size of each transfer in the burst
      .m_axi_awburst(m_axi_awburst), //Address write channel burst type
      .m_axi_awlock(m_axi_awlock), //Address write channel lock type
      .m_axi_awcache(m_axi_awcache), //Address write channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
      .m_axi_awprot(m_axi_awprot), //Address write channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
      .m_axi_awqos(m_axi_awqos), //Address write channel quality of service
      .m_axi_awvalid(m_axi_awvalid), //Address write channel valid
      .m_axi_awready(m_axi_awready), //Address write channel ready
      .m_axi_wdata(m_axi_wdata), //Write channel data
      .m_axi_wstrb(m_axi_wstrb), //Write channel write strobe
      .m_axi_wlast(m_axi_wlast), //Write channel last word flag
      .m_axi_wvalid(m_axi_wvalid), //Write channel valid
      .m_axi_wready(m_axi_wready), //Write channel ready
      .m_axi_bid(m_axi_bid), //Write response channel ID
      .m_axi_bresp(m_axi_bresp), //Write response channel response
      .m_axi_bvalid(m_axi_bvalid), //Write response channel valid
      .m_axi_bready(m_axi_bready), //Write response channel ready
      .m_axi_arid(m_axi_arid), //Address read channel ID
      .m_axi_araddr(m_axi_araddr), //Address read channel address
      .m_axi_arlen(m_axi_arlen), //Address read channel burst length
      .m_axi_arsize(m_axi_arsize), //Address read channel burst size. This signal indicates the size of each transfer in the burst
      .m_axi_arburst(m_axi_arburst), //Address read channel burst type
      .m_axi_arlock(m_axi_arlock), //Address read channel lock type
      .m_axi_arcache(m_axi_arcache), //Address read channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
      .m_axi_arprot(m_axi_arprot), //Address read channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
      .m_axi_arqos(m_axi_arqos), //Address read channel quality of service
      .m_axi_arvalid(m_axi_arvalid), //Address read channel valid
      .m_axi_arready(m_axi_arready), //Address read channel ready
      .m_axi_rid(m_axi_rid), //Read channel ID
      .m_axi_rdata(m_axi_rdata), //Read channel data
      .m_axi_rresp(m_axi_rresp), //Read channel response
      .m_axi_rlast(m_axi_rlast), //Read channel last word
      .m_axi_rvalid(m_axi_rvalid), //Read channel valid
      .m_axi_rready(m_axi_rready), //Read channel addr
      .clock(clock),
      .reset(reset)
      );
   
   
   generate
      if (CTRL_CACHE) begin : ctrl
        IOB_cache_control
          #(
            .CTRL_CNT   (CTRL_CNT),
            .BITSIZE_rdata(CTRL_CNT * FE_DATA_W)
            )
      cache_control
        (
         .clock   (clock),
         .reset (reset),
         //control&apos;s signals
         .valid (ctrl_valid),
         .addr  (ctrl_addr),
         //write data
         .wtbuf_full (wtbuf_full),
         .wtbuf_empty (wtbuf_empty), 
         .write_hit  (write_hit),
         .write_miss (write_miss),
         .read_hit   (read_hit),
         .read_miss  (read_miss),
         ////////////
         .rdata (ctrl_rdata),
         .ready (ctrl_ready),
         .invalidate (invalidate)
         );
      end else
        begin
           assign ctrl_rdata = 1&apos;bx;
           assign ctrl_ready = 1&apos;bx;
           assign invalidate = 1&apos;b0;
        end // else: !if(CTRL_CACHE)
      
   endgenerate

    // synthesis translate_off
    always @(posedge clock)
    begin
      if(m_axi_bresp != 0 || m_axi_rresp !=0)
      begin
        $display(&quot;ERROR: Sim: Abort incorret AXI answer from slave &quot;);
        $finish;
      end
    end
    // synthesis translate_on

   `undef CTRL_ADDR_W
   `undef WORD_ADDR
     "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_minimal_axi</name>
      <circuit>
        <component_o id="IOB_cache_minimal_axi">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_minimal_axi"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_DATA_W"> 32 </parameter>
          <parameter name="N_WAYS"> 1 </parameter>
          <parameter name="LINE_OFF_W"> 8 </parameter>
          <parameter name="WORD_OFF_W"> 4 </parameter>
          <parameter name="WTBUF_DEPTH_W"> 5 </parameter>
          <parameter name="REP_POLICY"> 2 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="AXI_ID"> 0 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_input" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="32"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="32"/>
          </port_o>
          <port_o id="Min_data_size_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="5"/>
          </port_o>
          <port_o id="Min_accelerator_context_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_back_pressure" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_datardy" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_Rdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="32"/>
          </port_o>
          <port_o id="Min_accelerator_context" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_back_pressure_in" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awaddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_awlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_awcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_awqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_awvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_awready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_wlast" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_wready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_bresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_bvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_bready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arid" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_araddr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arlen" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arsize" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arburst" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_arlock" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_arcache" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arprot" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="3"/>
          </port_o>
          <port_o id="m_axi_arqos" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="4"/>
          </port_o>
          <port_o id="m_axi_arvalid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_arready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rid" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="m_axi_rresp" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="2"/>
          </port_o>
          <port_o id="m_axi_rlast" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rvalid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="m_axi_rready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_minimal_axi FE_ADDR_W BE_ADDR_W BE_DATA_W N_WAYS LINE_OFF_W WORD_OFF_W WTBUF_DEPTH_W REP_POLICY WRITE_POL AXI_ID CTRL_CACHE CTRL_CNT Min_addr_ram Min_Wdata_ram Min_Rdata_ram Min_data_size_ram Min_accelerator_context_in Min_accelerator_context m_axi_awid m_axi_awaddr m_axi_awlen m_axi_wdata m_axi_wstrb m_axi_bid m_axi_arid m_axi_araddr m_axi_arlen m_axi_rid m_axi_rdata" IP_COMPONENT="IOB_front_end,IOB_cache_memory,IOB_back_end_axi,IOB_cache_control" VERILOG_PROVIDED="
   //Cache-Control
   `define CTRL_ADDR_W 4
   //Address-port
   `define WORD_ADDR // Word-addressable, (BE) addr becomes word-addressable (doesn&apos;t receive the byte-offset).

   
   localparam FE_DATA_W = BITSIZE_Min_Wdata_ram;
   localparam NWAY_W = $clog2(N_WAYS);
   localparam FE_NBYTES = FE_DATA_W / 8;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   localparam BE_NBYTES = BE_DATA_W / 8;
   localparam BE_BYTE_W = $clog2(BE_NBYTES);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);
   localparam AXI_ADDR_W = BE_ADDR_W;
   localparam AXI_DATA_W = BE_DATA_W;
   localparam AXI_ID_W = 1;
   localparam AXI_LEN_W = 8;

   wire                                         data_valid, data_ready;
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr; 
   wire [FE_DATA_W-1 : 0]                       data_wdata, data_rdata;
   wire [FE_NBYTES-1: 0]                        data_wstrb;
   
   //stored signals
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr_reg; 
   wire [FE_DATA_W-1 : 0]                       data_wdata_reg;
   wire [FE_NBYTES-1: 0]                        data_wstrb_reg;
   wire                                         data_valid_reg;

   //back-end write-channel
   wire                                         write_valid, write_ready;
   wire [FE_ADDR_W-1:FE_BYTE_W + WRITE_POL*WORD_OFF_W] write_addr;
   wire [FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)-1 :0] write_wdata;
   wire [FE_NBYTES-1:0]                                                    write_wstrb;
   wire                                                                    write_done;
   
   //back-end read-channel
   wire                                                                    replace_valid, replace;
   wire [FE_ADDR_W -1:BE_BYTE_W+LINE2MEM_W]                                replace_addr; 
   wire                                                                    read_valid;
   wire [LINE2MEM_W-1:0]                                                   read_addr;
   wire [BE_DATA_W-1:0]                                                    read_rdata;
   
   //cache-control
   wire                                                                    ctrl_valid, ctrl_ready;   
   wire [`CTRL_ADDR_W-1:0]                                                 ctrl_addr;
   wire                                                                    wtbuf_full, wtbuf_empty;
   wire                                                                    write_hit, write_miss, read_hit, read_miss;
   wire [CTRL_CACHE*(FE_DATA_W-1):0]                                       ctrl_rdata;
   wire                                                                    invalidate;
   
   wire                                                                    dirty;
   
   reg [BITSIZE_Min_accelerator_context - 1 : 0]                           acc_ctxt;
   reg                                                                     done_input_reg = 1&apos;b0;

   reg                                                                     done_input_reg = 1&apos;b0, done_input_next;

   reg                                                                     Min_back_pressure_progress;

   reg                                                                     Min_back_pressure;
   reg [BITSIZE_Min_addr_ram - 1 : 0]                                      addr_reg;

   reg                                                                     done;

   always @(*) begin
     done_input_next = done_input ? 1&apos;b1 : done_input_reg;
     if((Min_oe_ram || Min_we_ram) &amp;&amp; !Min_back_pressure_in) begin
       addr_reg = addr;
     end
   end

   always @(posedge clock) begin
     done_input_reg &lt;= done_input_next;
     if((Min_oe_ram || Min_we_ram) &amp;&amp; !data_valid_reg) begin
       acc_ctxt &lt;= Min_accelerator_context_in;
     end
     if(done_input_next) begin
       done &lt;= !dirty;
     end
     Min_back_pressure &lt;= data_valid_reg &amp;&amp; (Min_we_ram || Min_oe_ram) ? Min_back_pressure_progress : 1&apos;b0;
     Min_back_pressure_progress &lt;= data_valid_reg &amp;&amp; !Min_datardy ? 1&apos;b1 : 1&apos;b0;
   end

   assign Min_accelerator_context = acc_ctxt;
   
   IOB_front_end
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT(CTRL_CNT),
       .BITSIZE_addr(CTRL_CACHE + FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata(FE_DATA_W),
       .BITSIZE_wstrb(FE_NBYTES),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_data_addr(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_rdata(FE_DATA_W),
       .BITSIZE_data_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_wdata_reg(FE_DATA_W),
       .BITSIZE_data_wstrb_reg(FE_NBYTES),
       .BITSIZE_ctrl_addr(`CTRL_ADDR_W),
       .BITSIZE_ctrl_rdata(CTRL_CACHE * (FE_DATA_W - 1) + 1)
       )
   front_end
     (
      .clock   (clock),
      .reset (reset),
      //front-end port
      .valid (Min_oe_ram || Min_we_ram),
      .addr  (addr_reg[FE_ADDR_W - 1 : FE_BYTE_W]),
      .wdata (Min_Wdata_ram),
      .wstrb ({FE_NBYTES{Min_we_ram}}),
      .rdata (Min_Rdata_ram),
      .ready (Min_datardy),
      //cache-memory input signals
      .data_valid (data_valid),
      .data_addr  (data_addr),
      //cache-memory output
      .data_rdata (data_rdata),
      .data_ready (data_ready),
      //stored input signals
      .data_valid_reg (data_valid_reg),
      .data_addr_reg  (data_addr_reg),
      .data_wdata_reg (data_wdata_reg),
      .data_wstrb_reg (data_wstrb_reg),
      //cache-control
      .ctrl_valid (ctrl_valid),
      .ctrl_addr  (ctrl_addr),
      .ctrl_rdata (ctrl_rdata),
      .ctrl_ready (ctrl_ready)
      );

   IOB_cache_memory
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .N_WAYS     (N_WAYS),
       .LINE_OFF_W (LINE_OFF_W),
       .WORD_OFF_W (WORD_OFF_W),
       .REP_POLICY (REP_POLICY),    
       .WTBUF_DEPTH_W (WTBUF_DEPTH_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT  (CTRL_CNT),
       .WRITE_POL (WRITE_POL),
       .BITSIZE_addr(FE_ADDR_W - (BE_BYTE_W + LINE2MEM_W)),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata_reg(FE_DATA_W),
       .BITSIZE_wstrb_reg(FE_NBYTES),
       .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_write_wstrb(FE_NBYTES),
       .BITSIZE_replace_addr(FE_ADDR_W - (BE_BYTE_W+LINE2MEM_W)),
       .BITSIZE_read_addr(LINE2MEM_W),
       .BITSIZE_read_rdata(BE_DATA_W)
       )
   cache_memory
     (
      .clock   (clock),
      .reset (reset),
      //front-end
      //internal data signals
      .valid (data_valid),
      .addr  (data_addr[FE_ADDR_W-1:BE_BYTE_W + LINE2MEM_W]),
      //.wdata (data_wdata),
      // .wstrb (data_wstrb),
      .rdata (data_rdata),
      .ready (data_ready),
      .dirty_mem (dirty),
      //stored data signals
      .valid_reg (data_valid_reg),   
      .addr_reg  (data_addr_reg),
      .wdata_reg (data_wdata_reg),
      .wstrb_reg (data_wstrb_reg),
      //back-end
      //write-through-buffer (write-channel)
      .write_valid (write_valid),
      .write_addr  (write_addr),
      .write_wdata (write_wdata),
      .write_wstrb (write_wstrb),
      .write_ready (write_ready),
      .write_done  (write_done),
      //cache-line replacement (read-channel)
      .replace_valid (replace_valid),
      .replace_addr  (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr  (read_addr),
      .read_rdata (read_rdata),
      //control&apos;s signals
      .wtbuf_empty (wtbuf_empty),
      .wtbuf_full  (wtbuf_full),
      .write_hit   (write_hit),
      .write_miss  (write_miss),
      .read_hit    (read_hit),
      .read_miss   (read_miss),
      .flush(done_input_reg)
      );


   IOB_back_end_axi #(.FE_ADDR_W (FE_ADDR_W),
    .FE_DATA_W (FE_DATA_W),  
    .BE_ADDR_W (BE_ADDR_W),
    .WORD_OFF_W(WORD_OFF_W),
    .WRITE_POL (WRITE_POL),
    .AXI_ID(AXI_ID),
    .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
    .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
    .BITSIZE_write_wstrb(FE_NBYTES),
    .BITSIZE_replace_addr(FE_ADDR_W - (FE_BYTE_W + WORD_OFF_W)),
    .BITSIZE_read_addr(LINE2MEM_W),
    .BITSIZE_read_rdata(BE_DATA_W),
    .BITSIZE_m_axi_awid(AXI_ID_W),
    .BITSIZE_m_axi_awaddr(AXI_ADDR_W),
    .BITSIZE_m_axi_awlen(AXI_LEN_W),
    .BITSIZE_m_axi_wdata(AXI_DATA_W),
    .BITSIZE_m_axi_wstrb(AXI_DATA_W / 8),
    .BITSIZE_m_axi_bid(AXI_ID_W),
    .BITSIZE_m_axi_arid(AXI_ID_W),
    .BITSIZE_m_axi_araddr(AXI_ADDR_W),
    .BITSIZE_m_axi_arlen(AXI_LEN_W),
    .BITSIZE_m_axi_rid(AXI_ID_W),
    .BITSIZE_m_axi_rdata(AXI_DATA_W))
   back_end (.write_valid(write_valid),
    .write_addr(write_addr),
    .write_wdata(write_wdata),
    .write_wstrb(write_wstrb),
    .write_ready(write_ready),
    .write_done(write_done),
    //cache-line replacement(read-channel)
    .replace_valid(replace_valid),
    .replace_addr(replace_addr),
    .replace(replace),
    .read_valid(read_valid),
    .read_addr(read_addr),
    .read_rdata(read_rdata),
    .m_axi_awid(m_axi_awid), //Address write channel ID
    .m_axi_awaddr(m_axi_awaddr), //Address write channel address
    .m_axi_awlen(m_axi_awlen), //Address write channel burst length
    .m_axi_awsize(m_axi_awsize), //Address write channel burst size. This signal indicates the size of each transfer in the burst
    .m_axi_awburst(m_axi_awburst), //Address write channel burst type
    .m_axi_awlock(m_axi_awlock), //Address write channel lock type
    .m_axi_awcache(m_axi_awcache), //Address write channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
    .m_axi_awprot(m_axi_awprot), //Address write channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
    .m_axi_awqos(m_axi_awqos), //Address write channel quality of service
    .m_axi_awvalid(m_axi_awvalid), //Address write channel valid
    .m_axi_awready(m_axi_awready), //Address write channel ready
    .m_axi_wdata(m_axi_wdata), //Write channel data
    .m_axi_wstrb(m_axi_wstrb), //Write channel write strobe
    .m_axi_wlast(m_axi_wlast), //Write channel last word flag
    .m_axi_wvalid(m_axi_wvalid), //Write channel valid
    .m_axi_wready(m_axi_wready), //Write channel ready
    .m_axi_bid(m_axi_bid), //Write response channel ID
    .m_axi_bresp(m_axi_bresp), //Write response channel response
    .m_axi_bvalid(m_axi_bvalid), //Write response channel valid
    .m_axi_bready(m_axi_bready), //Write response channel ready
    .m_axi_arid(m_axi_arid), //Address read channel ID
    .m_axi_araddr(m_axi_araddr), //Address read channel address
    .m_axi_arlen(m_axi_arlen), //Address read channel burst length
    .m_axi_arsize(m_axi_arsize), //Address read channel burst size. This signal indicates the size of each transfer in the burst
    .m_axi_arburst(m_axi_arburst), //Address read channel burst type
    .m_axi_arlock(m_axi_arlock), //Address read channel lock type
    .m_axi_arcache(m_axi_arcache), //Address read channel memory type. Transactions set with Normal Non-cacheable Modifiable and Bufferable (0011).
    .m_axi_arprot(m_axi_arprot), //Address read channel protection type. Transactions set with Normal, Secure, and Data attributes (000).
    .m_axi_arqos(m_axi_arqos), //Address read channel quality of service
    .m_axi_arvalid(m_axi_arvalid), //Address read channel valid
    .m_axi_arready(m_axi_arready), //Address read channel ready
    .m_axi_rid(m_axi_rid), //Read channel ID
    .m_axi_rdata(m_axi_rdata), //Read channel data
    .m_axi_rresp(m_axi_rresp), //Read channel response
    .m_axi_rlast(m_axi_rlast), //Read channel last word
    .m_axi_rvalid(m_axi_rvalid), //Read channel valid
    .m_axi_rready(m_axi_rready), //Read channel addr
    .clock(clock),
    .reset(reset)));
   
   
   generate
      if (CTRL_CACHE)
        IOB_cache_control
          #(
            .CTRL_CNT   (CTRL_CNT),
            .BITSIZE_rdata(CTRL_CNT * FE_DATA_W)
            )
      cache_control
        (
         .clock   (clock),
         .reset (reset),
         //control&apos;s signals
         .valid (ctrl_valid),
         .addr  (ctrl_addr),
         //write data
         .wtbuf_full (wtbuf_full),
         .wtbuf_empty (wtbuf_empty), 
         .write_hit  (write_hit),
         .write_miss (write_miss),
         .read_hit   (read_hit),
         .read_miss  (read_miss),
         ////////////
         .rdata (ctrl_rdata),
         .ready (ctrl_ready),
         .invalidate (invalidate)
         );
      else
        begin
           assign ctrl_rdata = 1&apos;bx;
           assign ctrl_ready = 1&apos;bx;
           assign invalidate = 1&apos;b0;
        end // else: !if(CTRL_CACHE)
      
   endgenerate
   `undef CTRL_ADDR_W
   `undef WORD_ADDR
     "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_read_channel_minimal</name>
      <circuit>
        <component_o id="IOB_read_channel_minimal">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_read_channel_minimal"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="mem_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="mem_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_rdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_read_channel_minimal FE_ADDR_W FE_DATA_W WORD_OFF_W replace_addr read_addr read_rdata mem_addr mem_rdata" VERILOG_PROVIDED="
   localparam BE_ADDR_W = BITSIZE_mem_addr;
   localparam BE_DATA_W = BITSIZE_read_rdata;
   localparam BE_BYTE_W = $clog2(BE_DATA_W / 8);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);

   reg [BITSIZE_read_addr - 1 : 0] read_addr;
   reg read_valid;
   reg mem_valid;
   reg replace;

   generate
      if (LINE2MEM_W &gt; 0)
        begin

           reg [LINE2MEM_W-1:0] word_counter;
           
           assign mem_addr  = {BE_ADDR_W{1&apos;b0}} + {replace_addr[FE_ADDR_W -1 - (BE_BYTE_W + LINE2MEM_W): 0], word_counter, {BE_BYTE_W{1&apos;b0}}};
           

           // assign read_valid = mem_ready;
           assign read_rdata = mem_rdata;

           localparam
             idle             = 2&apos;d0,
             read             = 2&apos;d1, 
             delay            = 2&apos;d2;

           always @ (posedge clock)
             read_addr &lt;= word_counter;
           
           reg [1:0]            state;

           always @(posedge clock 1RESET_EDGE)
             begin
                if(1RESET_VALUE)
                  begin
                     state &lt;= idle;
                  end
                else
                  begin
                     case(state)

                       idle:
                         begin
                            if(replace_valid) //main_process flag
                              state &lt;= read;                                        
                            else
                              state &lt;= idle;                      
                         end
                       
                       read:
                         begin
                            state &lt;= delay;
                         end
                       
                       delay: 
                         begin
                            if(mem_ready)
                              if(read_addr == {LINE2MEM_W{1&apos;b1}})
                                state &lt;= idle;
                              else
                                begin
                                   state &lt;= read;
                                end
                            else
                              begin
                                 state &lt;= delay;
                              end
                         end
                       
                       default:;
                       
                     endcase                                                     
                  end         
             end
           
           
           always @(*)
             begin 
                mem_valid     = 1&apos;b0;
                replace       = 1&apos;b1;
                word_counter  = 0;
                read_valid    = 1&apos;b0;
                
                case(state)
                  
                  idle:
                    begin
                       replace = 1&apos;b0;
                    end

                  read:
                    begin
                       mem_valid = 1&apos;b1;
                       word_counter = read_addr;
                    end
                  
                  delay:
                    begin
                       word_counter = read_addr + mem_ready;
                       read_valid = mem_ready;
                    end
                  default:;
                  
                  
                endcase
             end
        end // if (LINE2MEM_W &gt; 0)
      else
        begin
           assign mem_addr  = {BE_ADDR_W{1&apos;b0}} + {replace_addr, {BE_BYTE_W{1&apos;b0}}};
           
           // assign read_valid = mem_valid; //doesn require line_load since when mem_valid is HIGH, so is line_load.
           assign read_rdata = mem_rdata;

           localparam
             idle             = 2&apos;d0,
             read             = 2&apos;d1, 
             delay            = 2&apos;d2;
           
           
           reg [1:0]                                  state;

           always @(posedge clock 1RESET_EDGE)
             begin
                if(1RESET_VALUE)
                  state &lt;= idle;
                else
                  begin
                     case(state)

                       idle:
                         begin
                            
                            if(replace_valid)
                              state &lt;= read;                                        
                            else
                              state &lt;= idle;                      
                         end
                       
                       read:
                         begin
                            state &lt;= delay;
                         end
                       
                       delay:
                         begin
                            if(mem_ready)
                              state &lt;= idle;
                            else
                              state &lt;= delay;
                         end
                       
                       default:;
                       
                     endcase                                                     
                  end         
             end
           
           
           always @(*)
             begin 
                mem_valid     = 1&apos;b0;
                replace       = 1&apos;b1;
                read_valid    = 1&apos;b0;
                
                case(state)
                  
                  idle:
                    begin
                       replace = 1&apos;b0;
                    end

                  read:
                    begin
                       mem_valid = 1&apos;b1;
                    end
                  
                  delay:
                    begin
                       read_valid = mem_ready;
                    end
                  
                  default:;
                  
                endcase
             end
           
        end // else: !if(MEM_OFF_W &gt; 0)
      endgenerate
        "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_write_channel_minimal</name>
      <circuit>
        <component_o id="IOB_write_channel_minimal">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_write_channel_minimal"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="mem_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="mem_wdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="mem_wstrb" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_write_channel_minimal FE_ADDR_W FE_DATA_W WRITE_POL WORD_OFF_W addr wstrb wdata mem_addr mem_wdata mem_wstrb" VERILOG_PROVIDED="
    localparam FE_NBYTES = BITSIZE_wstrb;
    localparam FE_BYTE_W = $clog2(FE_NBYTES);
    localparam BE_ADDR_W = BITSIZE_mem_addr;
    localparam BE_DATA_W = BITSIZE_mem_wdata;
    localparam BE_NBYTES = BE_DATA_W / 8;
    localparam BE_BYTE_W = $clog2(BE_NBYTES);
    localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);

    reg mem_wstrb;
    reg ready;
    reg mem_valid;



    assign write_done=mem_ready;
    
    genvar                                                                   i;

    generate
      if(WRITE_POL == 0) begin

        assign mem_addr = {BE_ADDR_W{1&apos;b0}} + {addr[FE_ADDR_W-1 - (FE_BYTE_W + WRITE_POL*WORD_OFF_W) :BE_BYTE_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)], {BE_BYTE_W{1&apos;b0}}};

        localparam
          idle  = 2&apos;d0,
          write = 2&apos;d1,
          delay  = 2&apos;d2;

          reg [1:0] state;
          if(BE_DATA_W == FE_DATA_W) begin
            assign mem_wdata = wdata;
            always @(*) begin
              mem_wstrb = 0;
              case(state)
                write: mem_wstrb = wstrb;
                default:;
              endcase // case (state)
            end // always @ *
          end
          else begin
            wire [BE_BYTE_W-FE_BYTE_W -1 :0] word_align = addr[FE_BYTE_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W) +: (BE_BYTE_W - FE_BYTE_W)];

            for (i = 0; i &lt; BE_DATA_W/FE_DATA_W; i = i +1) begin : wdata_block
              assign mem_wdata[(i+1)*FE_DATA_W-1:i*FE_DATA_W] = wdata;
            end

            always @(*) begin
              mem_wstrb = 0;
              case(state)
                write: mem_wstrb = wstrb &lt;&lt; word_align * FE_NBYTES;
                default:;
              endcase // case (state)
            end // always @ *
          end

          always @(posedge clock 1RESET_EDGE) begin
            if(1RESET_VALUE)
              state &lt;= idle;
            else
              case(state)
                idle: begin
                  if(valid)
                    state &lt;= write;
                  else
                    state &lt;= idle;
                end
                write: begin
                    state &lt;= delay;
                end
                default: begin /* delay */
                  if(mem_ready &amp; ~valid)
                    state &lt;= idle;
                  else
                    if(mem_ready &amp; valid) //still has data to write
                      state &lt;= write;
                    else
                      state &lt;= delay;
                end
              endcase // case (state)
          end // always @ (posedge clock 1RESET_EDGE)

         always @(*)
           begin
              ready = 1&apos;b0;
              mem_valid = 1&apos;b0;
              case(state)
                idle:
                  ready = 1&apos;b1;
                write:
                  mem_valid = ~mem_ready;
                default: /* delay */
                  begin
                     ready = mem_ready;
                  end
              endcase // case (state)
           end
      end // if (WRITE_POL == WRITE_THROUGH)
      //////////////////////////////////////////////////////////////////////////////////////////////
      else begin // if (WRITE_POL == WRITE_BACK)

         if (LINE2MEM_W &gt; 0) begin

            reg [LINE2MEM_W-1:0] word_counter, word_counter_reg;
            always @(posedge clock) word_counter_reg &lt;= word_counter;

            // memory address
            assign mem_addr  = {BE_ADDR_W{1&apos;b0}} + {addr[FE_ADDR_W-1 - (FE_BYTE_W + WRITE_POL*WORD_OFF_W) : BE_BYTE_W + LINE2MEM_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)], word_counter, {BE_BYTE_W{1&apos;b0}}};
            // memory write-data
            assign mem_wdata = wdata&gt;&gt;(BE_DATA_W*word_counter);

            localparam
              idle  = 2&apos;d0,
              write = 2&apos;d1,
              delay = 2&apos;d2;

            reg [1:0]            state;

            always @(posedge clock 1RESET_EDGE)
              begin
                 if(1RESET_VALUE)
                   state &lt;= idle;
                 else
                   case(state)

                     idle:
                       begin
                          if(valid)
                            state &lt;= write;
                          else
                            state &lt;= idle;
                       end

                     write:
                       state &lt;= delay;
                     default: /* delay */
                       begin
                          if(mem_ready &amp; (&amp;word_counter_reg))
                            state &lt;= idle;
                          else if(mem_ready)
                            state &lt;= write;
                          else
                            state &lt;= delay;
                       end
                   endcase // case (state)
              end // always @ (posedge clock 1RESET_EDGE)

            always @(*)
              begin
                 ready        = 1&apos;b0;
                 mem_valid    = 1&apos;b0;
                 mem_wstrb    = 0;
                 word_counter = 0;

                 case(state)
                   idle:
                     begin
                        ready = ~valid;
                        if(valid) mem_wstrb = {BE_NBYTES{1&apos;b1}};
                        else mem_wstrb =0;
                     end

                   write:
                     begin
                        mem_valid = ~(mem_ready &amp; (&amp;word_counter));
                        mem_wstrb = {BE_NBYTES{1&apos;b1}};
                        word_counter = word_counter_reg;
                     end
                   default: /* delay */
                     begin
                        ready = mem_ready &amp; (&amp;word_counter); //last word transfered
                        word_counter = word_counter_reg + mem_ready;
                     end
                 endcase // case (state)
              end

         end // if (LINE2MEM_W &gt; 0)
         else begin // if (LINE2MEM_W == 0)

            // memory address
            assign mem_addr  = {BE_ADDR_W{1&apos;b0}} + {addr[FE_ADDR_W-1 - (FE_BYTE_W + WRITE_POL*WORD_OFF_W) : BE_BYTE_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)], {BE_BYTE_W{1&apos;b0}}};
            // memory write-data
            assign mem_wdata = wdata;

            localparam
              idle  = 2&apos;d0,
              write = 2&apos;d1,
              delay = 2&apos;d2;

            reg [1:0]            state;

            always @(posedge clock 1RESET_EDGE)
              begin
                 if(1RESET_VALUE)
                   state &lt;= idle;
                 else
                   case(state)

                     idle:
                       begin
                          if(valid)
                            state &lt;= write;
                          else
                            state &lt;= idle;
                       end

                     write:
                       begin
                         state &lt;= delay;
                       end
                     default:
                       begin
                          if(mem_ready)
                            state &lt;= idle;
                          else
                            state &lt;= delay;
                       end
                   endcase // case (state)
              end // always @ (posedge clock 1RESET_EDGE)

            always @(*)
              begin
                 ready        = 1&apos;b0;
                 mem_valid    = 1&apos;b0;
                 mem_wstrb    = 0;

                 case(state)
                   idle:
                     begin
                        ready = ~valid;
                        if(valid) mem_wstrb = {BE_NBYTES{1&apos;b1}};
                        else mem_wstrb = 0;
                     end

                   write:
                     begin
                        mem_valid = ~mem_ready;
                        mem_wstrb = {BE_NBYTES{1&apos;b1}};
                     end
                   default: /* delay */
                     begin
                        ready = mem_ready;
                     end
                 endcase // case (state)
              end // always @ *

         end // else: !if(LINE2MEM_W &gt; 0)
      end // else: !if(WRITE_POL == WRITE_THROUGH)
   endgenerate
        "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_back_end_minimal</name>
      <circuit>
        <component_o id="IOB_back_end_minimal">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_back_end_minimal"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="FE_DATA_W"> 32 </parameter>
          <parameter name="WORD_OFF_W"> 3 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wdata" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_wstrb" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_ready" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_valid" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="replace_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="replace" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_valid" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="read_addr" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_rdata" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="acc_ctxt" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="back_pressure" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_accelerator_context" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_back_pressure" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_data_ready" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_accelerator_context" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_back_pressure" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="write_done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_back_end_minimal FE_ADDR_W FE_DATA_W WORD_OFF_W BE_ADDR_W WRITE_POL write_addr write_wdata write_wstrb replace_addr read_addr read_rdata acc_ctxt Mout_addr_ram Mout_Wdata_ram Mout_data_ram_size Mout_accelerator_context M_Rdata_ram M_accelerator_context" IP_COMPONENT="IOB_read_channel_minimal,IOB_write_channel_minimal" VERILOG_PROVIDED="
   localparam BE_DATA_W = BITSIZE_read_rdata;
   localparam BE_NBYTES = BE_DATA_W / 8;

   wire [BE_ADDR_W-1:0]                                                      mem_addr_read,  mem_addr_write;
   wire                                                                      mem_valid_read, mem_valid_write;
   
   reg                                                                       acc_ctxt_reg;
   
   always @(posedge clock) begin
     if(write_valid || replace_valid) begin
        acc_ctxt_reg &lt;= acc_ctxt;
     end
   end

   assign Mout_addr_ram =  mem_valid_read ? mem_addr_read : mem_valid_write ? mem_addr_write : &apos;b0;
   assign Mout_oe_ram = mem_valid_read;
   assign Mout_we_ram = mem_valid_write;
   assign Mout_data_ram_size = BE_DATA_W;
   assign Mout_accelerator_context = acc_ctxt_reg;
   assign M_back_pressure = back_pressure;
   
   
   IOB_read_channel_minimal
     #(
       .FE_ADDR_W(FE_ADDR_W),
       .FE_DATA_W(FE_DATA_W),  
       .WORD_OFF_W(WORD_OFF_W),
       .BITSIZE_replace_addr(BITSIZE_replace_addr),
       .BITSIZE_read_addr(BITSIZE_read_addr),
       .BITSIZE_read_rdata(BITSIZE_read_rdata),
       .BITSIZE_mem_addr(BE_ADDR_W),
       .BITSIZE_mem_rdata(BITSIZE_M_Rdata_ram)
       )
   read_fsm
     (
      .clock(clock),
      .reset(reset),
      .replace_valid (replace_valid),
      .replace_addr (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr (read_addr),
      .read_rdata (read_rdata),
      .mem_addr(mem_addr_read),
      .mem_valid(mem_valid_read),
      .mem_ready(M_data_ready),
      .mem_rdata(M_Rdata_ram)  
      );

   IOB_write_channel_minimal
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .FE_DATA_W (FE_DATA_W),
       .WRITE_POL (WRITE_POL),
       .WORD_OFF_W(WORD_OFF_W),
       .BITSIZE_addr(BITSIZE_write_addr),
       .BITSIZE_wstrb(BITSIZE_write_wstrb),
       .BITSIZE_wdata(BITSIZE_write_wdata),
       .BITSIZE_mem_addr(BE_ADDR_W),
       .BITSIZE_mem_wdata(BITSIZE_Mout_Wdata_ram),
       .BITSIZE_mem_wstrb(BE_NBYTES)
       )
   write_fsm
     (
      .clock(clock),
      .reset(reset),
      .valid (write_valid),
      .addr (write_addr),
      .wstrb (write_wstrb),
      .wdata (write_wdata),
      .ready (write_ready),
      .mem_addr(mem_addr_write),
      .mem_valid(mem_valid_write),
      .mem_ready(M_data_ready),
      .mem_wdata(Mout_Wdata_ram),
      .mem_wstrb(mem_wstrb),
      .write_done(write_done));
   
        "/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>IOB_cache_minimal_minimal</name>
      <circuit>
        <component_o id="IOB_cache_minimal_minimal">
          <description>This component is based on the work available at https://github.com/IObundle/iob-cache and it is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2023-2024 Politecnico di Milano</copyright>
          <authors>Claudio Barone &lt;claudio.barone@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <structural_type_descriptor id_type="IOB_cache_minimal_minimal"/>
          <parameter name="FE_ADDR_W"> 32 </parameter>
          <parameter name="BE_ADDR_W"> 32 </parameter>
          <parameter name="BE_DATA_W"> 32 </parameter>
          <parameter name="N_WAYS"> 1 </parameter>
          <parameter name="LINE_OFF_W"> 8 </parameter>
          <parameter name="WORD_OFF_W"> 4 </parameter>
          <parameter name="WTBUF_DEPTH_W"> 5 </parameter>
          <parameter name="REP_POLICY"> 2 </parameter>
          <parameter name="WRITE_POL"> 0 </parameter>
          <parameter name="CTRL_CACHE"> 0 </parameter>
          <parameter name="CTRL_CNT"> 0 </parameter>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_input" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_data_size_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_accelerator_context_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_back_pressure" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_datardy" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_Rdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_accelerator_context" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_back_pressure_in" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_accelerator_context" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_back_pressure" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_accelerator_context" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_back_pressure" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="IOB_cache_minimal_minimal FE_ADDR_W BE_ADDR_W BE_DATA_W N_WAYS LINE_OFF_W WORD_OFF_W WTBUF_DEPTH_W REP_POLICY WRITE_POL CTRL_CACHE CTRL_CNT Min_addr_ram Min_Wdata_ram  Min_data_size_ram Min_accelerator_context_in Min_Rdata_ram Min_accelerator_context Mout_addr_ram Mout_Wdata_ram Mout_data_ram_size Mout_accelerator_context M_Rdata_ram M_accelerator_context" IP_COMPONENT="IOB_front_end,IOB_cache_memory,IOB_back_end_minimal" VERILOG_PROVIDED="
   //Cache-Control
   `define CTRL_ADDR_W 4
   //Address-port
   `define WORD_ADDR // Word-addressable, (BE) addr becomes word-addressable (doesn&apos;t receive the byte-offset).

   
   localparam FE_DATA_W = BITSIZE_Min_Wdata_ram;
   localparam NWAY_W = $clog2(N_WAYS);
   localparam FE_NBYTES = FE_DATA_W / 8;
   localparam FE_BYTE_W = $clog2(FE_NBYTES);
   localparam BE_NBYTES = BE_DATA_W / 8;
   localparam BE_BYTE_W = $clog2(BE_NBYTES);
   localparam LINE2MEM_W = WORD_OFF_W-$clog2(BE_DATA_W/FE_DATA_W);

   wire                                         data_valid, data_ready;
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr; 
   wire [FE_DATA_W-1 : 0]                       data_wdata, data_rdata;
   wire [FE_NBYTES-1: 0]                        data_wstrb;
   
   //stored signals
   wire [FE_ADDR_W -1:FE_BYTE_W]                data_addr_reg; 
   wire [FE_DATA_W-1 : 0]                       data_wdata_reg;
   wire [FE_NBYTES-1: 0]                        data_wstrb_reg;
   wire                                         data_valid_reg;

   //back-end write-channel
   wire                                         write_valid, write_ready;
   wire [FE_ADDR_W-1:FE_BYTE_W + WRITE_POL*WORD_OFF_W] write_addr;
   wire [FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)-1 :0] write_wdata;
   wire [FE_NBYTES-1:0]                                                    write_wstrb;
   wire                                                                    write_done;
   
   //back-end read-channel
   wire                                                                    replace_valid, replace;
   wire [FE_ADDR_W -1:BE_BYTE_W+LINE2MEM_W]                                replace_addr; 
   wire                                                                    read_valid;
   wire [LINE2MEM_W-1:0]                                                   read_addr;
   wire [BE_DATA_W-1:0]                                                    read_rdata;
   
   //cache-control
   wire                                                                    ctrl_valid, ctrl_ready;   
   wire [`CTRL_ADDR_W-1:0]                                                 ctrl_addr;
   wire                                                                    wtbuf_full, wtbuf_empty;
   wire                                                                    write_hit, write_miss, read_hit, read_miss;
   wire [CTRL_CACHE*(FE_DATA_W-1):0]                                       ctrl_rdata;
   wire                                                                    invalidate;
   
   wire                                                                    dirty;
   
   reg [BITSIZE_Min_accelerator_context - 1 : 0]                           acc_ctxt;
   reg                                                                     done_input_reg = 1&apos;b0, done_input_next;

   reg                                                                     Min_back_pressure_progress;

   reg                                                                     Min_back_pressure;

   wire [BITSIZE_Min_addr_ram - 1 : 0]                                     addr_reg_next;
   reg [BITSIZE_Min_addr_ram - 1 : 0]                                      addr_reg;

   reg                                                                     done;
   wire [BITSIZE_Min_Rdata_ram - 1 : 0]                                    rdata;

   always @(*) 
   begin
     done_input_next = done_input ? 1&apos;b1 : done_input_reg;
     addr_reg_next = ((Min_oe_ram || Min_we_ram) &amp;&amp; !Min_back_pressure_in) ? Min_addr_ram : addr_reg;
   end

  always @(posedge clock)
  begin
    if(1RESET_VALUE)
    begin
      addr_reg &lt;= 0;
      done_input_reg &lt;= 0;
    end
    else
    begin
      addr_reg &lt;= addr_reg_next;
      done_input_reg &lt;= done_input_next;
    end
  end

   always @(posedge clock) 
   begin
     if((Min_oe_ram || Min_we_ram) &amp;&amp; !data_valid_reg) 
     begin
       acc_ctxt &lt;= Min_accelerator_context_in;
     end
     if(done_input_next) 
     begin
       done &lt;= !dirty;
     end
     Min_back_pressure &lt;= data_valid_reg &amp;&amp; (Min_we_ram || Min_oe_ram) ? Min_back_pressure_progress : 1&apos;b0;
     Min_back_pressure_progress &lt;= data_valid_reg &amp;&amp; !Min_datardy ? 1&apos;b1 : 1&apos;b0;   
   end

   assign Min_accelerator_context = acc_ctxt;
   assign Min_Rdata_ram = Min_datardy ? rdata : 0;

   IOB_front_end
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT(CTRL_CNT),
       .BITSIZE_addr(CTRL_CACHE + FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata(FE_DATA_W),
       .BITSIZE_wstrb(FE_NBYTES),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_data_addr(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_rdata(FE_DATA_W),
       .BITSIZE_data_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_data_wdata_reg(FE_DATA_W),
       .BITSIZE_data_wstrb_reg(FE_NBYTES),
       .BITSIZE_ctrl_addr(`CTRL_ADDR_W),
       .BITSIZE_ctrl_rdata(CTRL_CACHE * (FE_DATA_W - 1) + 1)
       )
   front_end
     (
      .clock   (clock),
      .reset (reset),
      //front-end port
      .valid (Min_oe_ram || Min_we_ram),
      .addr  (addr_reg_next[FE_ADDR_W - 1 : FE_BYTE_W]),
      .wdata (Min_Wdata_ram),
      .wstrb ({FE_NBYTES{Min_we_ram}}),
      .rdata (rdata),
      .ready (Min_datardy),
      //cache-memory input signals
      .data_valid (data_valid),
      .data_addr  (data_addr),
      //cache-memory output
      .data_rdata (data_rdata),
      .data_ready (data_ready),
      //stored input signals
      .data_valid_reg (data_valid_reg),
      .data_addr_reg  (data_addr_reg),
      .data_wdata_reg (data_wdata_reg),
      .data_wstrb_reg (data_wstrb_reg),
      //cache-control
      .ctrl_valid (ctrl_valid),
      .ctrl_addr  (ctrl_addr),
      .ctrl_rdata (ctrl_rdata),
      .ctrl_ready (ctrl_ready)
      );

   IOB_cache_memory
     #(
       .FE_ADDR_W (FE_ADDR_W),
       .N_WAYS     (N_WAYS),
       .LINE_OFF_W (LINE_OFF_W),
       .WORD_OFF_W (WORD_OFF_W),
       .REP_POLICY (REP_POLICY),    
       .WTBUF_DEPTH_W (WTBUF_DEPTH_W),
       .CTRL_CACHE(CTRL_CACHE),
       .CTRL_CNT  (CTRL_CNT),
       .WRITE_POL (WRITE_POL),
       .BITSIZE_addr(FE_ADDR_W - (BE_BYTE_W + LINE2MEM_W)),
       .BITSIZE_rdata(FE_DATA_W),
       .BITSIZE_addr_reg(FE_ADDR_W - FE_BYTE_W),
       .BITSIZE_wdata_reg(FE_DATA_W),
       .BITSIZE_wstrb_reg(FE_NBYTES),
       .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL*WORD_OFF_W)),
       .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
       .BITSIZE_write_wstrb(FE_NBYTES),
       .BITSIZE_replace_addr(FE_ADDR_W - (BE_BYTE_W+LINE2MEM_W)),
       .BITSIZE_read_addr(LINE2MEM_W),
       .BITSIZE_read_rdata(BE_DATA_W)
       )
   cache_memory
     (
      .clock   (clock),
      .reset (reset),
      //front-end
      //internal data signals
      .valid (data_valid),
      .addr  (data_addr[FE_ADDR_W-1:BE_BYTE_W + LINE2MEM_W]),
      //.wdata (data_wdata),
      // .wstrb (data_wstrb),
      .rdata (data_rdata),
      .ready (data_ready),
      .dirty_mem (dirty),
      //stored data signals
      .valid_reg (data_valid_reg),   
      .addr_reg  (data_addr_reg),
      .wdata_reg (data_wdata_reg),
      .wstrb_reg (data_wstrb_reg),
      //back-end
      //write-through-buffer (write-channel)
      .write_valid (write_valid),
      .write_addr  (write_addr),
      .write_wdata (write_wdata),
      .write_wstrb (write_wstrb),
      .write_ready (write_ready),
      .write_done  (write_done),
      //cache-line replacement (read-channel)
      .replace_valid (replace_valid),
      .replace_addr  (replace_addr),
      .replace (replace),
      .read_valid (read_valid),
      .read_addr  (read_addr),
      .read_rdata (read_rdata),
      //control&apos;s signals
      .wtbuf_empty (wtbuf_empty),
      .wtbuf_full  (wtbuf_full),
      .write_hit   (write_hit),
      .write_miss  (write_miss),
      .read_hit    (read_hit),
      .read_miss   (read_miss),
      .flush(done_input)
      );

   IOB_back_end_minimal
     #(
        .FE_ADDR_W(FE_ADDR_W),
        .FE_DATA_W(FE_DATA_W),
        .WORD_OFF_W(WORD_OFF_W),
        .BE_ADDR_W(BE_ADDR_W),
        .BITSIZE_write_addr(FE_ADDR_W - (FE_BYTE_W + WRITE_POL * WORD_OFF_W)),
        .BITSIZE_write_wdata(FE_DATA_W + WRITE_POL*(FE_DATA_W*(2**WORD_OFF_W)-FE_DATA_W)),
        .BITSIZE_write_wstrb(FE_NBYTES),
        .BITSIZE_replace_addr(FE_ADDR_W - (FE_BYTE_W + WORD_OFF_W)),
        .BITSIZE_read_addr(LINE2MEM_W),
        .BITSIZE_read_rdata(BE_DATA_W),
        .BITSIZE_acc_ctxt(BITSIZE_Min_accelerator_context_in),
        .BITSIZE_Mout_addr_ram(BE_ADDR_W),
        .BITSIZE_Mout_Wdata_ram(BE_DATA_W),
        .BITSIZE_Mout_data_ram_size(BITSIZE_Min_data_size_ram),
        .BITSIZE_Mout_accelerator_context(BITSIZE_Mout_accelerator_context),
        .BITSIZE_M_Rdata_ram(BE_DATA_W),
        .BITSIZE_M_accelerator_context(BITSIZE_M_accelerator_context)
     ) 
     back_end (
        .clock(clock),
        .reset(reset),
        .write_valid (write_valid),
        .write_addr  (write_addr),
        .write_wdata (write_wdata),
        .write_wstrb (write_wstrb),
        .write_ready (write_ready),
        .write_done  (write_done),
        .replace_valid (replace_valid),
        .replace_addr  (replace_addr),
        .replace (replace),
        .read_valid (read_valid),
        .read_addr  (read_addr),
        .read_rdata (read_rdata),
        .acc_ctxt   (acc_ctxt),
        .back_pressure(Min_back_pressure_in),
        .Mout_oe_ram(Mout_oe_ram),
        .Mout_we_ram(Mout_we_ram),
        .Mout_addr_ram(Mout_addr_ram),
        .Mout_Wdata_ram(Mout_Wdata_ram),
        .Mout_data_ram_size(Mout_data_ram_size),
        .Mout_accelerator_context(Mout_accelerator_context),
        .Mout_back_pressure(Mout_back_pressure),
        .M_data_ready(M_DataRdy),
        .M_Rdata_ram(M_Rdata_ram),
        .M_accelerator_context(M_accelerator_context),
        .M_back_pressure(M_back_pressure)
     );
   
   
   generate
      if (CTRL_CACHE)
        IOB_cache_control
          #(
            .CTRL_CNT   (CTRL_CNT),
            .BITSIZE_rdata(CTRL_CNT * FE_DATA_W)
            )
      cache_control
        (
         .clock   (clock),
         .reset (reset),
         //control&apos;s signals
         .valid (ctrl_valid),
         .addr  (ctrl_addr),
         //write data
         .wtbuf_full (wtbuf_full),
         .wtbuf_empty (wtbuf_empty), 
         .write_hit  (write_hit),
         .write_miss (write_miss),
         .read_hit   (read_hit),
         .read_miss  (read_miss),
         ////////////
         .rdata (ctrl_rdata),
         .ready (ctrl_ready),
         .invalidate (invalidate)
         );
      else
        begin
           assign ctrl_rdata = 1&apos;bx;
           assign ctrl_ready = 1&apos;bx;
           assign invalidate = 1&apos;b0;
        end // else: !if(CTRL_CACHE)
      
   endgenerate
   `undef CTRL_ADDR_W
   `undef WORD_ADDR"/>
        </component_o>
      </circuit>
    </cell>
  </library>
</technology>
