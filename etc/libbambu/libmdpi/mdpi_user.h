/*
 *
 *                   _/_/_/    _/_/   _/    _/ _/_/_/    _/_/
 *                  _/   _/ _/    _/ _/_/  _/ _/   _/ _/    _/
 *                 _/_/_/  _/_/_/_/ _/  _/_/ _/   _/ _/_/_/_/
 *                _/      _/    _/ _/    _/ _/   _/ _/    _/
 *               _/      _/    _/ _/    _/ _/_/_/  _/    _/
 *
 *             ***********************************************
 *                              PandA Project
 *                     URL: http://panda.dei.polimi.it
 *                       Politecnico di Milano - DEIB
 *                        System Architectures Group
 *             ***********************************************
 *              Copyright (C) 2023 Politecnico di Milano
 *
 *   This file is part of the PandA framework.
 *
 *   The PandA framework is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
/**
 * @file mdpi_user.h
 *
 * @author Michele Fiorito <michele.fiorito@polimi.it>
 * $Revision$
 * $Date$
 * Last modified by $Author$
 *
 */
#ifndef __MDPI_USER_H
#define __MDPI_USER_H

#ifndef EXTERN
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif
#endif

#include <stddef.h>
#include <stdint.h>

EXTERN_C void m_param_alloc(uint8_t idx, size_t size);

#ifndef __cplusplus
EXTERN_C float m_float_distancef(float, float) __attribute__((const));
EXTERN_C double m_float_distance(double, double) __attribute__((const));
EXTERN_C long double m_float_distancel(long double, long double) __attribute__((const));
EXTERN_C float m_floats_distancef(float, float) __attribute__((const));
EXTERN_C double m_floats_distance(double, double) __attribute__((const));
EXTERN_C long double m_floats_distancel(long double, long double) __attribute__((const));
#else
#include <algorithm>
#include <cassert>
#include <cmath>
#include <limits>

/*
 * m_float_distance was implemented based on the Boost implementation
 * whose copyright notice is reported below
 *
 * (C) Copyright John Maddock 2008.
 * Use, modification and distribution are subject to the
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
template <class T>
T m_floats_distance(const T& a, const T& b)
{
   //
   // Error handling:
   //
   if(std::isfinite(a) ^ std::isfinite(b))
      return std::numeric_limits<T>::max();

   //
   // Special cases:
   //
   if(a == b)
      return T(0);
   if(std::isinf(a) && std::isinf(b))
      return T(0);
   if(std::isnan(a) && std::isnan(b))
      return T(0);
   if(a > b)
      return m_floats_distance<T>(b, a);
   if(a == 0)
      return 1 + std::fabs(m_floats_distance<T>(static_cast<T>((b < 0) ? T(-std::numeric_limits<T>::epsilon()) :
                                                                         std::numeric_limits<T>::epsilon()),
                                                b));
   if(b == 0)
      return 1 + std::fabs(m_floats_distance<T>(static_cast<T>((a < 0) ? T(-std::numeric_limits<T>::epsilon()) :
                                                                         std::numeric_limits<T>::epsilon()),
                                                a));
   if((a > 0) != (b > 0))
      return 2 +
             std::fabs(m_floats_distance<T>(
                 static_cast<T>((b < 0) ? T(-std::numeric_limits<T>::epsilon()) : std::numeric_limits<T>::epsilon()),
                 b)) +
             std::fabs(m_floats_distance<T>(
                 static_cast<T>((a < 0) ? T(-std::numeric_limits<T>::epsilon()) : std::numeric_limits<T>::epsilon()),
                 a));
   //
   // By the time we get here, both a and b must have the same sign, we want
   // b > a and both positive for the following logic:
   //
   if(a < 0)
      return m_floats_distance<T>(static_cast<T>(-b), static_cast<T>(-a));

   assert(a >= 0);
   assert(b >= a);

   int expon;
   //
   // Note that if a is a denorm then the usual formula fails
   // because we actually have fewer than std::numeric_limits<T>::digits
   // significant bits in the representation:
   //
   (void)std::frexp(((std::fpclassify)(a) == (int)FP_SUBNORMAL) ? std::numeric_limits<T>::min() : a, &expon);
   T upper = std::ldexp(T(1), expon);
   T result = T(0);
   //
   // If b is greater than upper, then we *must* split the calculation
   // as the size of the ULP changes with each order of magnitude change:
   //
   if(b > upper)
   {
      int expon2;
      (void)std::frexp(b, &expon2);
      T upper2 = std::ldexp(T(0.5), expon2);
      result = m_floats_distance<T>(upper2, b);
      result += (expon2 - expon - 1) * std::ldexp(T(1), std::numeric_limits<T>::digits - 1);
   }
   //
   // Use compensated double-double addition to avoid rounding
   // errors in the subtraction:
   //
   expon = std::numeric_limits<T>::digits - expon;
   T mb, x, y, z;
   if(((std::fpclassify)(a) == (int)FP_SUBNORMAL) || (b - a < std::numeric_limits<T>::min()))
   {
      //
      // Special case - either one end of the range is a denormal, or else the difference is.
      // The regular code will fail if we're using the SSE2 registers on Intel and either
      // the FTZ or DAZ flags are set.
      //
      T a2 = std::ldexp(a, std::numeric_limits<T>::digits);
      T b2 = std::ldexp(b, std::numeric_limits<T>::digits);
      mb = -(std::min)(T(std::ldexp(upper, std::numeric_limits<T>::digits)), b2);
      x = a2 + mb;
      z = x - a2;
      y = (a2 - (x - z)) + (mb - z);

      expon -= std::numeric_limits<T>::digits;
   }
   else
   {
      mb = -(std::min)(upper, b);
      x = a + mb;
      z = x - a;
      y = (a - (x - z)) + (mb - z);
   }
   if(x < 0)
   {
      x = -x;
      y = -y;
   }
   result += std::ldexp(x, expon) + std::ldexp(y, expon);
   //
   // Result must be an integer:
   //
   assert(result == std::floor(result));
   return result;
}

template <class T>
T m_float_distance(const T& a, const T& b)
{
   return m_floats_distance<T>((std::fpclassify)(a) == (int)FP_SUBNORMAL ? copysign(T(0), a) : a,
                               (std::fpclassify)(b) == (int)FP_SUBNORMAL ? copysign(T(0), b) : b);
}
#endif

#endif // __MDPI_ALLOC_H